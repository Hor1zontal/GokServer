// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: star.proto

package protocol

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// 星球基本信息( 自己 )@brief wjl 20170601 新增
type StarInfoBase struct {
	StarID      int32  `protobuf:"varint,1,opt,name=starID,proto3" json:"starID,omitempty"`
	Type        int32  `protobuf:"varint,2,opt,name=type,proto3" json:"type,omitempty"`
	OwnID       int32  `protobuf:"varint,3,opt,name=ownID,proto3" json:"ownID,omitempty"`
	OwnNikeName string `protobuf:"bytes,4,opt,name=ownNikeName,proto3" json:"ownNikeName,omitempty"`
}

func (m *StarInfoBase) Reset()                    { *m = StarInfoBase{} }
func (m *StarInfoBase) String() string            { return proto.CompactTextString(m) }
func (*StarInfoBase) ProtoMessage()               {}
func (*StarInfoBase) Descriptor() ([]byte, []int) { return fileDescriptorStar, []int{0} }

func (m *StarInfoBase) GetStarID() int32 {
	if m != nil {
		return m.StarID
	}
	return 0
}

func (m *StarInfoBase) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *StarInfoBase) GetOwnID() int32 {
	if m != nil {
		return m.OwnID
	}
	return 0
}

func (m *StarInfoBase) GetOwnNikeName() string {
	if m != nil {
		return m.OwnNikeName
	}
	return ""
}

type TransmitUserStar struct {
	UserID int32 `protobuf:"varint,1,opt,name=userID,proto3" json:"userID,omitempty"`
}

func (m *TransmitUserStar) Reset()                    { *m = TransmitUserStar{} }
func (m *TransmitUserStar) String() string            { return proto.CompactTextString(m) }
func (*TransmitUserStar) ProtoMessage()               {}
func (*TransmitUserStar) Descriptor() ([]byte, []int) { return fileDescriptorStar, []int{1} }

func (m *TransmitUserStar) GetUserID() int32 {
	if m != nil {
		return m.UserID
	}
	return 0
}

type TransmitUserStarRet struct {
	//    bytes activeStar = 1;
	Stars [][]byte `protobuf:"bytes,1,rep,name=stars" json:"stars,omitempty"`
}

func (m *TransmitUserStarRet) Reset()                    { *m = TransmitUserStarRet{} }
func (m *TransmitUserStarRet) String() string            { return proto.CompactTextString(m) }
func (*TransmitUserStarRet) ProtoMessage()               {}
func (*TransmitUserStarRet) Descriptor() ([]byte, []int) { return fileDescriptorStar, []int{2} }

func (m *TransmitUserStarRet) GetStars() [][]byte {
	if m != nil {
		return m.Stars
	}
	return nil
}

type HelpRepairBuildPublic struct {
	BuildingType int32 `protobuf:"varint,1,opt,name=buildingType,proto3" json:"buildingType,omitempty"`
}

func (m *HelpRepairBuildPublic) Reset()                    { *m = HelpRepairBuildPublic{} }
func (m *HelpRepairBuildPublic) String() string            { return proto.CompactTextString(m) }
func (*HelpRepairBuildPublic) ProtoMessage()               {}
func (*HelpRepairBuildPublic) Descriptor() ([]byte, []int) { return fileDescriptorStar, []int{3} }

func (m *HelpRepairBuildPublic) GetBuildingType() int32 {
	if m != nil {
		return m.BuildingType
	}
	return 0
}

type HelpRepairBuildPublicRet struct {
	BuildingType int32 `protobuf:"varint,1,opt,name=buildingType,proto3" json:"buildingType,omitempty"`
}

func (m *HelpRepairBuildPublicRet) Reset()                    { *m = HelpRepairBuildPublicRet{} }
func (m *HelpRepairBuildPublicRet) String() string            { return proto.CompactTextString(m) }
func (*HelpRepairBuildPublicRet) ProtoMessage()               {}
func (*HelpRepairBuildPublicRet) Descriptor() ([]byte, []int) { return fileDescriptorStar, []int{4} }

func (m *HelpRepairBuildPublicRet) GetBuildingType() int32 {
	if m != nil {
		return m.BuildingType
	}
	return 0
}

type LoginStarInfo struct {
	Uid int32 `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
}

func (m *LoginStarInfo) Reset()                    { *m = LoginStarInfo{} }
func (m *LoginStarInfo) String() string            { return proto.CompactTextString(m) }
func (*LoginStarInfo) ProtoMessage()               {}
func (*LoginStarInfo) Descriptor() ([]byte, []int) { return fileDescriptorStar, []int{5} }

func (m *LoginStarInfo) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

type LoginStarInfoRet struct {
	Star             []*StarInfo      `protobuf:"bytes,1,rep,name=star" json:"star,omitempty"`
	CurrStar         *StarInfo        `protobuf:"bytes,2,opt,name=currStar" json:"currStar,omitempty"`
	PowerLimit       int32            `protobuf:"varint,5,opt,name=powerLimit,proto3" json:"powerLimit,omitempty"`
	UpgradedBuilding []*BuildingState `protobuf:"bytes,6,rep,name=upgradedBuilding" json:"upgradedBuilding,omitempty"`
	RepairedBuilding []*BuildingState `protobuf:"bytes,7,rep,name=repairedBuilding" json:"repairedBuilding,omitempty"`
	AllBuilding      []*BuildingState `protobuf:"bytes,8,rep,name=allBuilding" json:"allBuilding,omitempty"`
	StarFlags        []*FlagInfo      `protobuf:"bytes,9,rep,name=starFlags" json:"starFlags,omitempty"`
}

func (m *LoginStarInfoRet) Reset()                    { *m = LoginStarInfoRet{} }
func (m *LoginStarInfoRet) String() string            { return proto.CompactTextString(m) }
func (*LoginStarInfoRet) ProtoMessage()               {}
func (*LoginStarInfoRet) Descriptor() ([]byte, []int) { return fileDescriptorStar, []int{6} }

func (m *LoginStarInfoRet) GetStar() []*StarInfo {
	if m != nil {
		return m.Star
	}
	return nil
}

func (m *LoginStarInfoRet) GetCurrStar() *StarInfo {
	if m != nil {
		return m.CurrStar
	}
	return nil
}

func (m *LoginStarInfoRet) GetPowerLimit() int32 {
	if m != nil {
		return m.PowerLimit
	}
	return 0
}

func (m *LoginStarInfoRet) GetUpgradedBuilding() []*BuildingState {
	if m != nil {
		return m.UpgradedBuilding
	}
	return nil
}

func (m *LoginStarInfoRet) GetRepairedBuilding() []*BuildingState {
	if m != nil {
		return m.RepairedBuilding
	}
	return nil
}

func (m *LoginStarInfoRet) GetAllBuilding() []*BuildingState {
	if m != nil {
		return m.AllBuilding
	}
	return nil
}

func (m *LoginStarInfoRet) GetStarFlags() []*FlagInfo {
	if m != nil {
		return m.StarFlags
	}
	return nil
}

type BuildingState struct {
	StarType      int32 `protobuf:"varint,1,opt,name=starType,proto3" json:"starType,omitempty"`
	BuildingType  int32 `protobuf:"varint,2,opt,name=buildingType,proto3" json:"buildingType,omitempty"`
	BuildingLevel int32 `protobuf:"varint,3,opt,name=buildingLevel,proto3" json:"buildingLevel,omitempty"`
}

func (m *BuildingState) Reset()                    { *m = BuildingState{} }
func (m *BuildingState) String() string            { return proto.CompactTextString(m) }
func (*BuildingState) ProtoMessage()               {}
func (*BuildingState) Descriptor() ([]byte, []int) { return fileDescriptorStar, []int{7} }

func (m *BuildingState) GetStarType() int32 {
	if m != nil {
		return m.StarType
	}
	return 0
}

func (m *BuildingState) GetBuildingType() int32 {
	if m != nil {
		return m.BuildingType
	}
	return 0
}

func (m *BuildingState) GetBuildingLevel() int32 {
	if m != nil {
		return m.BuildingLevel
	}
	return 0
}

type StarInfo struct {
	StarID   int32 `protobuf:"varint,1,opt,name=starID,proto3" json:"starID,omitempty"`
	StarType int32 `protobuf:"varint,2,opt,name=starType,proto3" json:"starType,omitempty"`
}

func (m *StarInfo) Reset()                    { *m = StarInfo{} }
func (m *StarInfo) String() string            { return proto.CompactTextString(m) }
func (*StarInfo) ProtoMessage()               {}
func (*StarInfo) Descriptor() ([]byte, []int) { return fileDescriptorStar, []int{8} }

func (m *StarInfo) GetStarID() int32 {
	if m != nil {
		return m.StarID
	}
	return 0
}

func (m *StarInfo) GetStarType() int32 {
	if m != nil {
		return m.StarType
	}
	return 0
}

type GetStarsSelect struct {
	Num int32 `protobuf:"varint,1,opt,name=num,proto3" json:"num,omitempty"`
	Uid int32 `protobuf:"varint,2,opt,name=uid,proto3" json:"uid,omitempty"`
}

func (m *GetStarsSelect) Reset()                    { *m = GetStarsSelect{} }
func (m *GetStarsSelect) String() string            { return proto.CompactTextString(m) }
func (*GetStarsSelect) ProtoMessage()               {}
func (*GetStarsSelect) Descriptor() ([]byte, []int) { return fileDescriptorStar, []int{9} }

func (m *GetStarsSelect) GetNum() int32 {
	if m != nil {
		return m.Num
	}
	return 0
}

func (m *GetStarsSelect) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

type GetStarsSelectRet struct {
	StarsType []int32 `protobuf:"varint,1,rep,packed,name=starsType" json:"starsType,omitempty"`
}

func (m *GetStarsSelectRet) Reset()                    { *m = GetStarsSelectRet{} }
func (m *GetStarsSelectRet) String() string            { return proto.CompactTextString(m) }
func (*GetStarsSelectRet) ProtoMessage()               {}
func (*GetStarsSelectRet) Descriptor() ([]byte, []int) { return fileDescriptorStar, []int{10} }

func (m *GetStarsSelectRet) GetStarsType() []int32 {
	if m != nil {
		return m.StarsType
	}
	return nil
}

type SelectStar struct {
	StarType int32 `protobuf:"varint,1,opt,name=starType,proto3" json:"starType,omitempty"`
}

func (m *SelectStar) Reset()                    { *m = SelectStar{} }
func (m *SelectStar) String() string            { return proto.CompactTextString(m) }
func (*SelectStar) ProtoMessage()               {}
func (*SelectStar) Descriptor() ([]byte, []int) { return fileDescriptorStar, []int{11} }

func (m *SelectStar) GetStarType() int32 {
	if m != nil {
		return m.StarType
	}
	return 0
}

type SelectStarRet struct {
	Star         []*StarInfo     `protobuf:"bytes,1,rep,name=star" json:"star,omitempty"`
	CurrentStar  *StarInfoDetail `protobuf:"bytes,2,opt,name=currentStar" json:"currentStar,omitempty"`
	LastStarType int32           `protobuf:"varint,3,opt,name=lastStarType,proto3" json:"lastStarType,omitempty"`
	Faith        int32           `protobuf:"varint,4,opt,name=faith,proto3" json:"faith,omitempty"`
	Items        []int32         `protobuf:"varint,5,rep,packed,name=items" json:"items,omitempty"`
}

func (m *SelectStarRet) Reset()                    { *m = SelectStarRet{} }
func (m *SelectStarRet) String() string            { return proto.CompactTextString(m) }
func (*SelectStarRet) ProtoMessage()               {}
func (*SelectStarRet) Descriptor() ([]byte, []int) { return fileDescriptorStar, []int{12} }

func (m *SelectStarRet) GetStar() []*StarInfo {
	if m != nil {
		return m.Star
	}
	return nil
}

func (m *SelectStarRet) GetCurrentStar() *StarInfoDetail {
	if m != nil {
		return m.CurrentStar
	}
	return nil
}

func (m *SelectStarRet) GetLastStarType() int32 {
	if m != nil {
		return m.LastStarType
	}
	return 0
}

func (m *SelectStarRet) GetFaith() int32 {
	if m != nil {
		return m.Faith
	}
	return 0
}

func (m *SelectStarRet) GetItems() []int32 {
	if m != nil {
		return m.Items
	}
	return nil
}

// 获取用户星球信息
type GetStarInfo struct {
}

func (m *GetStarInfo) Reset()                    { *m = GetStarInfo{} }
func (m *GetStarInfo) String() string            { return proto.CompactTextString(m) }
func (*GetStarInfo) ProtoMessage()               {}
func (*GetStarInfo) Descriptor() ([]byte, []int) { return fileDescriptorStar, []int{13} }

// 获取用星球信息结果
type GetStarInfoRet struct {
	Star        []*StarInfo     `protobuf:"bytes,1,rep,name=star" json:"star,omitempty"`
	CurrentStar *StarInfoDetail `protobuf:"bytes,2,opt,name=currentStar" json:"currentStar,omitempty"`
}

func (m *GetStarInfoRet) Reset()                    { *m = GetStarInfoRet{} }
func (m *GetStarInfoRet) String() string            { return proto.CompactTextString(m) }
func (*GetStarInfoRet) ProtoMessage()               {}
func (*GetStarInfoRet) Descriptor() ([]byte, []int) { return fileDescriptorStar, []int{14} }

func (m *GetStarInfoRet) GetStar() []*StarInfo {
	if m != nil {
		return m.Star
	}
	return nil
}

func (m *GetStarInfoRet) GetCurrentStar() *StarInfoDetail {
	if m != nil {
		return m.CurrentStar
	}
	return nil
}

type GetStarShield struct {
}

func (m *GetStarShield) Reset()                    { *m = GetStarShield{} }
func (m *GetStarShield) String() string            { return proto.CompactTextString(m) }
func (*GetStarShield) ProtoMessage()               {}
func (*GetStarShield) Descriptor() ([]byte, []int) { return fileDescriptorStar, []int{15} }

type GetStarShieldRet struct {
	FaithShield    *Shield `protobuf:"bytes,1,opt,name=faithShield" json:"faithShield,omitempty"`
	BelieverShield *Shield `protobuf:"bytes,2,opt,name=believerShield" json:"believerShield,omitempty"`
	BuildingShield *Shield `protobuf:"bytes,3,opt,name=buildingShield" json:"buildingShield,omitempty"`
}

func (m *GetStarShieldRet) Reset()                    { *m = GetStarShieldRet{} }
func (m *GetStarShieldRet) String() string            { return proto.CompactTextString(m) }
func (*GetStarShieldRet) ProtoMessage()               {}
func (*GetStarShieldRet) Descriptor() ([]byte, []int) { return fileDescriptorStar, []int{16} }

func (m *GetStarShieldRet) GetFaithShield() *Shield {
	if m != nil {
		return m.FaithShield
	}
	return nil
}

func (m *GetStarShieldRet) GetBelieverShield() *Shield {
	if m != nil {
		return m.BelieverShield
	}
	return nil
}

func (m *GetStarShieldRet) GetBuildingShield() *Shield {
	if m != nil {
		return m.BuildingShield
	}
	return nil
}

type Shield struct {
	Value      int32 `protobuf:"varint,1,opt,name=value,proto3" json:"value,omitempty"`
	Limit      int32 `protobuf:"varint,2,opt,name=limit,proto3" json:"limit,omitempty"`
	UpdateTime int64 `protobuf:"varint,3,opt,name=updateTime,proto3" json:"updateTime,omitempty"`
}

func (m *Shield) Reset()                    { *m = Shield{} }
func (m *Shield) String() string            { return proto.CompactTextString(m) }
func (*Shield) ProtoMessage()               {}
func (*Shield) Descriptor() ([]byte, []int) { return fileDescriptorStar, []int{17} }

func (m *Shield) GetValue() int32 {
	if m != nil {
		return m.Value
	}
	return 0
}

func (m *Shield) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *Shield) GetUpdateTime() int64 {
	if m != nil {
		return m.UpdateTime
	}
	return 0
}

// 解锁星球推送
type OpenStarPush struct {
	Star *StarInfoDetail `protobuf:"bytes,1,opt,name=star" json:"star,omitempty"`
}

func (m *OpenStarPush) Reset()                    { *m = OpenStarPush{} }
func (m *OpenStarPush) String() string            { return proto.CompactTextString(m) }
func (*OpenStarPush) ProtoMessage()               {}
func (*OpenStarPush) Descriptor() ([]byte, []int) { return fileDescriptorStar, []int{18} }

func (m *OpenStarPush) GetStar() *StarInfoDetail {
	if m != nil {
		return m.Star
	}
	return nil
}

type SearchStarInfo struct {
	Uid int32 `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
}

func (m *SearchStarInfo) Reset()                    { *m = SearchStarInfo{} }
func (m *SearchStarInfo) String() string            { return proto.CompactTextString(m) }
func (*SearchStarInfo) ProtoMessage()               {}
func (*SearchStarInfo) Descriptor() ([]byte, []int) { return fileDescriptorStar, []int{19} }

func (m *SearchStarInfo) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

// 探索星球信息 wjl 20170531
type SearchStarInfoRet struct {
	Star *StarInfoDetail `protobuf:"bytes,1,opt,name=star" json:"star,omitempty"`
}

func (m *SearchStarInfoRet) Reset()                    { *m = SearchStarInfoRet{} }
func (m *SearchStarInfoRet) String() string            { return proto.CompactTextString(m) }
func (*SearchStarInfoRet) ProtoMessage()               {}
func (*SearchStarInfoRet) Descriptor() ([]byte, []int) { return fileDescriptorStar, []int{20} }

func (m *SearchStarInfoRet) GetStar() *StarInfoDetail {
	if m != nil {
		return m.Star
	}
	return nil
}

type GetStarInfoDetail struct {
	Uid                int32 `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
	StarID             int32 `protobuf:"varint,2,opt,name=starID,proto3" json:"starID,omitempty"`
	ShieldType         int32 `protobuf:"varint,3,opt,name=shieldType,proto3" json:"shieldType,omitempty"`
	IsConvert          bool  `protobuf:"varint,4,opt,name=isConvert,proto3" json:"isConvert,omitempty"`
	BelieverTotalLevel int32 `protobuf:"varint,5,opt,name=believerTotalLevel,proto3" json:"believerTotalLevel,omitempty"`
	BuildingTotalLevel int32 `protobuf:"varint,6,opt,name=buildingTotalLevel,proto3" json:"buildingTotalLevel,omitempty"`
}

func (m *GetStarInfoDetail) Reset()                    { *m = GetStarInfoDetail{} }
func (m *GetStarInfoDetail) String() string            { return proto.CompactTextString(m) }
func (*GetStarInfoDetail) ProtoMessage()               {}
func (*GetStarInfoDetail) Descriptor() ([]byte, []int) { return fileDescriptorStar, []int{21} }

func (m *GetStarInfoDetail) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *GetStarInfoDetail) GetStarID() int32 {
	if m != nil {
		return m.StarID
	}
	return 0
}

func (m *GetStarInfoDetail) GetShieldType() int32 {
	if m != nil {
		return m.ShieldType
	}
	return 0
}

func (m *GetStarInfoDetail) GetIsConvert() bool {
	if m != nil {
		return m.IsConvert
	}
	return false
}

func (m *GetStarInfoDetail) GetBelieverTotalLevel() int32 {
	if m != nil {
		return m.BelieverTotalLevel
	}
	return 0
}

func (m *GetStarInfoDetail) GetBuildingTotalLevel() int32 {
	if m != nil {
		return m.BuildingTotalLevel
	}
	return 0
}

type GetStarRecordInfo struct {
	Uid    int32   `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
	StarID []int32 `protobuf:"varint,2,rep,packed,name=StarID" json:"StarID,omitempty"`
	UserID []int32 `protobuf:"varint,3,rep,packed,name=UserID" json:"UserID,omitempty"`
}

func (m *GetStarRecordInfo) Reset()                    { *m = GetStarRecordInfo{} }
func (m *GetStarRecordInfo) String() string            { return proto.CompactTextString(m) }
func (*GetStarRecordInfo) ProtoMessage()               {}
func (*GetStarRecordInfo) Descriptor() ([]byte, []int) { return fileDescriptorStar, []int{22} }

func (m *GetStarRecordInfo) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *GetStarRecordInfo) GetStarID() []int32 {
	if m != nil {
		return m.StarID
	}
	return nil
}

func (m *GetStarRecordInfo) GetUserID() []int32 {
	if m != nil {
		return m.UserID
	}
	return nil
}

type SetStarRecordInfo struct {
	RecordType int32 `protobuf:"varint,1,opt,name=recordType,proto3" json:"recordType,omitempty"`
	RecordID   int32 `protobuf:"varint,2,opt,name=recordID,proto3" json:"recordID,omitempty"`
}

func (m *SetStarRecordInfo) Reset()                    { *m = SetStarRecordInfo{} }
func (m *SetStarRecordInfo) String() string            { return proto.CompactTextString(m) }
func (*SetStarRecordInfo) ProtoMessage()               {}
func (*SetStarRecordInfo) Descriptor() ([]byte, []int) { return fileDescriptorStar, []int{23} }

func (m *SetStarRecordInfo) GetRecordType() int32 {
	if m != nil {
		return m.RecordType
	}
	return 0
}

func (m *SetStarRecordInfo) GetRecordID() int32 {
	if m != nil {
		return m.RecordID
	}
	return 0
}

type DelStarRecordInfo struct {
	RecordType int32 `protobuf:"varint,1,opt,name=recordType,proto3" json:"recordType,omitempty"`
	RecordID   int32 `protobuf:"varint,2,opt,name=recordID,proto3" json:"recordID,omitempty"`
}

func (m *DelStarRecordInfo) Reset()                    { *m = DelStarRecordInfo{} }
func (m *DelStarRecordInfo) String() string            { return proto.CompactTextString(m) }
func (*DelStarRecordInfo) ProtoMessage()               {}
func (*DelStarRecordInfo) Descriptor() ([]byte, []int) { return fileDescriptorStar, []int{24} }

func (m *DelStarRecordInfo) GetRecordType() int32 {
	if m != nil {
		return m.RecordType
	}
	return 0
}

func (m *DelStarRecordInfo) GetRecordID() int32 {
	if m != nil {
		return m.RecordID
	}
	return 0
}

type ReplaceStarRecordInfo struct {
	RecordType      int32 `protobuf:"varint,1,opt,name=recordType,proto3" json:"recordType,omitempty"`
	RecordID        int32 `protobuf:"varint,2,opt,name=recordID,proto3" json:"recordID,omitempty"`
	ReplaceRecordID int32 `protobuf:"varint,3,opt,name=replaceRecordID,proto3" json:"replaceRecordID,omitempty"`
}

func (m *ReplaceStarRecordInfo) Reset()                    { *m = ReplaceStarRecordInfo{} }
func (m *ReplaceStarRecordInfo) String() string            { return proto.CompactTextString(m) }
func (*ReplaceStarRecordInfo) ProtoMessage()               {}
func (*ReplaceStarRecordInfo) Descriptor() ([]byte, []int) { return fileDescriptorStar, []int{25} }

func (m *ReplaceStarRecordInfo) GetRecordType() int32 {
	if m != nil {
		return m.RecordType
	}
	return 0
}

func (m *ReplaceStarRecordInfo) GetRecordID() int32 {
	if m != nil {
		return m.RecordID
	}
	return 0
}

func (m *ReplaceStarRecordInfo) GetReplaceRecordID() int32 {
	if m != nil {
		return m.ReplaceRecordID
	}
	return 0
}

type MoveStarRecordInfo struct {
	SrcType  int32 `protobuf:"varint,1,opt,name=srcType,proto3" json:"srcType,omitempty"`
	SrcID    int32 `protobuf:"varint,2,opt,name=srcID,proto3" json:"srcID,omitempty"`
	DestType int32 `protobuf:"varint,3,opt,name=destType,proto3" json:"destType,omitempty"`
	DestID   int32 `protobuf:"varint,4,opt,name=destID,proto3" json:"destID,omitempty"`
}

func (m *MoveStarRecordInfo) Reset()                    { *m = MoveStarRecordInfo{} }
func (m *MoveStarRecordInfo) String() string            { return proto.CompactTextString(m) }
func (*MoveStarRecordInfo) ProtoMessage()               {}
func (*MoveStarRecordInfo) Descriptor() ([]byte, []int) { return fileDescriptorStar, []int{26} }

func (m *MoveStarRecordInfo) GetSrcType() int32 {
	if m != nil {
		return m.SrcType
	}
	return 0
}

func (m *MoveStarRecordInfo) GetSrcID() int32 {
	if m != nil {
		return m.SrcID
	}
	return 0
}

func (m *MoveStarRecordInfo) GetDestType() int32 {
	if m != nil {
		return m.DestType
	}
	return 0
}

func (m *MoveStarRecordInfo) GetDestID() int32 {
	if m != nil {
		return m.DestID
	}
	return 0
}

type OccupyStar struct {
	Uid    int32 `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
	StarID int32 `protobuf:"varint,2,opt,name=starID,proto3" json:"starID,omitempty"`
}

func (m *OccupyStar) Reset()                    { *m = OccupyStar{} }
func (m *OccupyStar) String() string            { return proto.CompactTextString(m) }
func (*OccupyStar) ProtoMessage()               {}
func (*OccupyStar) Descriptor() ([]byte, []int) { return fileDescriptorStar, []int{27} }

func (m *OccupyStar) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *OccupyStar) GetStarID() int32 {
	if m != nil {
		return m.StarID
	}
	return 0
}

type GetHelpRepairInfo struct {
	BuildType int32 `protobuf:"varint,1,opt,name=buildType,proto3" json:"buildType,omitempty"`
}

func (m *GetHelpRepairInfo) Reset()                    { *m = GetHelpRepairInfo{} }
func (m *GetHelpRepairInfo) String() string            { return proto.CompactTextString(m) }
func (*GetHelpRepairInfo) ProtoMessage()               {}
func (*GetHelpRepairInfo) Descriptor() ([]byte, []int) { return fileDescriptorStar, []int{28} }

func (m *GetHelpRepairInfo) GetBuildType() int32 {
	if m != nil {
		return m.BuildType
	}
	return 0
}

type GetHelpRepairInfoRet struct {
	HelpRepairBuildInfo []*HelpRepairBuildInfo `protobuf:"bytes,1,rep,name=helpRepairBuildInfo" json:"helpRepairBuildInfo,omitempty"`
}

func (m *GetHelpRepairInfoRet) Reset()                    { *m = GetHelpRepairInfoRet{} }
func (m *GetHelpRepairInfoRet) String() string            { return proto.CompactTextString(m) }
func (*GetHelpRepairInfoRet) ProtoMessage()               {}
func (*GetHelpRepairInfoRet) Descriptor() ([]byte, []int) { return fileDescriptorStar, []int{29} }

func (m *GetHelpRepairInfoRet) GetHelpRepairBuildInfo() []*HelpRepairBuildInfo {
	if m != nil {
		return m.HelpRepairBuildInfo
	}
	return nil
}

type HelpRepairBuildInfo struct {
	BuildingType int32 `protobuf:"varint,1,opt,name=buildingType,proto3" json:"buildingType,omitempty"`
	RepairTime   int64 `protobuf:"varint,2,opt,name=repairTime,proto3" json:"repairTime,omitempty"`
	BrokenTime   int64 `protobuf:"varint,3,opt,name=brokenTime,proto3" json:"brokenTime,omitempty"`
	HelpID       int32 `protobuf:"varint,4,opt,name=helpID,proto3" json:"helpID,omitempty"`
}

func (m *HelpRepairBuildInfo) Reset()                    { *m = HelpRepairBuildInfo{} }
func (m *HelpRepairBuildInfo) String() string            { return proto.CompactTextString(m) }
func (*HelpRepairBuildInfo) ProtoMessage()               {}
func (*HelpRepairBuildInfo) Descriptor() ([]byte, []int) { return fileDescriptorStar, []int{30} }

func (m *HelpRepairBuildInfo) GetBuildingType() int32 {
	if m != nil {
		return m.BuildingType
	}
	return 0
}

func (m *HelpRepairBuildInfo) GetRepairTime() int64 {
	if m != nil {
		return m.RepairTime
	}
	return 0
}

func (m *HelpRepairBuildInfo) GetBrokenTime() int64 {
	if m != nil {
		return m.BrokenTime
	}
	return 0
}

func (m *HelpRepairBuildInfo) GetHelpID() int32 {
	if m != nil {
		return m.HelpID
	}
	return 0
}

type HelpRepairBuild struct {
	BuildingType int32 `protobuf:"varint,1,opt,name=buildingType,proto3" json:"buildingType,omitempty"`
	HelperID     int32 `protobuf:"varint,2,opt,name=helperID,proto3" json:"helperID,omitempty"`
}

func (m *HelpRepairBuild) Reset()                    { *m = HelpRepairBuild{} }
func (m *HelpRepairBuild) String() string            { return proto.CompactTextString(m) }
func (*HelpRepairBuild) ProtoMessage()               {}
func (*HelpRepairBuild) Descriptor() ([]byte, []int) { return fileDescriptorStar, []int{31} }

func (m *HelpRepairBuild) GetBuildingType() int32 {
	if m != nil {
		return m.BuildingType
	}
	return 0
}

func (m *HelpRepairBuild) GetHelperID() int32 {
	if m != nil {
		return m.HelperID
	}
	return 0
}

type HelpRepairBuildRet struct {
	Result        bool  `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
	BuildingLevel int32 `protobuf:"varint,2,opt,name=buildingLevel,proto3" json:"buildingLevel,omitempty"`
	StarType      int32 `protobuf:"varint,3,opt,name=starType,proto3" json:"starType,omitempty"`
}

func (m *HelpRepairBuildRet) Reset()                    { *m = HelpRepairBuildRet{} }
func (m *HelpRepairBuildRet) String() string            { return proto.CompactTextString(m) }
func (*HelpRepairBuildRet) ProtoMessage()               {}
func (*HelpRepairBuildRet) Descriptor() ([]byte, []int) { return fileDescriptorStar, []int{32} }

func (m *HelpRepairBuildRet) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func (m *HelpRepairBuildRet) GetBuildingLevel() int32 {
	if m != nil {
		return m.BuildingLevel
	}
	return 0
}

func (m *HelpRepairBuildRet) GetStarType() int32 {
	if m != nil {
		return m.StarType
	}
	return 0
}

type GetCurrentGroupItems struct {
}

func (m *GetCurrentGroupItems) Reset()                    { *m = GetCurrentGroupItems{} }
func (m *GetCurrentGroupItems) String() string            { return proto.CompactTextString(m) }
func (*GetCurrentGroupItems) ProtoMessage()               {}
func (*GetCurrentGroupItems) Descriptor() ([]byte, []int) { return fileDescriptorStar, []int{33} }

type GetCurrentGroupItemsRet struct {
	ItemIDs []int32 `protobuf:"varint,1,rep,packed,name=itemIDs" json:"itemIDs,omitempty"`
	GroupID int32   `protobuf:"varint,2,opt,name=groupID,proto3" json:"groupID,omitempty"`
}

func (m *GetCurrentGroupItemsRet) Reset()                    { *m = GetCurrentGroupItemsRet{} }
func (m *GetCurrentGroupItemsRet) String() string            { return proto.CompactTextString(m) }
func (*GetCurrentGroupItemsRet) ProtoMessage()               {}
func (*GetCurrentGroupItemsRet) Descriptor() ([]byte, []int) { return fileDescriptorStar, []int{34} }

func (m *GetCurrentGroupItemsRet) GetItemIDs() []int32 {
	if m != nil {
		return m.ItemIDs
	}
	return nil
}

func (m *GetCurrentGroupItemsRet) GetGroupID() int32 {
	if m != nil {
		return m.GroupID
	}
	return 0
}

type GetEventStarInfo struct {
	Uid int32 `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
}

func (m *GetEventStarInfo) Reset()                    { *m = GetEventStarInfo{} }
func (m *GetEventStarInfo) String() string            { return proto.CompactTextString(m) }
func (*GetEventStarInfo) ProtoMessage()               {}
func (*GetEventStarInfo) Descriptor() ([]byte, []int) { return fileDescriptorStar, []int{35} }

func (m *GetEventStarInfo) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

type GetEventStarInfoRet struct {
	StarInfo *StarInfoDetail `protobuf:"bytes,1,opt,name=starInfo" json:"starInfo,omitempty"`
}

func (m *GetEventStarInfoRet) Reset()                    { *m = GetEventStarInfoRet{} }
func (m *GetEventStarInfoRet) String() string            { return proto.CompactTextString(m) }
func (*GetEventStarInfoRet) ProtoMessage()               {}
func (*GetEventStarInfoRet) Descriptor() ([]byte, []int) { return fileDescriptorStar, []int{36} }

func (m *GetEventStarInfoRet) GetStarInfo() *StarInfoDetail {
	if m != nil {
		return m.StarInfo
	}
	return nil
}

// 分配一个用户的初始星球
type AllocNewStar struct {
	Uid      int32 `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
	StarType int32 `protobuf:"varint,2,opt,name=starType,proto3" json:"starType,omitempty"`
}

func (m *AllocNewStar) Reset()                    { *m = AllocNewStar{} }
func (m *AllocNewStar) String() string            { return proto.CompactTextString(m) }
func (*AllocNewStar) ProtoMessage()               {}
func (*AllocNewStar) Descriptor() ([]byte, []int) { return fileDescriptorStar, []int{37} }

func (m *AllocNewStar) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *AllocNewStar) GetStarType() int32 {
	if m != nil {
		return m.StarType
	}
	return 0
}

type AllocNewStarRet struct {
	Star         []*StarInfo     `protobuf:"bytes,1,rep,name=star" json:"star,omitempty"`
	CurrentStar  *StarInfoDetail `protobuf:"bytes,2,opt,name=currentStar" json:"currentStar,omitempty"`
	LastStarType int32           `protobuf:"varint,3,opt,name=lastStarType,proto3" json:"lastStarType,omitempty"`
	Faith        int32           `protobuf:"varint,4,opt,name=faith,proto3" json:"faith,omitempty"`
	Items        []int32         `protobuf:"varint,5,rep,packed,name=items" json:"items,omitempty"`
	IsFirst      bool            `protobuf:"varint,6,opt,name=isFirst,proto3" json:"isFirst,omitempty"`
}

func (m *AllocNewStarRet) Reset()                    { *m = AllocNewStarRet{} }
func (m *AllocNewStarRet) String() string            { return proto.CompactTextString(m) }
func (*AllocNewStarRet) ProtoMessage()               {}
func (*AllocNewStarRet) Descriptor() ([]byte, []int) { return fileDescriptorStar, []int{38} }

func (m *AllocNewStarRet) GetStar() []*StarInfo {
	if m != nil {
		return m.Star
	}
	return nil
}

func (m *AllocNewStarRet) GetCurrentStar() *StarInfoDetail {
	if m != nil {
		return m.CurrentStar
	}
	return nil
}

func (m *AllocNewStarRet) GetLastStarType() int32 {
	if m != nil {
		return m.LastStarType
	}
	return 0
}

func (m *AllocNewStarRet) GetFaith() int32 {
	if m != nil {
		return m.Faith
	}
	return 0
}

func (m *AllocNewStarRet) GetItems() []int32 {
	if m != nil {
		return m.Items
	}
	return nil
}

func (m *AllocNewStarRet) GetIsFirst() bool {
	if m != nil {
		return m.IsFirst
	}
	return false
}

// 获取用户的当前开发星球信息
type UserStarInfo struct {
	Uid int32 `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
}

func (m *UserStarInfo) Reset()                    { *m = UserStarInfo{} }
func (m *UserStarInfo) String() string            { return proto.CompactTextString(m) }
func (*UserStarInfo) ProtoMessage()               {}
func (*UserStarInfo) Descriptor() ([]byte, []int) { return fileDescriptorStar, []int{39} }

func (m *UserStarInfo) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

type UserStarInfoRet struct {
	CurrentStar int32           `protobuf:"varint,1,opt,name=currentStar,proto3" json:"currentStar,omitempty"`
	Star        *StarInfoDetail `protobuf:"bytes,2,opt,name=star" json:"star,omitempty"`
}

func (m *UserStarInfoRet) Reset()                    { *m = UserStarInfoRet{} }
func (m *UserStarInfoRet) String() string            { return proto.CompactTextString(m) }
func (*UserStarInfoRet) ProtoMessage()               {}
func (*UserStarInfoRet) Descriptor() ([]byte, []int) { return fileDescriptorStar, []int{40} }

func (m *UserStarInfoRet) GetCurrentStar() int32 {
	if m != nil {
		return m.CurrentStar
	}
	return 0
}

func (m *UserStarInfoRet) GetStar() *StarInfoDetail {
	if m != nil {
		return m.Star
	}
	return nil
}

type GetStarInfoDetailRet struct {
	Star   *StarInfoDetail `protobuf:"bytes,1,opt,name=star" json:"star,omitempty"`
	Shield *Shield         `protobuf:"bytes,2,opt,name=shield" json:"shield,omitempty"`
}

func (m *GetStarInfoDetailRet) Reset()                    { *m = GetStarInfoDetailRet{} }
func (m *GetStarInfoDetailRet) String() string            { return proto.CompactTextString(m) }
func (*GetStarInfoDetailRet) ProtoMessage()               {}
func (*GetStarInfoDetailRet) Descriptor() ([]byte, []int) { return fileDescriptorStar, []int{41} }

func (m *GetStarInfoDetailRet) GetStar() *StarInfoDetail {
	if m != nil {
		return m.Star
	}
	return nil
}

func (m *GetStarInfoDetailRet) GetShield() *Shield {
	if m != nil {
		return m.Shield
	}
	return nil
}

type GetStarInfoCompleteRet struct {
	Star []*StarInfoDetail `protobuf:"bytes,1,rep,name=star" json:"star,omitempty"`
}

func (m *GetStarInfoCompleteRet) Reset()                    { *m = GetStarInfoCompleteRet{} }
func (m *GetStarInfoCompleteRet) String() string            { return proto.CompactTextString(m) }
func (*GetStarInfoCompleteRet) ProtoMessage()               {}
func (*GetStarInfoCompleteRet) Descriptor() ([]byte, []int) { return fileDescriptorStar, []int{42} }

func (m *GetStarInfoCompleteRet) GetStar() []*StarInfoDetail {
	if m != nil {
		return m.Star
	}
	return nil
}

type GetStarRecordInfoRet struct {
	StarsOri  []*StarInfoBase `protobuf:"bytes,1,rep,name=stars_ori,json=starsOri" json:"stars_ori,omitempty"`
	StarsUser []*StarInfoBase `protobuf:"bytes,2,rep,name=stars_user,json=starsUser" json:"stars_user,omitempty"`
}

func (m *GetStarRecordInfoRet) Reset()                    { *m = GetStarRecordInfoRet{} }
func (m *GetStarRecordInfoRet) String() string            { return proto.CompactTextString(m) }
func (*GetStarRecordInfoRet) ProtoMessage()               {}
func (*GetStarRecordInfoRet) Descriptor() ([]byte, []int) { return fileDescriptorStar, []int{43} }

func (m *GetStarRecordInfoRet) GetStarsOri() []*StarInfoBase {
	if m != nil {
		return m.StarsOri
	}
	return nil
}

func (m *GetStarRecordInfoRet) GetStarsUser() []*StarInfoBase {
	if m != nil {
		return m.StarsUser
	}
	return nil
}

type SetStarRecordInfoRet struct {
	RecordType int32 `protobuf:"varint,1,opt,name=recordType,proto3" json:"recordType,omitempty"`
	RecordID   int32 `protobuf:"varint,2,opt,name=recordID,proto3" json:"recordID,omitempty"`
}

func (m *SetStarRecordInfoRet) Reset()                    { *m = SetStarRecordInfoRet{} }
func (m *SetStarRecordInfoRet) String() string            { return proto.CompactTextString(m) }
func (*SetStarRecordInfoRet) ProtoMessage()               {}
func (*SetStarRecordInfoRet) Descriptor() ([]byte, []int) { return fileDescriptorStar, []int{44} }

func (m *SetStarRecordInfoRet) GetRecordType() int32 {
	if m != nil {
		return m.RecordType
	}
	return 0
}

func (m *SetStarRecordInfoRet) GetRecordID() int32 {
	if m != nil {
		return m.RecordID
	}
	return 0
}

type DelStarRecordInfoRet struct {
	RecordType int32 `protobuf:"varint,1,opt,name=recordType,proto3" json:"recordType,omitempty"`
	RecordID   int32 `protobuf:"varint,2,opt,name=recordID,proto3" json:"recordID,omitempty"`
}

func (m *DelStarRecordInfoRet) Reset()                    { *m = DelStarRecordInfoRet{} }
func (m *DelStarRecordInfoRet) String() string            { return proto.CompactTextString(m) }
func (*DelStarRecordInfoRet) ProtoMessage()               {}
func (*DelStarRecordInfoRet) Descriptor() ([]byte, []int) { return fileDescriptorStar, []int{45} }

func (m *DelStarRecordInfoRet) GetRecordType() int32 {
	if m != nil {
		return m.RecordType
	}
	return 0
}

func (m *DelStarRecordInfoRet) GetRecordID() int32 {
	if m != nil {
		return m.RecordID
	}
	return 0
}

type ReplaceStarRecordInfoRet struct {
	RecordType      int32 `protobuf:"varint,1,opt,name=recordType,proto3" json:"recordType,omitempty"`
	RecordID        int32 `protobuf:"varint,2,opt,name=recordID,proto3" json:"recordID,omitempty"`
	ReplaceRecordID int32 `protobuf:"varint,3,opt,name=replaceRecordID,proto3" json:"replaceRecordID,omitempty"`
}

func (m *ReplaceStarRecordInfoRet) Reset()                    { *m = ReplaceStarRecordInfoRet{} }
func (m *ReplaceStarRecordInfoRet) String() string            { return proto.CompactTextString(m) }
func (*ReplaceStarRecordInfoRet) ProtoMessage()               {}
func (*ReplaceStarRecordInfoRet) Descriptor() ([]byte, []int) { return fileDescriptorStar, []int{46} }

func (m *ReplaceStarRecordInfoRet) GetRecordType() int32 {
	if m != nil {
		return m.RecordType
	}
	return 0
}

func (m *ReplaceStarRecordInfoRet) GetRecordID() int32 {
	if m != nil {
		return m.RecordID
	}
	return 0
}

func (m *ReplaceStarRecordInfoRet) GetReplaceRecordID() int32 {
	if m != nil {
		return m.ReplaceRecordID
	}
	return 0
}

type MoveStarRecordInfoRet struct {
	SrcType  int32 `protobuf:"varint,1,opt,name=srcType,proto3" json:"srcType,omitempty"`
	SrcID    int32 `protobuf:"varint,2,opt,name=srcID,proto3" json:"srcID,omitempty"`
	DestType int32 `protobuf:"varint,3,opt,name=destType,proto3" json:"destType,omitempty"`
	DestID   int32 `protobuf:"varint,4,opt,name=destID,proto3" json:"destID,omitempty"`
}

func (m *MoveStarRecordInfoRet) Reset()                    { *m = MoveStarRecordInfoRet{} }
func (m *MoveStarRecordInfoRet) String() string            { return proto.CompactTextString(m) }
func (*MoveStarRecordInfoRet) ProtoMessage()               {}
func (*MoveStarRecordInfoRet) Descriptor() ([]byte, []int) { return fileDescriptorStar, []int{47} }

func (m *MoveStarRecordInfoRet) GetSrcType() int32 {
	if m != nil {
		return m.SrcType
	}
	return 0
}

func (m *MoveStarRecordInfoRet) GetSrcID() int32 {
	if m != nil {
		return m.SrcID
	}
	return 0
}

func (m *MoveStarRecordInfoRet) GetDestType() int32 {
	if m != nil {
		return m.DestType
	}
	return 0
}

func (m *MoveStarRecordInfoRet) GetDestID() int32 {
	if m != nil {
		return m.DestID
	}
	return 0
}

type OccupyStarRet struct {
	Uid     int32           `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
	StarOld *StarInfoDetail `protobuf:"bytes,2,opt,name=starOld" json:"starOld,omitempty"`
	Star    *StarInfoDetail `protobuf:"bytes,3,opt,name=star" json:"star,omitempty"`
}

func (m *OccupyStarRet) Reset()                    { *m = OccupyStarRet{} }
func (m *OccupyStarRet) String() string            { return proto.CompactTextString(m) }
func (*OccupyStarRet) ProtoMessage()               {}
func (*OccupyStarRet) Descriptor() ([]byte, []int) { return fileDescriptorStar, []int{48} }

func (m *OccupyStarRet) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *OccupyStarRet) GetStarOld() *StarInfoDetail {
	if m != nil {
		return m.StarOld
	}
	return nil
}

func (m *OccupyStarRet) GetStar() *StarInfoDetail {
	if m != nil {
		return m.Star
	}
	return nil
}

type AddCivilization struct {
	CivilizationValue int32 `protobuf:"varint,1,opt,name=civilizationValue,proto3" json:"civilizationValue,omitempty"`
}

func (m *AddCivilization) Reset()                    { *m = AddCivilization{} }
func (m *AddCivilization) String() string            { return proto.CompactTextString(m) }
func (*AddCivilization) ProtoMessage()               {}
func (*AddCivilization) Descriptor() ([]byte, []int) { return fileDescriptorStar, []int{49} }

func (m *AddCivilization) GetCivilizationValue() int32 {
	if m != nil {
		return m.CivilizationValue
	}
	return 0
}

type DrawCivilizationReward struct {
	Uid       int32 `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
	StarID    int32 `protobuf:"varint,2,opt,name=starID,proto3" json:"starID,omitempty"`
	DrawLevel int32 `protobuf:"varint,3,opt,name=drawLevel,proto3" json:"drawLevel,omitempty"`
}

func (m *DrawCivilizationReward) Reset()                    { *m = DrawCivilizationReward{} }
func (m *DrawCivilizationReward) String() string            { return proto.CompactTextString(m) }
func (*DrawCivilizationReward) ProtoMessage()               {}
func (*DrawCivilizationReward) Descriptor() ([]byte, []int) { return fileDescriptorStar, []int{50} }

func (m *DrawCivilizationReward) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *DrawCivilizationReward) GetStarID() int32 {
	if m != nil {
		return m.StarID
	}
	return 0
}

func (m *DrawCivilizationReward) GetDrawLevel() int32 {
	if m != nil {
		return m.DrawLevel
	}
	return 0
}

type DrawCivilizationRewardRet struct {
	StarID      int32    `protobuf:"varint,1,opt,name=starID,proto3" json:"starID,omitempty"`
	DrawLevel   int32    `protobuf:"varint,2,opt,name=drawLevel,proto3" json:"drawLevel,omitempty"`
	Reward      int32    `protobuf:"varint,3,opt,name=reward,proto3" json:"reward,omitempty"`
	Faith       int32    `protobuf:"varint,4,opt,name=faith,proto3" json:"faith,omitempty"`
	Diamond     int32    `protobuf:"varint,5,opt,name=diamond,proto3" json:"diamond,omitempty"`
	GayPiont    int32    `protobuf:"varint,6,opt,name=gayPiont,proto3" json:"gayPiont,omitempty"`
	Believer    []string `protobuf:"bytes,7,rep,name=believer" json:"believer,omitempty"`
	BelieverNum []int32  `protobuf:"varint,8,rep,packed,name=believerNum" json:"believerNum,omitempty"`
}

func (m *DrawCivilizationRewardRet) Reset()                    { *m = DrawCivilizationRewardRet{} }
func (m *DrawCivilizationRewardRet) String() string            { return proto.CompactTextString(m) }
func (*DrawCivilizationRewardRet) ProtoMessage()               {}
func (*DrawCivilizationRewardRet) Descriptor() ([]byte, []int) { return fileDescriptorStar, []int{51} }

func (m *DrawCivilizationRewardRet) GetStarID() int32 {
	if m != nil {
		return m.StarID
	}
	return 0
}

func (m *DrawCivilizationRewardRet) GetDrawLevel() int32 {
	if m != nil {
		return m.DrawLevel
	}
	return 0
}

func (m *DrawCivilizationRewardRet) GetReward() int32 {
	if m != nil {
		return m.Reward
	}
	return 0
}

func (m *DrawCivilizationRewardRet) GetFaith() int32 {
	if m != nil {
		return m.Faith
	}
	return 0
}

func (m *DrawCivilizationRewardRet) GetDiamond() int32 {
	if m != nil {
		return m.Diamond
	}
	return 0
}

func (m *DrawCivilizationRewardRet) GetGayPiont() int32 {
	if m != nil {
		return m.GayPiont
	}
	return 0
}

func (m *DrawCivilizationRewardRet) GetBeliever() []string {
	if m != nil {
		return m.Believer
	}
	return nil
}

func (m *DrawCivilizationRewardRet) GetBelieverNum() []int32 {
	if m != nil {
		return m.BelieverNum
	}
	return nil
}

type StarSettle struct {
}

func (m *StarSettle) Reset()                    { *m = StarSettle{} }
func (m *StarSettle) String() string            { return proto.CompactTextString(m) }
func (*StarSettle) ProtoMessage()               {}
func (*StarSettle) Descriptor() ([]byte, []int) { return fileDescriptorStar, []int{52} }

type StarSettleRet struct {
	RankNum   int32 `protobuf:"varint,1,opt,name=rankNum,proto3" json:"rankNum,omitempty"`
	TotalRank int32 `protobuf:"varint,2,opt,name=totalRank,proto3" json:"totalRank,omitempty"`
	PassTime  int64 `protobuf:"varint,3,opt,name=passTime,proto3" json:"passTime,omitempty"`
}

func (m *StarSettleRet) Reset()                    { *m = StarSettleRet{} }
func (m *StarSettleRet) String() string            { return proto.CompactTextString(m) }
func (*StarSettleRet) ProtoMessage()               {}
func (*StarSettleRet) Descriptor() ([]byte, []int) { return fileDescriptorStar, []int{53} }

func (m *StarSettleRet) GetRankNum() int32 {
	if m != nil {
		return m.RankNum
	}
	return 0
}

func (m *StarSettleRet) GetTotalRank() int32 {
	if m != nil {
		return m.TotalRank
	}
	return 0
}

func (m *StarSettleRet) GetPassTime() int64 {
	if m != nil {
		return m.PassTime
	}
	return 0
}

type StarFlagInfo struct {
}

func (m *StarFlagInfo) Reset()                    { *m = StarFlagInfo{} }
func (m *StarFlagInfo) String() string            { return proto.CompactTextString(m) }
func (*StarFlagInfo) ProtoMessage()               {}
func (*StarFlagInfo) Descriptor() ([]byte, []int) { return fileDescriptorStar, []int{54} }

type StarFlagInfoRet struct {
	Flags []*FlagInfo `protobuf:"bytes,1,rep,name=flags" json:"flags,omitempty"`
}

func (m *StarFlagInfoRet) Reset()                    { *m = StarFlagInfoRet{} }
func (m *StarFlagInfoRet) String() string            { return proto.CompactTextString(m) }
func (*StarFlagInfoRet) ProtoMessage()               {}
func (*StarFlagInfoRet) Descriptor() ([]byte, []int) { return fileDescriptorStar, []int{55} }

func (m *StarFlagInfoRet) GetFlags() []*FlagInfo {
	if m != nil {
		return m.Flags
	}
	return nil
}

type UpdateStarFlag struct {
	Flag  int32 `protobuf:"varint,1,opt,name=flag,proto3" json:"flag,omitempty"`
	Value int32 `protobuf:"varint,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *UpdateStarFlag) Reset()                    { *m = UpdateStarFlag{} }
func (m *UpdateStarFlag) String() string            { return proto.CompactTextString(m) }
func (*UpdateStarFlag) ProtoMessage()               {}
func (*UpdateStarFlag) Descriptor() ([]byte, []int) { return fileDescriptorStar, []int{56} }

func (m *UpdateStarFlag) GetFlag() int32 {
	if m != nil {
		return m.Flag
	}
	return 0
}

func (m *UpdateStarFlag) GetValue() int32 {
	if m != nil {
		return m.Value
	}
	return 0
}

type UpdateStarFlagRet struct {
	Flag *FlagInfo `protobuf:"bytes,1,opt,name=flag" json:"flag,omitempty"`
}

func (m *UpdateStarFlagRet) Reset()                    { *m = UpdateStarFlagRet{} }
func (m *UpdateStarFlagRet) String() string            { return proto.CompactTextString(m) }
func (*UpdateStarFlagRet) ProtoMessage()               {}
func (*UpdateStarFlagRet) Descriptor() ([]byte, []int) { return fileDescriptorStar, []int{57} }

func (m *UpdateStarFlagRet) GetFlag() *FlagInfo {
	if m != nil {
		return m.Flag
	}
	return nil
}

type UpdateAllStarFlag struct {
	Key   int32 `protobuf:"varint,1,opt,name=key,proto3" json:"key,omitempty"`
	Value int32 `protobuf:"varint,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *UpdateAllStarFlag) Reset()                    { *m = UpdateAllStarFlag{} }
func (m *UpdateAllStarFlag) String() string            { return proto.CompactTextString(m) }
func (*UpdateAllStarFlag) ProtoMessage()               {}
func (*UpdateAllStarFlag) Descriptor() ([]byte, []int) { return fileDescriptorStar, []int{58} }

func (m *UpdateAllStarFlag) GetKey() int32 {
	if m != nil {
		return m.Key
	}
	return 0
}

func (m *UpdateAllStarFlag) GetValue() int32 {
	if m != nil {
		return m.Value
	}
	return 0
}

type UpdateAllStarFlagRet struct {
	Result bool `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
}

func (m *UpdateAllStarFlagRet) Reset()                    { *m = UpdateAllStarFlagRet{} }
func (m *UpdateAllStarFlagRet) String() string            { return proto.CompactTextString(m) }
func (*UpdateAllStarFlagRet) ProtoMessage()               {}
func (*UpdateAllStarFlagRet) Descriptor() ([]byte, []int) { return fileDescriptorStar, []int{59} }

func (m *UpdateAllStarFlagRet) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

type GetOwnersByCondition struct {
	Start   int64 `protobuf:"varint,1,opt,name=start,proto3" json:"start,omitempty"`
	End     int64 `protobuf:"varint,2,opt,name=end,proto3" json:"end,omitempty"`
	Limit   int32 `protobuf:"varint,3,opt,name=limit,proto3" json:"limit,omitempty"`
	BuildLv int32 `protobuf:"varint,4,opt,name=buildLv,proto3" json:"buildLv,omitempty"`
	Skip    int32 `protobuf:"varint,5,opt,name=skip,proto3" json:"skip,omitempty"`
}

func (m *GetOwnersByCondition) Reset()                    { *m = GetOwnersByCondition{} }
func (m *GetOwnersByCondition) String() string            { return proto.CompactTextString(m) }
func (*GetOwnersByCondition) ProtoMessage()               {}
func (*GetOwnersByCondition) Descriptor() ([]byte, []int) { return fileDescriptorStar, []int{60} }

func (m *GetOwnersByCondition) GetStart() int64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *GetOwnersByCondition) GetEnd() int64 {
	if m != nil {
		return m.End
	}
	return 0
}

func (m *GetOwnersByCondition) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *GetOwnersByCondition) GetBuildLv() int32 {
	if m != nil {
		return m.BuildLv
	}
	return 0
}

func (m *GetOwnersByCondition) GetSkip() int32 {
	if m != nil {
		return m.Skip
	}
	return 0
}

type GetOwnersByConditionRet struct {
	Count    int32           `protobuf:"varint,1,opt,name=count,proto3" json:"count,omitempty"`
	UserData []*UserStarData `protobuf:"bytes,2,rep,name=userData" json:"userData,omitempty"`
}

func (m *GetOwnersByConditionRet) Reset()                    { *m = GetOwnersByConditionRet{} }
func (m *GetOwnersByConditionRet) String() string            { return proto.CompactTextString(m) }
func (*GetOwnersByConditionRet) ProtoMessage()               {}
func (*GetOwnersByConditionRet) Descriptor() ([]byte, []int) { return fileDescriptorStar, []int{61} }

func (m *GetOwnersByConditionRet) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *GetOwnersByConditionRet) GetUserData() []*UserStarData {
	if m != nil {
		return m.UserData
	}
	return nil
}

type UserStarData struct {
	Uid        int32           `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
	Believers  []*BelieverInfo `protobuf:"bytes,2,rep,name=believers" json:"believers,omitempty"`
	StarStatis []*Statistics   `protobuf:"bytes,3,rep,name=starStatis" json:"starStatis,omitempty"`
	UserStatis []*Statistics   `protobuf:"bytes,4,rep,name=UserStatis" json:"UserStatis,omitempty"`
}

func (m *UserStarData) Reset()                    { *m = UserStarData{} }
func (m *UserStarData) String() string            { return proto.CompactTextString(m) }
func (*UserStarData) ProtoMessage()               {}
func (*UserStarData) Descriptor() ([]byte, []int) { return fileDescriptorStar, []int{62} }

func (m *UserStarData) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *UserStarData) GetBelievers() []*BelieverInfo {
	if m != nil {
		return m.Believers
	}
	return nil
}

func (m *UserStarData) GetStarStatis() []*Statistics {
	if m != nil {
		return m.StarStatis
	}
	return nil
}

func (m *UserStarData) GetUserStatis() []*Statistics {
	if m != nil {
		return m.UserStatis
	}
	return nil
}

func init() {
	proto.RegisterType((*StarInfoBase)(nil), "protocol.star_info_base")
	proto.RegisterType((*TransmitUserStar)(nil), "protocol.transmit_user_star")
	proto.RegisterType((*TransmitUserStarRet)(nil), "protocol.transmit_user_star_ret")
	proto.RegisterType((*HelpRepairBuildPublic)(nil), "protocol.help_repair_build_public")
	proto.RegisterType((*HelpRepairBuildPublicRet)(nil), "protocol.help_repair_build_public_ret")
	proto.RegisterType((*LoginStarInfo)(nil), "protocol.login_star_info")
	proto.RegisterType((*LoginStarInfoRet)(nil), "protocol.login_star_info_ret")
	proto.RegisterType((*BuildingState)(nil), "protocol.building_state")
	proto.RegisterType((*StarInfo)(nil), "protocol.star_info")
	proto.RegisterType((*GetStarsSelect)(nil), "protocol.get_stars_select")
	proto.RegisterType((*GetStarsSelectRet)(nil), "protocol.get_stars_select_ret")
	proto.RegisterType((*SelectStar)(nil), "protocol.select_star")
	proto.RegisterType((*SelectStarRet)(nil), "protocol.select_star_ret")
	proto.RegisterType((*GetStarInfo)(nil), "protocol.get_star_info")
	proto.RegisterType((*GetStarInfoRet)(nil), "protocol.get_star_info_ret")
	proto.RegisterType((*GetStarShield)(nil), "protocol.get_star_shield")
	proto.RegisterType((*GetStarShieldRet)(nil), "protocol.get_star_shield_ret")
	proto.RegisterType((*Shield)(nil), "protocol.shield")
	proto.RegisterType((*OpenStarPush)(nil), "protocol.open_star_push")
	proto.RegisterType((*SearchStarInfo)(nil), "protocol.search_star_info")
	proto.RegisterType((*SearchStarInfoRet)(nil), "protocol.search_star_info_ret")
	proto.RegisterType((*GetStarInfoDetail)(nil), "protocol.get_star_info_detail")
	proto.RegisterType((*GetStarRecordInfo)(nil), "protocol.get_star_record_info")
	proto.RegisterType((*SetStarRecordInfo)(nil), "protocol.set_star_record_info")
	proto.RegisterType((*DelStarRecordInfo)(nil), "protocol.del_star_record_info")
	proto.RegisterType((*ReplaceStarRecordInfo)(nil), "protocol.replace_star_record_info")
	proto.RegisterType((*MoveStarRecordInfo)(nil), "protocol.move_star_record_info")
	proto.RegisterType((*OccupyStar)(nil), "protocol.occupy_star")
	proto.RegisterType((*GetHelpRepairInfo)(nil), "protocol.get_help_repair_info")
	proto.RegisterType((*GetHelpRepairInfoRet)(nil), "protocol.get_help_repair_info_ret")
	proto.RegisterType((*HelpRepairBuildInfo)(nil), "protocol.help_repair_build_info")
	proto.RegisterType((*HelpRepairBuild)(nil), "protocol.help_repair_build")
	proto.RegisterType((*HelpRepairBuildRet)(nil), "protocol.help_repair_build_ret")
	proto.RegisterType((*GetCurrentGroupItems)(nil), "protocol.get_current_group_items")
	proto.RegisterType((*GetCurrentGroupItemsRet)(nil), "protocol.get_current_group_items_ret")
	proto.RegisterType((*GetEventStarInfo)(nil), "protocol.get_event_star_info")
	proto.RegisterType((*GetEventStarInfoRet)(nil), "protocol.get_event_star_info_ret")
	proto.RegisterType((*AllocNewStar)(nil), "protocol.alloc_new_star")
	proto.RegisterType((*AllocNewStarRet)(nil), "protocol.alloc_new_star_ret")
	proto.RegisterType((*UserStarInfo)(nil), "protocol.user_star_info")
	proto.RegisterType((*UserStarInfoRet)(nil), "protocol.user_star_info_ret")
	proto.RegisterType((*GetStarInfoDetailRet)(nil), "protocol.get_star_info_detail_ret")
	proto.RegisterType((*GetStarInfoCompleteRet)(nil), "protocol.get_star_info_complete_ret")
	proto.RegisterType((*GetStarRecordInfoRet)(nil), "protocol.get_star_record_info_ret")
	proto.RegisterType((*SetStarRecordInfoRet)(nil), "protocol.set_star_record_info_ret")
	proto.RegisterType((*DelStarRecordInfoRet)(nil), "protocol.del_star_record_info_ret")
	proto.RegisterType((*ReplaceStarRecordInfoRet)(nil), "protocol.replace_star_record_info_ret")
	proto.RegisterType((*MoveStarRecordInfoRet)(nil), "protocol.move_star_record_info_ret")
	proto.RegisterType((*OccupyStarRet)(nil), "protocol.occupy_star_ret")
	proto.RegisterType((*AddCivilization)(nil), "protocol.add_civilization")
	proto.RegisterType((*DrawCivilizationReward)(nil), "protocol.draw_civilization_reward")
	proto.RegisterType((*DrawCivilizationRewardRet)(nil), "protocol.draw_civilization_reward_ret")
	proto.RegisterType((*StarSettle)(nil), "protocol.star_settle")
	proto.RegisterType((*StarSettleRet)(nil), "protocol.star_settle_ret")
	proto.RegisterType((*StarFlagInfo)(nil), "protocol.star_flag_info")
	proto.RegisterType((*StarFlagInfoRet)(nil), "protocol.star_flag_info_ret")
	proto.RegisterType((*UpdateStarFlag)(nil), "protocol.update_star_flag")
	proto.RegisterType((*UpdateStarFlagRet)(nil), "protocol.update_star_flag_ret")
	proto.RegisterType((*UpdateAllStarFlag)(nil), "protocol.update_all_star_flag")
	proto.RegisterType((*UpdateAllStarFlagRet)(nil), "protocol.update_all_star_flag_ret")
	proto.RegisterType((*GetOwnersByCondition)(nil), "protocol.get_owners_by_condition")
	proto.RegisterType((*GetOwnersByConditionRet)(nil), "protocol.get_owners_by_condition_ret")
	proto.RegisterType((*UserStarData)(nil), "protocol.user_star_data")
}
func (m *StarInfoBase) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StarInfoBase) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StarID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.StarID))
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.Type))
	}
	if m.OwnID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.OwnID))
	}
	if len(m.OwnNikeName) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintStar(dAtA, i, uint64(len(m.OwnNikeName)))
		i += copy(dAtA[i:], m.OwnNikeName)
	}
	return i, nil
}

func (m *TransmitUserStar) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransmitUserStar) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.UserID))
	}
	return i, nil
}

func (m *TransmitUserStarRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransmitUserStarRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Stars) > 0 {
		for _, b := range m.Stars {
			dAtA[i] = 0xa
			i++
			i = encodeVarintStar(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	return i, nil
}

func (m *HelpRepairBuildPublic) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HelpRepairBuildPublic) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BuildingType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.BuildingType))
	}
	return i, nil
}

func (m *HelpRepairBuildPublicRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HelpRepairBuildPublicRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BuildingType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.BuildingType))
	}
	return i, nil
}

func (m *LoginStarInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoginStarInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.Uid))
	}
	return i, nil
}

func (m *LoginStarInfoRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoginStarInfoRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Star) > 0 {
		for _, msg := range m.Star {
			dAtA[i] = 0xa
			i++
			i = encodeVarintStar(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.CurrStar != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.CurrStar.Size()))
		n1, err := m.CurrStar.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.PowerLimit != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.PowerLimit))
	}
	if len(m.UpgradedBuilding) > 0 {
		for _, msg := range m.UpgradedBuilding {
			dAtA[i] = 0x32
			i++
			i = encodeVarintStar(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.RepairedBuilding) > 0 {
		for _, msg := range m.RepairedBuilding {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintStar(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.AllBuilding) > 0 {
		for _, msg := range m.AllBuilding {
			dAtA[i] = 0x42
			i++
			i = encodeVarintStar(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.StarFlags) > 0 {
		for _, msg := range m.StarFlags {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintStar(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *BuildingState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuildingState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StarType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.StarType))
	}
	if m.BuildingType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.BuildingType))
	}
	if m.BuildingLevel != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.BuildingLevel))
	}
	return i, nil
}

func (m *StarInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StarInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StarID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.StarID))
	}
	if m.StarType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.StarType))
	}
	return i, nil
}

func (m *GetStarsSelect) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetStarsSelect) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Num != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.Num))
	}
	if m.Uid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.Uid))
	}
	return i, nil
}

func (m *GetStarsSelectRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetStarsSelectRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.StarsType) > 0 {
		dAtA3 := make([]byte, len(m.StarsType)*10)
		var j2 int
		for _, num1 := range m.StarsType {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintStar(dAtA, i, uint64(j2))
		i += copy(dAtA[i:], dAtA3[:j2])
	}
	return i, nil
}

func (m *SelectStar) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SelectStar) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StarType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.StarType))
	}
	return i, nil
}

func (m *SelectStarRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SelectStarRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Star) > 0 {
		for _, msg := range m.Star {
			dAtA[i] = 0xa
			i++
			i = encodeVarintStar(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.CurrentStar != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.CurrentStar.Size()))
		n4, err := m.CurrentStar.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.LastStarType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.LastStarType))
	}
	if m.Faith != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.Faith))
	}
	if len(m.Items) > 0 {
		dAtA6 := make([]byte, len(m.Items)*10)
		var j5 int
		for _, num1 := range m.Items {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		dAtA[i] = 0x2a
		i++
		i = encodeVarintStar(dAtA, i, uint64(j5))
		i += copy(dAtA[i:], dAtA6[:j5])
	}
	return i, nil
}

func (m *GetStarInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetStarInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *GetStarInfoRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetStarInfoRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Star) > 0 {
		for _, msg := range m.Star {
			dAtA[i] = 0xa
			i++
			i = encodeVarintStar(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.CurrentStar != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.CurrentStar.Size()))
		n7, err := m.CurrentStar.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *GetStarShield) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetStarShield) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *GetStarShieldRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetStarShieldRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FaithShield != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.FaithShield.Size()))
		n8, err := m.FaithShield.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.BelieverShield != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.BelieverShield.Size()))
		n9, err := m.BelieverShield.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.BuildingShield != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.BuildingShield.Size()))
		n10, err := m.BuildingShield.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}

func (m *Shield) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Shield) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Value != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.Value))
	}
	if m.Limit != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.Limit))
	}
	if m.UpdateTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.UpdateTime))
	}
	return i, nil
}

func (m *OpenStarPush) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpenStarPush) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Star != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.Star.Size()))
		n11, err := m.Star.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}

func (m *SearchStarInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchStarInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.Uid))
	}
	return i, nil
}

func (m *SearchStarInfoRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchStarInfoRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Star != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.Star.Size()))
		n12, err := m.Star.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}

func (m *GetStarInfoDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetStarInfoDetail) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.Uid))
	}
	if m.StarID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.StarID))
	}
	if m.ShieldType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.ShieldType))
	}
	if m.IsConvert {
		dAtA[i] = 0x20
		i++
		if m.IsConvert {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.BelieverTotalLevel != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.BelieverTotalLevel))
	}
	if m.BuildingTotalLevel != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.BuildingTotalLevel))
	}
	return i, nil
}

func (m *GetStarRecordInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetStarRecordInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.Uid))
	}
	if len(m.StarID) > 0 {
		dAtA14 := make([]byte, len(m.StarID)*10)
		var j13 int
		for _, num1 := range m.StarID {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA14[j13] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j13++
			}
			dAtA14[j13] = uint8(num)
			j13++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintStar(dAtA, i, uint64(j13))
		i += copy(dAtA[i:], dAtA14[:j13])
	}
	if len(m.UserID) > 0 {
		dAtA16 := make([]byte, len(m.UserID)*10)
		var j15 int
		for _, num1 := range m.UserID {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA16[j15] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j15++
			}
			dAtA16[j15] = uint8(num)
			j15++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStar(dAtA, i, uint64(j15))
		i += copy(dAtA[i:], dAtA16[:j15])
	}
	return i, nil
}

func (m *SetStarRecordInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetStarRecordInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RecordType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.RecordType))
	}
	if m.RecordID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.RecordID))
	}
	return i, nil
}

func (m *DelStarRecordInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DelStarRecordInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RecordType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.RecordType))
	}
	if m.RecordID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.RecordID))
	}
	return i, nil
}

func (m *ReplaceStarRecordInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceStarRecordInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RecordType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.RecordType))
	}
	if m.RecordID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.RecordID))
	}
	if m.ReplaceRecordID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.ReplaceRecordID))
	}
	return i, nil
}

func (m *MoveStarRecordInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MoveStarRecordInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SrcType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.SrcType))
	}
	if m.SrcID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.SrcID))
	}
	if m.DestType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.DestType))
	}
	if m.DestID != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.DestID))
	}
	return i, nil
}

func (m *OccupyStar) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OccupyStar) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.Uid))
	}
	if m.StarID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.StarID))
	}
	return i, nil
}

func (m *GetHelpRepairInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetHelpRepairInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BuildType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.BuildType))
	}
	return i, nil
}

func (m *GetHelpRepairInfoRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetHelpRepairInfoRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.HelpRepairBuildInfo) > 0 {
		for _, msg := range m.HelpRepairBuildInfo {
			dAtA[i] = 0xa
			i++
			i = encodeVarintStar(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *HelpRepairBuildInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HelpRepairBuildInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BuildingType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.BuildingType))
	}
	if m.RepairTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.RepairTime))
	}
	if m.BrokenTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.BrokenTime))
	}
	if m.HelpID != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.HelpID))
	}
	return i, nil
}

func (m *HelpRepairBuild) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HelpRepairBuild) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BuildingType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.BuildingType))
	}
	if m.HelperID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.HelperID))
	}
	return i, nil
}

func (m *HelpRepairBuildRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HelpRepairBuildRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result {
		dAtA[i] = 0x8
		i++
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.BuildingLevel != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.BuildingLevel))
	}
	if m.StarType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.StarType))
	}
	return i, nil
}

func (m *GetCurrentGroupItems) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetCurrentGroupItems) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *GetCurrentGroupItemsRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetCurrentGroupItemsRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ItemIDs) > 0 {
		dAtA18 := make([]byte, len(m.ItemIDs)*10)
		var j17 int
		for _, num1 := range m.ItemIDs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA18[j17] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j17++
			}
			dAtA18[j17] = uint8(num)
			j17++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintStar(dAtA, i, uint64(j17))
		i += copy(dAtA[i:], dAtA18[:j17])
	}
	if m.GroupID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.GroupID))
	}
	return i, nil
}

func (m *GetEventStarInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetEventStarInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.Uid))
	}
	return i, nil
}

func (m *GetEventStarInfoRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetEventStarInfoRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StarInfo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.StarInfo.Size()))
		n19, err := m.StarInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	return i, nil
}

func (m *AllocNewStar) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllocNewStar) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.Uid))
	}
	if m.StarType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.StarType))
	}
	return i, nil
}

func (m *AllocNewStarRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllocNewStarRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Star) > 0 {
		for _, msg := range m.Star {
			dAtA[i] = 0xa
			i++
			i = encodeVarintStar(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.CurrentStar != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.CurrentStar.Size()))
		n20, err := m.CurrentStar.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.LastStarType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.LastStarType))
	}
	if m.Faith != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.Faith))
	}
	if len(m.Items) > 0 {
		dAtA22 := make([]byte, len(m.Items)*10)
		var j21 int
		for _, num1 := range m.Items {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA22[j21] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j21++
			}
			dAtA22[j21] = uint8(num)
			j21++
		}
		dAtA[i] = 0x2a
		i++
		i = encodeVarintStar(dAtA, i, uint64(j21))
		i += copy(dAtA[i:], dAtA22[:j21])
	}
	if m.IsFirst {
		dAtA[i] = 0x30
		i++
		if m.IsFirst {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *UserStarInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserStarInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.Uid))
	}
	return i, nil
}

func (m *UserStarInfoRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserStarInfoRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CurrentStar != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.CurrentStar))
	}
	if m.Star != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.Star.Size()))
		n23, err := m.Star.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	return i, nil
}

func (m *GetStarInfoDetailRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetStarInfoDetailRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Star != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.Star.Size()))
		n24, err := m.Star.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if m.Shield != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.Shield.Size()))
		n25, err := m.Shield.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	return i, nil
}

func (m *GetStarInfoCompleteRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetStarInfoCompleteRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Star) > 0 {
		for _, msg := range m.Star {
			dAtA[i] = 0xa
			i++
			i = encodeVarintStar(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GetStarRecordInfoRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetStarRecordInfoRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.StarsOri) > 0 {
		for _, msg := range m.StarsOri {
			dAtA[i] = 0xa
			i++
			i = encodeVarintStar(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.StarsUser) > 0 {
		for _, msg := range m.StarsUser {
			dAtA[i] = 0x12
			i++
			i = encodeVarintStar(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SetStarRecordInfoRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetStarRecordInfoRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RecordType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.RecordType))
	}
	if m.RecordID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.RecordID))
	}
	return i, nil
}

func (m *DelStarRecordInfoRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DelStarRecordInfoRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RecordType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.RecordType))
	}
	if m.RecordID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.RecordID))
	}
	return i, nil
}

func (m *ReplaceStarRecordInfoRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceStarRecordInfoRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RecordType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.RecordType))
	}
	if m.RecordID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.RecordID))
	}
	if m.ReplaceRecordID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.ReplaceRecordID))
	}
	return i, nil
}

func (m *MoveStarRecordInfoRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MoveStarRecordInfoRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SrcType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.SrcType))
	}
	if m.SrcID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.SrcID))
	}
	if m.DestType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.DestType))
	}
	if m.DestID != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.DestID))
	}
	return i, nil
}

func (m *OccupyStarRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OccupyStarRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.Uid))
	}
	if m.StarOld != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.StarOld.Size()))
		n26, err := m.StarOld.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	if m.Star != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.Star.Size()))
		n27, err := m.Star.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	return i, nil
}

func (m *AddCivilization) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddCivilization) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CivilizationValue != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.CivilizationValue))
	}
	return i, nil
}

func (m *DrawCivilizationReward) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DrawCivilizationReward) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.Uid))
	}
	if m.StarID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.StarID))
	}
	if m.DrawLevel != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.DrawLevel))
	}
	return i, nil
}

func (m *DrawCivilizationRewardRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DrawCivilizationRewardRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StarID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.StarID))
	}
	if m.DrawLevel != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.DrawLevel))
	}
	if m.Reward != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.Reward))
	}
	if m.Faith != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.Faith))
	}
	if m.Diamond != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.Diamond))
	}
	if m.GayPiont != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.GayPiont))
	}
	if len(m.Believer) > 0 {
		for _, s := range m.Believer {
			dAtA[i] = 0x3a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.BelieverNum) > 0 {
		dAtA29 := make([]byte, len(m.BelieverNum)*10)
		var j28 int
		for _, num1 := range m.BelieverNum {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA29[j28] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j28++
			}
			dAtA29[j28] = uint8(num)
			j28++
		}
		dAtA[i] = 0x42
		i++
		i = encodeVarintStar(dAtA, i, uint64(j28))
		i += copy(dAtA[i:], dAtA29[:j28])
	}
	return i, nil
}

func (m *StarSettle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StarSettle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *StarSettleRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StarSettleRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RankNum != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.RankNum))
	}
	if m.TotalRank != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.TotalRank))
	}
	if m.PassTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.PassTime))
	}
	return i, nil
}

func (m *StarFlagInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StarFlagInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *StarFlagInfoRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StarFlagInfoRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Flags) > 0 {
		for _, msg := range m.Flags {
			dAtA[i] = 0xa
			i++
			i = encodeVarintStar(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *UpdateStarFlag) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateStarFlag) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Flag != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.Flag))
	}
	if m.Value != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.Value))
	}
	return i, nil
}

func (m *UpdateStarFlagRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateStarFlagRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Flag != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.Flag.Size()))
		n30, err := m.Flag.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	return i, nil
}

func (m *UpdateAllStarFlag) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateAllStarFlag) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Key != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.Key))
	}
	if m.Value != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.Value))
	}
	return i, nil
}

func (m *UpdateAllStarFlagRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateAllStarFlagRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result {
		dAtA[i] = 0x8
		i++
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *GetOwnersByCondition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetOwnersByCondition) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Start != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.Start))
	}
	if m.End != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.End))
	}
	if m.Limit != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.Limit))
	}
	if m.BuildLv != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.BuildLv))
	}
	if m.Skip != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.Skip))
	}
	return i, nil
}

func (m *GetOwnersByConditionRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetOwnersByConditionRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Count != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.Count))
	}
	if len(m.UserData) > 0 {
		for _, msg := range m.UserData {
			dAtA[i] = 0x12
			i++
			i = encodeVarintStar(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *UserStarData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserStarData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStar(dAtA, i, uint64(m.Uid))
	}
	if len(m.Believers) > 0 {
		for _, msg := range m.Believers {
			dAtA[i] = 0x12
			i++
			i = encodeVarintStar(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.StarStatis) > 0 {
		for _, msg := range m.StarStatis {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintStar(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.UserStatis) > 0 {
		for _, msg := range m.UserStatis {
			dAtA[i] = 0x22
			i++
			i = encodeVarintStar(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintStar(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *StarInfoBase) Size() (n int) {
	var l int
	_ = l
	if m.StarID != 0 {
		n += 1 + sovStar(uint64(m.StarID))
	}
	if m.Type != 0 {
		n += 1 + sovStar(uint64(m.Type))
	}
	if m.OwnID != 0 {
		n += 1 + sovStar(uint64(m.OwnID))
	}
	l = len(m.OwnNikeName)
	if l > 0 {
		n += 1 + l + sovStar(uint64(l))
	}
	return n
}

func (m *TransmitUserStar) Size() (n int) {
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovStar(uint64(m.UserID))
	}
	return n
}

func (m *TransmitUserStarRet) Size() (n int) {
	var l int
	_ = l
	if len(m.Stars) > 0 {
		for _, b := range m.Stars {
			l = len(b)
			n += 1 + l + sovStar(uint64(l))
		}
	}
	return n
}

func (m *HelpRepairBuildPublic) Size() (n int) {
	var l int
	_ = l
	if m.BuildingType != 0 {
		n += 1 + sovStar(uint64(m.BuildingType))
	}
	return n
}

func (m *HelpRepairBuildPublicRet) Size() (n int) {
	var l int
	_ = l
	if m.BuildingType != 0 {
		n += 1 + sovStar(uint64(m.BuildingType))
	}
	return n
}

func (m *LoginStarInfo) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovStar(uint64(m.Uid))
	}
	return n
}

func (m *LoginStarInfoRet) Size() (n int) {
	var l int
	_ = l
	if len(m.Star) > 0 {
		for _, e := range m.Star {
			l = e.Size()
			n += 1 + l + sovStar(uint64(l))
		}
	}
	if m.CurrStar != nil {
		l = m.CurrStar.Size()
		n += 1 + l + sovStar(uint64(l))
	}
	if m.PowerLimit != 0 {
		n += 1 + sovStar(uint64(m.PowerLimit))
	}
	if len(m.UpgradedBuilding) > 0 {
		for _, e := range m.UpgradedBuilding {
			l = e.Size()
			n += 1 + l + sovStar(uint64(l))
		}
	}
	if len(m.RepairedBuilding) > 0 {
		for _, e := range m.RepairedBuilding {
			l = e.Size()
			n += 1 + l + sovStar(uint64(l))
		}
	}
	if len(m.AllBuilding) > 0 {
		for _, e := range m.AllBuilding {
			l = e.Size()
			n += 1 + l + sovStar(uint64(l))
		}
	}
	if len(m.StarFlags) > 0 {
		for _, e := range m.StarFlags {
			l = e.Size()
			n += 1 + l + sovStar(uint64(l))
		}
	}
	return n
}

func (m *BuildingState) Size() (n int) {
	var l int
	_ = l
	if m.StarType != 0 {
		n += 1 + sovStar(uint64(m.StarType))
	}
	if m.BuildingType != 0 {
		n += 1 + sovStar(uint64(m.BuildingType))
	}
	if m.BuildingLevel != 0 {
		n += 1 + sovStar(uint64(m.BuildingLevel))
	}
	return n
}

func (m *StarInfo) Size() (n int) {
	var l int
	_ = l
	if m.StarID != 0 {
		n += 1 + sovStar(uint64(m.StarID))
	}
	if m.StarType != 0 {
		n += 1 + sovStar(uint64(m.StarType))
	}
	return n
}

func (m *GetStarsSelect) Size() (n int) {
	var l int
	_ = l
	if m.Num != 0 {
		n += 1 + sovStar(uint64(m.Num))
	}
	if m.Uid != 0 {
		n += 1 + sovStar(uint64(m.Uid))
	}
	return n
}

func (m *GetStarsSelectRet) Size() (n int) {
	var l int
	_ = l
	if len(m.StarsType) > 0 {
		l = 0
		for _, e := range m.StarsType {
			l += sovStar(uint64(e))
		}
		n += 1 + sovStar(uint64(l)) + l
	}
	return n
}

func (m *SelectStar) Size() (n int) {
	var l int
	_ = l
	if m.StarType != 0 {
		n += 1 + sovStar(uint64(m.StarType))
	}
	return n
}

func (m *SelectStarRet) Size() (n int) {
	var l int
	_ = l
	if len(m.Star) > 0 {
		for _, e := range m.Star {
			l = e.Size()
			n += 1 + l + sovStar(uint64(l))
		}
	}
	if m.CurrentStar != nil {
		l = m.CurrentStar.Size()
		n += 1 + l + sovStar(uint64(l))
	}
	if m.LastStarType != 0 {
		n += 1 + sovStar(uint64(m.LastStarType))
	}
	if m.Faith != 0 {
		n += 1 + sovStar(uint64(m.Faith))
	}
	if len(m.Items) > 0 {
		l = 0
		for _, e := range m.Items {
			l += sovStar(uint64(e))
		}
		n += 1 + sovStar(uint64(l)) + l
	}
	return n
}

func (m *GetStarInfo) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *GetStarInfoRet) Size() (n int) {
	var l int
	_ = l
	if len(m.Star) > 0 {
		for _, e := range m.Star {
			l = e.Size()
			n += 1 + l + sovStar(uint64(l))
		}
	}
	if m.CurrentStar != nil {
		l = m.CurrentStar.Size()
		n += 1 + l + sovStar(uint64(l))
	}
	return n
}

func (m *GetStarShield) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *GetStarShieldRet) Size() (n int) {
	var l int
	_ = l
	if m.FaithShield != nil {
		l = m.FaithShield.Size()
		n += 1 + l + sovStar(uint64(l))
	}
	if m.BelieverShield != nil {
		l = m.BelieverShield.Size()
		n += 1 + l + sovStar(uint64(l))
	}
	if m.BuildingShield != nil {
		l = m.BuildingShield.Size()
		n += 1 + l + sovStar(uint64(l))
	}
	return n
}

func (m *Shield) Size() (n int) {
	var l int
	_ = l
	if m.Value != 0 {
		n += 1 + sovStar(uint64(m.Value))
	}
	if m.Limit != 0 {
		n += 1 + sovStar(uint64(m.Limit))
	}
	if m.UpdateTime != 0 {
		n += 1 + sovStar(uint64(m.UpdateTime))
	}
	return n
}

func (m *OpenStarPush) Size() (n int) {
	var l int
	_ = l
	if m.Star != nil {
		l = m.Star.Size()
		n += 1 + l + sovStar(uint64(l))
	}
	return n
}

func (m *SearchStarInfo) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovStar(uint64(m.Uid))
	}
	return n
}

func (m *SearchStarInfoRet) Size() (n int) {
	var l int
	_ = l
	if m.Star != nil {
		l = m.Star.Size()
		n += 1 + l + sovStar(uint64(l))
	}
	return n
}

func (m *GetStarInfoDetail) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovStar(uint64(m.Uid))
	}
	if m.StarID != 0 {
		n += 1 + sovStar(uint64(m.StarID))
	}
	if m.ShieldType != 0 {
		n += 1 + sovStar(uint64(m.ShieldType))
	}
	if m.IsConvert {
		n += 2
	}
	if m.BelieverTotalLevel != 0 {
		n += 1 + sovStar(uint64(m.BelieverTotalLevel))
	}
	if m.BuildingTotalLevel != 0 {
		n += 1 + sovStar(uint64(m.BuildingTotalLevel))
	}
	return n
}

func (m *GetStarRecordInfo) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovStar(uint64(m.Uid))
	}
	if len(m.StarID) > 0 {
		l = 0
		for _, e := range m.StarID {
			l += sovStar(uint64(e))
		}
		n += 1 + sovStar(uint64(l)) + l
	}
	if len(m.UserID) > 0 {
		l = 0
		for _, e := range m.UserID {
			l += sovStar(uint64(e))
		}
		n += 1 + sovStar(uint64(l)) + l
	}
	return n
}

func (m *SetStarRecordInfo) Size() (n int) {
	var l int
	_ = l
	if m.RecordType != 0 {
		n += 1 + sovStar(uint64(m.RecordType))
	}
	if m.RecordID != 0 {
		n += 1 + sovStar(uint64(m.RecordID))
	}
	return n
}

func (m *DelStarRecordInfo) Size() (n int) {
	var l int
	_ = l
	if m.RecordType != 0 {
		n += 1 + sovStar(uint64(m.RecordType))
	}
	if m.RecordID != 0 {
		n += 1 + sovStar(uint64(m.RecordID))
	}
	return n
}

func (m *ReplaceStarRecordInfo) Size() (n int) {
	var l int
	_ = l
	if m.RecordType != 0 {
		n += 1 + sovStar(uint64(m.RecordType))
	}
	if m.RecordID != 0 {
		n += 1 + sovStar(uint64(m.RecordID))
	}
	if m.ReplaceRecordID != 0 {
		n += 1 + sovStar(uint64(m.ReplaceRecordID))
	}
	return n
}

func (m *MoveStarRecordInfo) Size() (n int) {
	var l int
	_ = l
	if m.SrcType != 0 {
		n += 1 + sovStar(uint64(m.SrcType))
	}
	if m.SrcID != 0 {
		n += 1 + sovStar(uint64(m.SrcID))
	}
	if m.DestType != 0 {
		n += 1 + sovStar(uint64(m.DestType))
	}
	if m.DestID != 0 {
		n += 1 + sovStar(uint64(m.DestID))
	}
	return n
}

func (m *OccupyStar) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovStar(uint64(m.Uid))
	}
	if m.StarID != 0 {
		n += 1 + sovStar(uint64(m.StarID))
	}
	return n
}

func (m *GetHelpRepairInfo) Size() (n int) {
	var l int
	_ = l
	if m.BuildType != 0 {
		n += 1 + sovStar(uint64(m.BuildType))
	}
	return n
}

func (m *GetHelpRepairInfoRet) Size() (n int) {
	var l int
	_ = l
	if len(m.HelpRepairBuildInfo) > 0 {
		for _, e := range m.HelpRepairBuildInfo {
			l = e.Size()
			n += 1 + l + sovStar(uint64(l))
		}
	}
	return n
}

func (m *HelpRepairBuildInfo) Size() (n int) {
	var l int
	_ = l
	if m.BuildingType != 0 {
		n += 1 + sovStar(uint64(m.BuildingType))
	}
	if m.RepairTime != 0 {
		n += 1 + sovStar(uint64(m.RepairTime))
	}
	if m.BrokenTime != 0 {
		n += 1 + sovStar(uint64(m.BrokenTime))
	}
	if m.HelpID != 0 {
		n += 1 + sovStar(uint64(m.HelpID))
	}
	return n
}

func (m *HelpRepairBuild) Size() (n int) {
	var l int
	_ = l
	if m.BuildingType != 0 {
		n += 1 + sovStar(uint64(m.BuildingType))
	}
	if m.HelperID != 0 {
		n += 1 + sovStar(uint64(m.HelperID))
	}
	return n
}

func (m *HelpRepairBuildRet) Size() (n int) {
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	if m.BuildingLevel != 0 {
		n += 1 + sovStar(uint64(m.BuildingLevel))
	}
	if m.StarType != 0 {
		n += 1 + sovStar(uint64(m.StarType))
	}
	return n
}

func (m *GetCurrentGroupItems) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *GetCurrentGroupItemsRet) Size() (n int) {
	var l int
	_ = l
	if len(m.ItemIDs) > 0 {
		l = 0
		for _, e := range m.ItemIDs {
			l += sovStar(uint64(e))
		}
		n += 1 + sovStar(uint64(l)) + l
	}
	if m.GroupID != 0 {
		n += 1 + sovStar(uint64(m.GroupID))
	}
	return n
}

func (m *GetEventStarInfo) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovStar(uint64(m.Uid))
	}
	return n
}

func (m *GetEventStarInfoRet) Size() (n int) {
	var l int
	_ = l
	if m.StarInfo != nil {
		l = m.StarInfo.Size()
		n += 1 + l + sovStar(uint64(l))
	}
	return n
}

func (m *AllocNewStar) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovStar(uint64(m.Uid))
	}
	if m.StarType != 0 {
		n += 1 + sovStar(uint64(m.StarType))
	}
	return n
}

func (m *AllocNewStarRet) Size() (n int) {
	var l int
	_ = l
	if len(m.Star) > 0 {
		for _, e := range m.Star {
			l = e.Size()
			n += 1 + l + sovStar(uint64(l))
		}
	}
	if m.CurrentStar != nil {
		l = m.CurrentStar.Size()
		n += 1 + l + sovStar(uint64(l))
	}
	if m.LastStarType != 0 {
		n += 1 + sovStar(uint64(m.LastStarType))
	}
	if m.Faith != 0 {
		n += 1 + sovStar(uint64(m.Faith))
	}
	if len(m.Items) > 0 {
		l = 0
		for _, e := range m.Items {
			l += sovStar(uint64(e))
		}
		n += 1 + sovStar(uint64(l)) + l
	}
	if m.IsFirst {
		n += 2
	}
	return n
}

func (m *UserStarInfo) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovStar(uint64(m.Uid))
	}
	return n
}

func (m *UserStarInfoRet) Size() (n int) {
	var l int
	_ = l
	if m.CurrentStar != 0 {
		n += 1 + sovStar(uint64(m.CurrentStar))
	}
	if m.Star != nil {
		l = m.Star.Size()
		n += 1 + l + sovStar(uint64(l))
	}
	return n
}

func (m *GetStarInfoDetailRet) Size() (n int) {
	var l int
	_ = l
	if m.Star != nil {
		l = m.Star.Size()
		n += 1 + l + sovStar(uint64(l))
	}
	if m.Shield != nil {
		l = m.Shield.Size()
		n += 1 + l + sovStar(uint64(l))
	}
	return n
}

func (m *GetStarInfoCompleteRet) Size() (n int) {
	var l int
	_ = l
	if len(m.Star) > 0 {
		for _, e := range m.Star {
			l = e.Size()
			n += 1 + l + sovStar(uint64(l))
		}
	}
	return n
}

func (m *GetStarRecordInfoRet) Size() (n int) {
	var l int
	_ = l
	if len(m.StarsOri) > 0 {
		for _, e := range m.StarsOri {
			l = e.Size()
			n += 1 + l + sovStar(uint64(l))
		}
	}
	if len(m.StarsUser) > 0 {
		for _, e := range m.StarsUser {
			l = e.Size()
			n += 1 + l + sovStar(uint64(l))
		}
	}
	return n
}

func (m *SetStarRecordInfoRet) Size() (n int) {
	var l int
	_ = l
	if m.RecordType != 0 {
		n += 1 + sovStar(uint64(m.RecordType))
	}
	if m.RecordID != 0 {
		n += 1 + sovStar(uint64(m.RecordID))
	}
	return n
}

func (m *DelStarRecordInfoRet) Size() (n int) {
	var l int
	_ = l
	if m.RecordType != 0 {
		n += 1 + sovStar(uint64(m.RecordType))
	}
	if m.RecordID != 0 {
		n += 1 + sovStar(uint64(m.RecordID))
	}
	return n
}

func (m *ReplaceStarRecordInfoRet) Size() (n int) {
	var l int
	_ = l
	if m.RecordType != 0 {
		n += 1 + sovStar(uint64(m.RecordType))
	}
	if m.RecordID != 0 {
		n += 1 + sovStar(uint64(m.RecordID))
	}
	if m.ReplaceRecordID != 0 {
		n += 1 + sovStar(uint64(m.ReplaceRecordID))
	}
	return n
}

func (m *MoveStarRecordInfoRet) Size() (n int) {
	var l int
	_ = l
	if m.SrcType != 0 {
		n += 1 + sovStar(uint64(m.SrcType))
	}
	if m.SrcID != 0 {
		n += 1 + sovStar(uint64(m.SrcID))
	}
	if m.DestType != 0 {
		n += 1 + sovStar(uint64(m.DestType))
	}
	if m.DestID != 0 {
		n += 1 + sovStar(uint64(m.DestID))
	}
	return n
}

func (m *OccupyStarRet) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovStar(uint64(m.Uid))
	}
	if m.StarOld != nil {
		l = m.StarOld.Size()
		n += 1 + l + sovStar(uint64(l))
	}
	if m.Star != nil {
		l = m.Star.Size()
		n += 1 + l + sovStar(uint64(l))
	}
	return n
}

func (m *AddCivilization) Size() (n int) {
	var l int
	_ = l
	if m.CivilizationValue != 0 {
		n += 1 + sovStar(uint64(m.CivilizationValue))
	}
	return n
}

func (m *DrawCivilizationReward) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovStar(uint64(m.Uid))
	}
	if m.StarID != 0 {
		n += 1 + sovStar(uint64(m.StarID))
	}
	if m.DrawLevel != 0 {
		n += 1 + sovStar(uint64(m.DrawLevel))
	}
	return n
}

func (m *DrawCivilizationRewardRet) Size() (n int) {
	var l int
	_ = l
	if m.StarID != 0 {
		n += 1 + sovStar(uint64(m.StarID))
	}
	if m.DrawLevel != 0 {
		n += 1 + sovStar(uint64(m.DrawLevel))
	}
	if m.Reward != 0 {
		n += 1 + sovStar(uint64(m.Reward))
	}
	if m.Faith != 0 {
		n += 1 + sovStar(uint64(m.Faith))
	}
	if m.Diamond != 0 {
		n += 1 + sovStar(uint64(m.Diamond))
	}
	if m.GayPiont != 0 {
		n += 1 + sovStar(uint64(m.GayPiont))
	}
	if len(m.Believer) > 0 {
		for _, s := range m.Believer {
			l = len(s)
			n += 1 + l + sovStar(uint64(l))
		}
	}
	if len(m.BelieverNum) > 0 {
		l = 0
		for _, e := range m.BelieverNum {
			l += sovStar(uint64(e))
		}
		n += 1 + sovStar(uint64(l)) + l
	}
	return n
}

func (m *StarSettle) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *StarSettleRet) Size() (n int) {
	var l int
	_ = l
	if m.RankNum != 0 {
		n += 1 + sovStar(uint64(m.RankNum))
	}
	if m.TotalRank != 0 {
		n += 1 + sovStar(uint64(m.TotalRank))
	}
	if m.PassTime != 0 {
		n += 1 + sovStar(uint64(m.PassTime))
	}
	return n
}

func (m *StarFlagInfo) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *StarFlagInfoRet) Size() (n int) {
	var l int
	_ = l
	if len(m.Flags) > 0 {
		for _, e := range m.Flags {
			l = e.Size()
			n += 1 + l + sovStar(uint64(l))
		}
	}
	return n
}

func (m *UpdateStarFlag) Size() (n int) {
	var l int
	_ = l
	if m.Flag != 0 {
		n += 1 + sovStar(uint64(m.Flag))
	}
	if m.Value != 0 {
		n += 1 + sovStar(uint64(m.Value))
	}
	return n
}

func (m *UpdateStarFlagRet) Size() (n int) {
	var l int
	_ = l
	if m.Flag != nil {
		l = m.Flag.Size()
		n += 1 + l + sovStar(uint64(l))
	}
	return n
}

func (m *UpdateAllStarFlag) Size() (n int) {
	var l int
	_ = l
	if m.Key != 0 {
		n += 1 + sovStar(uint64(m.Key))
	}
	if m.Value != 0 {
		n += 1 + sovStar(uint64(m.Value))
	}
	return n
}

func (m *UpdateAllStarFlagRet) Size() (n int) {
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	return n
}

func (m *GetOwnersByCondition) Size() (n int) {
	var l int
	_ = l
	if m.Start != 0 {
		n += 1 + sovStar(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovStar(uint64(m.End))
	}
	if m.Limit != 0 {
		n += 1 + sovStar(uint64(m.Limit))
	}
	if m.BuildLv != 0 {
		n += 1 + sovStar(uint64(m.BuildLv))
	}
	if m.Skip != 0 {
		n += 1 + sovStar(uint64(m.Skip))
	}
	return n
}

func (m *GetOwnersByConditionRet) Size() (n int) {
	var l int
	_ = l
	if m.Count != 0 {
		n += 1 + sovStar(uint64(m.Count))
	}
	if len(m.UserData) > 0 {
		for _, e := range m.UserData {
			l = e.Size()
			n += 1 + l + sovStar(uint64(l))
		}
	}
	return n
}

func (m *UserStarData) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovStar(uint64(m.Uid))
	}
	if len(m.Believers) > 0 {
		for _, e := range m.Believers {
			l = e.Size()
			n += 1 + l + sovStar(uint64(l))
		}
	}
	if len(m.StarStatis) > 0 {
		for _, e := range m.StarStatis {
			l = e.Size()
			n += 1 + l + sovStar(uint64(l))
		}
	}
	if len(m.UserStatis) > 0 {
		for _, e := range m.UserStatis {
			l = e.Size()
			n += 1 + l + sovStar(uint64(l))
		}
	}
	return n
}

func sovStar(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozStar(x uint64) (n int) {
	return sovStar(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *StarInfoBase) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: star_info_base: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: star_info_base: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StarID", wireType)
			}
			m.StarID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StarID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnID", wireType)
			}
			m.OwnID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OwnID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnNikeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStar
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnNikeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransmitUserStar) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: transmit_user_star: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: transmit_user_star: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransmitUserStarRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: transmit_user_star_ret: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: transmit_user_star_ret: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stars", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStar
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stars = append(m.Stars, make([]byte, postIndex-iNdEx))
			copy(m.Stars[len(m.Stars)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HelpRepairBuildPublic) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: help_repair_build_public: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: help_repair_build_public: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildingType", wireType)
			}
			m.BuildingType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuildingType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HelpRepairBuildPublicRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: help_repair_build_public_ret: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: help_repair_build_public_ret: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildingType", wireType)
			}
			m.BuildingType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuildingType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoginStarInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: login_star_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: login_star_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoginStarInfoRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: login_star_info_ret: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: login_star_info_ret: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Star", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Star = append(m.Star, &StarInfo{})
			if err := m.Star[len(m.Star)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrStar", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CurrStar == nil {
				m.CurrStar = &StarInfo{}
			}
			if err := m.CurrStar.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PowerLimit", wireType)
			}
			m.PowerLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PowerLimit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpgradedBuilding", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpgradedBuilding = append(m.UpgradedBuilding, &BuildingState{})
			if err := m.UpgradedBuilding[len(m.UpgradedBuilding)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepairedBuilding", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepairedBuilding = append(m.RepairedBuilding, &BuildingState{})
			if err := m.RepairedBuilding[len(m.RepairedBuilding)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllBuilding", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllBuilding = append(m.AllBuilding, &BuildingState{})
			if err := m.AllBuilding[len(m.AllBuilding)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StarFlags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StarFlags = append(m.StarFlags, &FlagInfo{})
			if err := m.StarFlags[len(m.StarFlags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuildingState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: building_state: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: building_state: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StarType", wireType)
			}
			m.StarType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StarType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildingType", wireType)
			}
			m.BuildingType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuildingType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildingLevel", wireType)
			}
			m.BuildingLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuildingLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StarInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: star_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: star_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StarID", wireType)
			}
			m.StarID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StarID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StarType", wireType)
			}
			m.StarType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StarType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetStarsSelect) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: get_stars_select: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: get_stars_select: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			m.Num = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Num |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetStarsSelectRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: get_stars_select_ret: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: get_stars_select_ret: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStar
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.StarsType = append(m.StarsType, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStar
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthStar
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStar
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.StarsType = append(m.StarsType, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field StarsType", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SelectStar) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: select_star: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: select_star: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StarType", wireType)
			}
			m.StarType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StarType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SelectStarRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: select_star_ret: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: select_star_ret: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Star", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Star = append(m.Star, &StarInfo{})
			if err := m.Star[len(m.Star)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentStar", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CurrentStar == nil {
				m.CurrentStar = &StarInfoDetail{}
			}
			if err := m.CurrentStar.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastStarType", wireType)
			}
			m.LastStarType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastStarType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Faith", wireType)
			}
			m.Faith = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Faith |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStar
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Items = append(m.Items, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStar
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthStar
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStar
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Items = append(m.Items, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetStarInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: get_star_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: get_star_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipStar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetStarInfoRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: get_star_info_ret: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: get_star_info_ret: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Star", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Star = append(m.Star, &StarInfo{})
			if err := m.Star[len(m.Star)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentStar", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CurrentStar == nil {
				m.CurrentStar = &StarInfoDetail{}
			}
			if err := m.CurrentStar.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetStarShield) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: get_star_shield: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: get_star_shield: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipStar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetStarShieldRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: get_star_shield_ret: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: get_star_shield_ret: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FaithShield", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FaithShield == nil {
				m.FaithShield = &Shield{}
			}
			if err := m.FaithShield.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BelieverShield", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BelieverShield == nil {
				m.BelieverShield = &Shield{}
			}
			if err := m.BelieverShield.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildingShield", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BuildingShield == nil {
				m.BuildingShield = &Shield{}
			}
			if err := m.BuildingShield.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Shield) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: shield: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: shield: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateTime", wireType)
			}
			m.UpdateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpenStarPush) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: open_star_push: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: open_star_push: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Star", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Star == nil {
				m.Star = &StarInfoDetail{}
			}
			if err := m.Star.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchStarInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: search_star_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: search_star_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchStarInfoRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: search_star_info_ret: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: search_star_info_ret: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Star", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Star == nil {
				m.Star = &StarInfoDetail{}
			}
			if err := m.Star.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetStarInfoDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: get_star_info_detail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: get_star_info_detail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StarID", wireType)
			}
			m.StarID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StarID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShieldType", wireType)
			}
			m.ShieldType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShieldType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsConvert", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsConvert = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BelieverTotalLevel", wireType)
			}
			m.BelieverTotalLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BelieverTotalLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildingTotalLevel", wireType)
			}
			m.BuildingTotalLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuildingTotalLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetStarRecordInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: get_star_record_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: get_star_record_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStar
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.StarID = append(m.StarID, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStar
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthStar
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStar
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.StarID = append(m.StarID, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field StarID", wireType)
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStar
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UserID = append(m.UserID, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStar
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthStar
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStar
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UserID = append(m.UserID, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetStarRecordInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: set_star_record_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: set_star_record_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordType", wireType)
			}
			m.RecordType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecordType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordID", wireType)
			}
			m.RecordID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecordID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DelStarRecordInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: del_star_record_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: del_star_record_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordType", wireType)
			}
			m.RecordType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecordType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordID", wireType)
			}
			m.RecordID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecordID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceStarRecordInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: replace_star_record_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: replace_star_record_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordType", wireType)
			}
			m.RecordType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecordType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordID", wireType)
			}
			m.RecordID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecordID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplaceRecordID", wireType)
			}
			m.ReplaceRecordID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplaceRecordID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MoveStarRecordInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: move_star_record_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: move_star_record_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcType", wireType)
			}
			m.SrcType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcID", wireType)
			}
			m.SrcID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestType", wireType)
			}
			m.DestType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DestType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestID", wireType)
			}
			m.DestID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DestID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OccupyStar) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: occupy_star: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: occupy_star: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StarID", wireType)
			}
			m.StarID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StarID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetHelpRepairInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: get_help_repair_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: get_help_repair_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildType", wireType)
			}
			m.BuildType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuildType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetHelpRepairInfoRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: get_help_repair_info_ret: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: get_help_repair_info_ret: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HelpRepairBuildInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HelpRepairBuildInfo = append(m.HelpRepairBuildInfo, &HelpRepairBuildInfo{})
			if err := m.HelpRepairBuildInfo[len(m.HelpRepairBuildInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HelpRepairBuildInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: help_repair_build_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: help_repair_build_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildingType", wireType)
			}
			m.BuildingType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuildingType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepairTime", wireType)
			}
			m.RepairTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RepairTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BrokenTime", wireType)
			}
			m.BrokenTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BrokenTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HelpID", wireType)
			}
			m.HelpID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HelpID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HelpRepairBuild) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: help_repair_build: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: help_repair_build: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildingType", wireType)
			}
			m.BuildingType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuildingType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HelperID", wireType)
			}
			m.HelperID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HelperID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HelpRepairBuildRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: help_repair_build_ret: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: help_repair_build_ret: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildingLevel", wireType)
			}
			m.BuildingLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuildingLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StarType", wireType)
			}
			m.StarType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StarType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetCurrentGroupItems) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: get_current_group_items: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: get_current_group_items: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipStar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetCurrentGroupItemsRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: get_current_group_items_ret: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: get_current_group_items_ret: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStar
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ItemIDs = append(m.ItemIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStar
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthStar
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStar
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ItemIDs = append(m.ItemIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemIDs", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			m.GroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetEventStarInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: get_event_star_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: get_event_star_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetEventStarInfoRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: get_event_star_info_ret: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: get_event_star_info_ret: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StarInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StarInfo == nil {
				m.StarInfo = &StarInfoDetail{}
			}
			if err := m.StarInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllocNewStar) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: alloc_new_star: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: alloc_new_star: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StarType", wireType)
			}
			m.StarType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StarType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllocNewStarRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: alloc_new_star_ret: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: alloc_new_star_ret: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Star", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Star = append(m.Star, &StarInfo{})
			if err := m.Star[len(m.Star)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentStar", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CurrentStar == nil {
				m.CurrentStar = &StarInfoDetail{}
			}
			if err := m.CurrentStar.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastStarType", wireType)
			}
			m.LastStarType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastStarType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Faith", wireType)
			}
			m.Faith = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Faith |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStar
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Items = append(m.Items, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStar
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthStar
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStar
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Items = append(m.Items, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFirst", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsFirst = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipStar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserStarInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: user_star_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: user_star_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserStarInfoRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: user_star_info_ret: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: user_star_info_ret: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentStar", wireType)
			}
			m.CurrentStar = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentStar |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Star", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Star == nil {
				m.Star = &StarInfoDetail{}
			}
			if err := m.Star.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetStarInfoDetailRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: get_star_info_detail_ret: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: get_star_info_detail_ret: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Star", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Star == nil {
				m.Star = &StarInfoDetail{}
			}
			if err := m.Star.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shield", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Shield == nil {
				m.Shield = &Shield{}
			}
			if err := m.Shield.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetStarInfoCompleteRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: get_star_info_complete_ret: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: get_star_info_complete_ret: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Star", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Star = append(m.Star, &StarInfoDetail{})
			if err := m.Star[len(m.Star)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetStarRecordInfoRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: get_star_record_info_ret: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: get_star_record_info_ret: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StarsOri", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StarsOri = append(m.StarsOri, &StarInfoBase{})
			if err := m.StarsOri[len(m.StarsOri)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StarsUser", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StarsUser = append(m.StarsUser, &StarInfoBase{})
			if err := m.StarsUser[len(m.StarsUser)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetStarRecordInfoRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: set_star_record_info_ret: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: set_star_record_info_ret: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordType", wireType)
			}
			m.RecordType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecordType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordID", wireType)
			}
			m.RecordID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecordID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DelStarRecordInfoRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: del_star_record_info_ret: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: del_star_record_info_ret: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordType", wireType)
			}
			m.RecordType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecordType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordID", wireType)
			}
			m.RecordID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecordID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceStarRecordInfoRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: replace_star_record_info_ret: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: replace_star_record_info_ret: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordType", wireType)
			}
			m.RecordType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecordType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordID", wireType)
			}
			m.RecordID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecordID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplaceRecordID", wireType)
			}
			m.ReplaceRecordID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplaceRecordID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MoveStarRecordInfoRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: move_star_record_info_ret: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: move_star_record_info_ret: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcType", wireType)
			}
			m.SrcType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcID", wireType)
			}
			m.SrcID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestType", wireType)
			}
			m.DestType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DestType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestID", wireType)
			}
			m.DestID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DestID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OccupyStarRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: occupy_star_ret: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: occupy_star_ret: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StarOld", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StarOld == nil {
				m.StarOld = &StarInfoDetail{}
			}
			if err := m.StarOld.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Star", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Star == nil {
				m.Star = &StarInfoDetail{}
			}
			if err := m.Star.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddCivilization) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: add_civilization: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: add_civilization: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CivilizationValue", wireType)
			}
			m.CivilizationValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CivilizationValue |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DrawCivilizationReward) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: draw_civilization_reward: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: draw_civilization_reward: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StarID", wireType)
			}
			m.StarID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StarID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DrawLevel", wireType)
			}
			m.DrawLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DrawLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DrawCivilizationRewardRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: draw_civilization_reward_ret: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: draw_civilization_reward_ret: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StarID", wireType)
			}
			m.StarID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StarID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DrawLevel", wireType)
			}
			m.DrawLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DrawLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reward", wireType)
			}
			m.Reward = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reward |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Faith", wireType)
			}
			m.Faith = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Faith |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Diamond", wireType)
			}
			m.Diamond = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Diamond |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GayPiont", wireType)
			}
			m.GayPiont = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GayPiont |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Believer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStar
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Believer = append(m.Believer, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStar
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.BelieverNum = append(m.BelieverNum, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStar
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthStar
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStar
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.BelieverNum = append(m.BelieverNum, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BelieverNum", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StarSettle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: star_settle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: star_settle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipStar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StarSettleRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: star_settle_ret: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: star_settle_ret: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RankNum", wireType)
			}
			m.RankNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RankNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalRank", wireType)
			}
			m.TotalRank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalRank |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PassTime", wireType)
			}
			m.PassTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PassTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StarFlagInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: star_flag_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: star_flag_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipStar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StarFlagInfoRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: star_flag_info_ret: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: star_flag_info_ret: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Flags = append(m.Flags, &FlagInfo{})
			if err := m.Flags[len(m.Flags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateStarFlag) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: update_star_flag: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: update_star_flag: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flag", wireType)
			}
			m.Flag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flag |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateStarFlagRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: update_star_flag_ret: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: update_star_flag_ret: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flag", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Flag == nil {
				m.Flag = &FlagInfo{}
			}
			if err := m.Flag.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateAllStarFlag) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: update_all_star_flag: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: update_all_star_flag: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Key |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateAllStarFlagRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: update_all_star_flag_ret: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: update_all_star_flag_ret: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipStar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetOwnersByCondition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: get_owners_by_condition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: get_owners_by_condition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildLv", wireType)
			}
			m.BuildLv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuildLv |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Skip", wireType)
			}
			m.Skip = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Skip |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetOwnersByConditionRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: get_owners_by_condition_ret: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: get_owners_by_condition_ret: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserData = append(m.UserData, &UserStarData{})
			if err := m.UserData[len(m.UserData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserStarData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: user_star_data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: user_star_data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Believers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Believers = append(m.Believers, &BelieverInfo{})
			if err := m.Believers[len(m.Believers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StarStatis", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StarStatis = append(m.StarStatis, &Statistics{})
			if err := m.StarStatis[len(m.StarStatis)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserStatis", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserStatis = append(m.UserStatis, &Statistics{})
			if err := m.UserStatis[len(m.UserStatis)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipStar(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowStar
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStar
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStar
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthStar
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowStar
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipStar(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthStar = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowStar   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("star.proto", fileDescriptorStar) }

var fileDescriptorStar = []byte{
	// 1771 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x18, 0x5d, 0x6b, 0xdc, 0xca,
	0x15, 0xed, 0x7a, 0xed, 0xf5, 0xd9, 0xc4, 0x5e, 0xcb, 0xbe, 0xbe, 0xba, 0xae, 0x31, 0x66, 0x7a,
	0xe1, 0xfa, 0x42, 0x70, 0xa9, 0xeb, 0x24, 0xa5, 0x84, 0x24, 0xa4, 0x26, 0x60, 0x30, 0x4e, 0x23,
	0xbb, 0xa1, 0x6f, 0x62, 0x56, 0x1a, 0xaf, 0x07, 0x6b, 0x25, 0x55, 0x33, 0x5a, 0xe3, 0xf4, 0xa1,
	0x7d, 0x68, 0x1f, 0x9a, 0xe7, 0xfe, 0x9d, 0x3e, 0x16, 0xf2, 0xd8, 0x5f, 0x50, 0x4a, 0xa0, 0x7f,
	0xa1, 0xcf, 0x65, 0xbe, 0xa4, 0xd1, 0xee, 0x6a, 0x6d, 0x37, 0x69, 0xe1, 0x3e, 0x49, 0xe7, 0xcc,
	0xf9, 0x9e, 0x33, 0xe7, 0x9c, 0x19, 0x00, 0xc6, 0x71, 0xbe, 0x9f, 0xe5, 0x29, 0x4f, 0xdd, 0xae,
	0xfc, 0x84, 0x69, 0xbc, 0xb5, 0x82, 0x71, 0x98, 0x8e, 0x46, 0x69, 0xa2, 0x56, 0x10, 0x87, 0x15,
	0x41, 0x17, 0xd0, 0xe4, 0x22, 0x0d, 0x06, 0x98, 0x11, 0x77, 0x13, 0x16, 0x05, 0xe6, 0xf8, 0xc8,
	0x73, 0x76, 0x9d, 0xbd, 0x8e, 0xaf, 0x21, 0xd7, 0x85, 0x05, 0x7e, 0x93, 0x11, 0xaf, 0x25, 0xb1,
	0xf2, 0xdf, 0xdd, 0x80, 0x4e, 0x7a, 0x9d, 0x1c, 0x1f, 0x79, 0x6d, 0x89, 0x54, 0x80, 0xbb, 0x0b,
	0xbd, 0xf4, 0x3a, 0x39, 0xa5, 0x57, 0xe4, 0x14, 0x8f, 0x88, 0xb7, 0xb0, 0xeb, 0xec, 0x2d, 0xfb,
	0x36, 0x0a, 0x3d, 0x02, 0x97, 0xe7, 0x38, 0x61, 0x23, 0xca, 0x83, 0x82, 0x91, 0x3c, 0x10, 0x3a,
	0x84, 0x66, 0x01, 0x54, 0x9a, 0x15, 0x84, 0xf6, 0x61, 0x73, 0x9a, 0x3a, 0xc8, 0x09, 0x17, 0xfa,
	0xc5, 0x3f, 0xf3, 0x9c, 0xdd, 0xf6, 0xde, 0x03, 0x5f, 0x01, 0xe8, 0x39, 0x78, 0x97, 0x24, 0xce,
	0x82, 0x9c, 0x64, 0x98, 0xe6, 0xc1, 0xa0, 0xa0, 0x71, 0x14, 0x64, 0xc5, 0x20, 0xa6, 0xa1, 0x8b,
	0xe0, 0x81, 0x84, 0x69, 0x32, 0x3c, 0x17, 0xde, 0x28, 0x4d, 0x35, 0x1c, 0x7a, 0x05, 0xdb, 0x4d,
	0xfc, 0x52, 0xeb, 0x5d, 0x64, 0xfc, 0x18, 0x56, 0xe3, 0x74, 0x48, 0x93, 0xa0, 0x8c, 0xae, 0xdb,
	0x87, 0x76, 0x41, 0x23, 0x4d, 0x2d, 0x7e, 0xd1, 0x87, 0x36, 0xac, 0x4f, 0x50, 0x49, 0x05, 0xdf,
	0xc1, 0x82, 0x40, 0x48, 0xaf, 0x7a, 0x07, 0xeb, 0xfb, 0x66, 0xf7, 0xf6, 0x4b, 0x32, 0x5f, 0x12,
	0xb8, 0x3f, 0x81, 0x6e, 0x58, 0xe4, 0xf9, 0x99, 0x20, 0x16, 0xfb, 0xd2, 0x40, 0x5c, 0x12, 0xb9,
	0x3b, 0x00, 0x59, 0x7a, 0x4d, 0xf2, 0x13, 0x3a, 0xa2, 0xdc, 0xeb, 0x48, 0x53, 0x2c, 0x8c, 0x7b,
	0x04, 0xfd, 0x22, 0x1b, 0xe6, 0x38, 0x22, 0xd1, 0x2b, 0xed, 0x8e, 0xb7, 0x28, 0xad, 0xf0, 0x2a,
	0xc1, 0xc6, 0x51, 0x61, 0x35, 0x27, 0xfe, 0x14, 0x87, 0x90, 0xa2, 0x62, 0x67, 0x49, 0x59, 0xba,
	0x4d, 0xca, 0x24, 0x87, 0xfb, 0x0b, 0xe8, 0xe1, 0x38, 0x2e, 0x05, 0x74, 0x6f, 0x11, 0x60, 0x13,
	0xbb, 0x3f, 0x85, 0x65, 0xe1, 0xfe, 0xeb, 0x18, 0x0f, 0x99, 0xb7, 0x3c, 0x19, 0xc6, 0x8b, 0x18,
	0x0f, 0x55, 0x64, 0x2a, 0x2a, 0x34, 0x86, 0x95, 0xba, 0x44, 0x77, 0x0b, 0xba, 0x62, 0xd9, 0xda,
	0xe3, 0x12, 0x9e, 0xca, 0x81, 0xd6, 0x74, 0x0e, 0xb8, 0xdf, 0xc2, 0x43, 0x03, 0x9f, 0x90, 0x31,
	0x89, 0xf5, 0x29, 0xa9, 0x23, 0xd1, 0x0b, 0x65, 0xaa, 0xca, 0x91, 0xa6, 0xc3, 0x67, 0x9b, 0xd2,
	0xaa, 0x9b, 0x82, 0x9e, 0x40, 0x7f, 0x48, 0xb8, 0x4c, 0x21, 0x16, 0x30, 0x12, 0x93, 0x90, 0x8b,
	0x5c, 0x4b, 0x8a, 0x91, 0xc9, 0xb5, 0xa4, 0x18, 0x99, 0xec, 0x6b, 0x55, 0xd9, 0x77, 0x08, 0x1b,
	0x93, 0x7c, 0x32, 0xfb, 0xb6, 0x95, 0x41, 0x4c, 0xfb, 0xdd, 0xde, 0xeb, 0xf8, 0x15, 0x02, 0x7d,
	0x0f, 0x3d, 0x4d, 0x2b, 0x33, 0x70, 0x4e, 0x8c, 0xd0, 0x47, 0x07, 0x56, 0x2d, 0xda, 0xfb, 0xa5,
	0xf6, 0x33, 0xe8, 0x89, 0xac, 0x25, 0x09, 0xb7, 0xb2, 0x7b, 0x6b, 0x06, 0x7d, 0x10, 0x11, 0x8e,
	0x69, 0xec, 0xdb, 0xe4, 0x62, 0x7b, 0x62, 0xcc, 0xe4, 0xbf, 0x34, 0x4d, 0x45, 0xbe, 0x86, 0x13,
	0xc5, 0xe3, 0x02, 0x53, 0x7e, 0x29, 0x0b, 0x54, 0xc7, 0x57, 0x80, 0xc0, 0x52, 0x4e, 0x46, 0xcc,
	0xeb, 0x48, 0xcf, 0x15, 0x80, 0x56, 0xe1, 0xa1, 0x89, 0x95, 0x54, 0x8a, 0xde, 0xc3, 0x5a, 0x0d,
	0xf1, 0x7f, 0x74, 0x0e, 0xad, 0xc1, 0x6a, 0xa9, 0x9b, 0x5d, 0x52, 0x12, 0x47, 0xe8, 0xaf, 0x0e,
	0xac, 0x4f, 0xe0, 0xa4, 0x45, 0x07, 0xd0, 0x93, 0x6e, 0x9d, 0x49, 0x94, 0xdc, 0xa1, 0xde, 0x41,
	0xdf, 0x52, 0x24, 0xf1, 0xbe, 0x4d, 0xe4, 0xfe, 0x1c, 0x56, 0x06, 0x24, 0xa6, 0x64, 0x4c, 0x72,
	0xcd, 0xd6, 0x6a, 0x60, 0x9b, 0xa0, 0x93, 0x9c, 0x3a, 0xb7, 0x35, 0x67, 0xbb, 0x91, 0xb3, 0x46,
	0x87, 0xce, 0x61, 0x51, 0xad, 0x88, 0xf8, 0x8f, 0x71, 0x5c, 0x98, 0x6c, 0x52, 0x80, 0xc0, 0xc6,
	0xb2, 0x64, 0xa9, 0xfc, 0x55, 0x80, 0xa8, 0x66, 0x45, 0x16, 0x61, 0x4e, 0xce, 0xe9, 0x48, 0xed,
	0x71, 0xdb, 0xb7, 0x30, 0xe8, 0x25, 0xac, 0xa4, 0x19, 0xd1, 0xd5, 0x35, 0x2b, 0xd8, 0xa5, 0xbb,
	0x5f, 0xee, 0xd0, 0x6d, 0x11, 0x97, 0x74, 0xe8, 0x5b, 0xe8, 0x33, 0x82, 0xf3, 0xf0, 0x72, 0x6e,
	0x1d, 0x7f, 0x0d, 0x1b, 0x93, 0x54, 0x32, 0xfa, 0xf7, 0xd5, 0xf6, 0x0f, 0xa7, 0x3a, 0x92, 0xf6,
	0xf2, 0xb4, 0x4a, 0xab, 0x50, 0xb4, 0x6a, 0x85, 0x62, 0x07, 0x40, 0x05, 0xd2, 0x4a, 0x7b, 0x0b,
	0x23, 0x0e, 0x37, 0x65, 0xbf, 0x4c, 0x93, 0x31, 0xc9, 0xb9, 0x4c, 0xfc, 0xae, 0x5f, 0x21, 0xdc,
	0x7d, 0x70, 0xcd, 0x96, 0x9e, 0xa7, 0x1c, 0xc7, 0xaa, 0x6c, 0xa9, 0x36, 0x31, 0x63, 0x45, 0xd2,
	0x9b, 0x8a, 0x57, 0xd1, 0x2f, 0x6a, 0xfa, 0xa9, 0x15, 0xf4, 0x1b, 0xcb, 0xbf, 0x9c, 0x84, 0x69,
	0x1e, 0x35, 0x84, 0x54, 0xf8, 0x77, 0x66, 0xfc, 0x13, 0xe7, 0x50, 0x43, 0x02, 0xff, 0x6b, 0x35,
	0x23, 0xb4, 0x15, 0x5e, 0x41, 0xc8, 0x17, 0x5b, 0x30, 0x43, 0xf2, 0x0e, 0x80, 0x02, 0xad, 0x0a,
	0x65, 0x61, 0x44, 0xfd, 0x52, 0x50, 0x19, 0xc9, 0x12, 0x16, 0x32, 0x23, 0x12, 0x7f, 0x59, 0x99,
	0x7f, 0x70, 0xc0, 0xcb, 0x49, 0x16, 0xe3, 0x90, 0x7c, 0x51, 0xc1, 0xee, 0x1e, 0xac, 0x6a, 0xb9,
	0xbe, 0x21, 0x51, 0xbb, 0x3f, 0x89, 0x46, 0xbf, 0x83, 0xaf, 0x46, 0xe9, 0x78, 0x86, 0x7a, 0x0f,
	0x96, 0x58, 0x1e, 0x5a, 0xba, 0x0d, 0x28, 0xe7, 0xac, 0x3c, 0x2c, 0xb5, 0x2a, 0x40, 0x98, 0x13,
	0x11, 0xc6, 0xad, 0x4c, 0x2b, 0x61, 0xb1, 0x4f, 0xe2, 0xff, 0xf8, 0x48, 0x57, 0x57, 0x0d, 0xa1,
	0xa7, 0xd0, 0x4b, 0xc3, 0xb0, 0xc8, 0x6e, 0x54, 0xfb, 0xb8, 0x73, 0x62, 0x9b, 0x6e, 0x65, 0x0f,
	0x66, 0xd2, 0xe8, 0x6d, 0x58, 0x96, 0x89, 0x66, 0x99, 0x5d, 0x21, 0x50, 0x02, 0xde, 0x2c, 0x2e,
	0x79, 0x3a, 0x7d, 0x58, 0x17, 0x78, 0x5f, 0xa2, 0xe5, 0xe4, 0x70, 0x9c, 0x5c, 0xa4, 0xba, 0x78,
	0xef, 0x56, 0x87, 0x75, 0x7a, 0x16, 0x94, 0x95, 0x7c, 0x16, 0x33, 0xfa, 0x8b, 0x03, 0x9b, 0xb3,
	0xe9, 0xef, 0x32, 0x35, 0xaa, 0x04, 0x10, 0x8c, 0xb2, 0xa0, 0xb5, 0x54, 0x41, 0xab, 0x30, 0x62,
	0x7d, 0x90, 0xa7, 0x57, 0x24, 0xb1, 0x0b, 0x5e, 0x85, 0x11, 0xc1, 0x13, 0xda, 0xab, 0xa8, 0x2b,
	0x08, 0x9d, 0xc1, 0xda, 0x94, 0x55, 0x77, 0x32, 0x68, 0x0b, 0xba, 0x82, 0x91, 0x54, 0xfb, 0x51,
	0xc2, 0xe8, 0xb7, 0xf0, 0xd5, 0xb4, 0xab, 0x22, 0xb0, 0x9b, 0xb0, 0x98, 0x13, 0x56, 0xc4, 0x5c,
	0x8a, 0xec, 0xfa, 0x1a, 0x9a, 0x9e, 0x87, 0x5a, 0x33, 0xe6, 0xa1, 0xda, 0x44, 0xd1, 0x9e, 0x98,
	0x28, 0xbe, 0x81, 0xaf, 0xc5, 0x76, 0xea, 0x66, 0x18, 0x0c, 0xf3, 0xb4, 0xc8, 0x02, 0xd5, 0xa1,
	0xdf, 0xc2, 0x8f, 0x1a, 0x96, 0xa4, 0x4d, 0x1e, 0x2c, 0x09, 0xe0, 0xf8, 0x88, 0xe9, 0x91, 0xc6,
	0x80, 0x62, 0x45, 0x12, 0x97, 0x1e, 0x1a, 0x10, 0x7d, 0xa7, 0x7a, 0x2a, 0x19, 0x0b, 0x81, 0xf3,
	0xea, 0xff, 0x5b, 0x65, 0xd6, 0x04, 0xa1, 0xd4, 0xfb, 0x44, 0x79, 0xa3, 0x33, 0xeb, 0xb6, 0x36,
	0x50, 0xd2, 0xa2, 0xe7, 0xb0, 0x82, 0xe3, 0x38, 0x0d, 0x83, 0x84, 0x5c, 0x37, 0x1d, 0x95, 0x79,
	0x43, 0xe1, 0xbf, 0x1c, 0x70, 0xeb, 0x02, 0x7e, 0xc0, 0xe3, 0x97, 0xdc, 0x3d, 0xf6, 0x9a, 0xe6,
	0x8c, 0xcb, 0xe6, 0xd2, 0xf5, 0x0d, 0x88, 0x10, 0xac, 0x54, 0x57, 0xc2, 0x86, 0xed, 0xb9, 0x00,
	0xb7, 0x4e, 0x23, 0x43, 0xb1, 0x5b, 0xf7, 0x50, 0xd1, 0xd7, 0xbc, 0x30, 0xed, 0xbb, 0x75, 0xc7,
	0xf6, 0xcd, 0x55, 0xb1, 0x99, 0x5c, 0xfd, 0x6f, 0x46, 0x01, 0x77, 0xcf, 0x0c, 0x44, 0x8d, 0xc3,
	0x97, 0x5e, 0x47, 0x27, 0xb0, 0x55, 0xd7, 0x1a, 0xa6, 0xa3, 0x2c, 0x26, 0x9c, 0x4c, 0xe8, 0x6d,
	0xdf, 0xc9, 0x87, 0x0f, 0x8e, 0xe5, 0x84, 0xd5, 0x1c, 0xa4, 0xb0, 0xc7, 0xfa, 0x66, 0x10, 0xa4,
	0x39, 0xd5, 0x12, 0xbd, 0x59, 0x12, 0x07, 0x98, 0x11, 0x95, 0x8b, 0xec, 0x4d, 0x4e, 0xdd, 0xa7,
	0xea, 0x2d, 0x82, 0xc9, 0xcb, 0xbb, 0xec, 0xe7, 0xf3, 0xf8, 0x94, 0x0a, 0xd1, 0xd6, 0xd1, 0x3b,
	0xf0, 0x58, 0x93, 0x2d, 0x9f, 0xd3, 0x84, 0xdf, 0x81, 0x37, 0xab, 0xb1, 0x7f, 0xb6, 0xdc, 0x3f,
	0x3a, 0xb0, 0xdd, 0xd4, 0xdc, 0x3f, 0x57, 0xf8, 0x3d, 0x1a, 0xfc, 0xef, 0xe1, 0x9b, 0x99, 0x0d,
	0xde, 0x14, 0xc2, 0xff, 0x79, 0x93, 0xff, 0xb3, 0x03, 0xab, 0x56, 0x97, 0x97, 0x7a, 0xa7, 0xcb,
	0xd7, 0x21, 0x2c, 0x89, 0xd5, 0x37, 0x65, 0x8e, 0xcf, 0xcb, 0x4e, 0x43, 0x5a, 0x26, 0x74, 0xfb,
	0x8e, 0x87, 0xf2, 0x25, 0xf4, 0x71, 0x14, 0x05, 0x21, 0x1d, 0xd3, 0x98, 0xbe, 0xc7, 0x9c, 0xa6,
	0x89, 0xfb, 0x08, 0xd6, 0x6c, 0xf8, 0x9d, 0x75, 0xdf, 0x98, 0x5e, 0x40, 0x03, 0xf0, 0xa2, 0x1c,
	0x5f, 0xd7, 0x44, 0x04, 0x39, 0xb9, 0xc6, 0x79, 0x74, 0x8f, 0xc1, 0x7c, 0x1b, 0x96, 0x85, 0x14,
	0xfb, 0x21, 0xa0, 0x42, 0xa0, 0x7f, 0x3b, 0xb0, 0xdd, 0xa4, 0xc4, 0xf4, 0xd4, 0x99, 0x0f, 0x03,
	0x35, 0xb1, 0xad, 0x09, 0xb1, 0xaa, 0x13, 0x0b, 0x19, 0x5a, 0xa3, 0x86, 0x1a, 0x6a, 0xaf, 0x07,
	0x4b, 0x11, 0xc5, 0xa3, 0x34, 0x89, 0xf4, 0xc8, 0x6f, 0x40, 0x91, 0x04, 0x43, 0x7c, 0xf3, 0x2b,
	0x9a, 0x26, 0x5c, 0x4f, 0xf7, 0x25, 0x2c, 0xd6, 0xcc, 0xcd, 0x40, 0x3e, 0xf2, 0x2c, 0xfb, 0x25,
	0x2c, 0x6a, 0xac, 0xf9, 0x3f, 0x2d, 0x46, 0xf2, 0x09, 0xa7, 0xe3, 0xdb, 0x28, 0xf4, 0x10, 0x7a,
	0xea, 0xce, 0x4a, 0x38, 0x8f, 0x09, 0x22, 0xb0, 0x6a, 0x81, 0x26, 0x61, 0x73, 0x9c, 0x5c, 0x9d,
	0x96, 0xcf, 0x19, 0x06, 0x14, 0xbe, 0x73, 0x71, 0xb7, 0xf0, 0x71, 0x72, 0x65, 0x7c, 0x2f, 0x11,
	0xc2, 0xae, 0x0c, 0x33, 0x66, 0x4d, 0x4a, 0x25, 0x8c, 0xfa, 0xfa, 0xd5, 0xb3, 0x7c, 0x08, 0x42,
	0x2f, 0xc0, 0xad, 0x63, 0xa4, 0xee, 0xef, 0xa1, 0x73, 0x21, 0x9f, 0x90, 0x9c, 0xe6, 0x27, 0x24,
	0x45, 0x81, 0x9e, 0x41, 0x5f, 0xdd, 0x3c, 0x83, 0x52, 0x8e, 0xeb, 0xc2, 0x82, 0xf8, 0x6a, 0xbb,
	0xe5, 0x7f, 0x75, 0xbf, 0x6d, 0x59, 0xf7, 0x5b, 0xf4, 0x02, 0x36, 0x26, 0xb9, 0x4d, 0xbf, 0x2e,
	0x25, 0x34, 0xe8, 0x97, 0x04, 0xe8, 0x79, 0x29, 0x00, 0xc7, 0xb1, 0x65, 0x42, 0x1f, 0xda, 0x57,
	0xe4, 0xc6, 0x24, 0xe8, 0x15, 0xb9, 0x69, 0x30, 0xe0, 0x00, 0xbc, 0x59, 0xfc, 0xf3, 0xe6, 0x39,
	0xf4, 0x27, 0x47, 0xcd, 0x3d, 0xe9, 0x75, 0x42, 0x72, 0x16, 0x0c, 0x6e, 0x82, 0x30, 0x4d, 0x22,
	0x2a, 0x8f, 0x98, 0x7e, 0x99, 0x55, 0x2c, 0x6d, 0xf5, 0x32, 0x2b, 0x8b, 0x00, 0x49, 0x22, 0x3d,
	0xd8, 0x8a, 0xdf, 0xea, 0x62, 0xdf, 0xb6, 0x2f, 0xf6, 0x1e, 0x2c, 0xc9, 0xa1, 0xf0, 0x64, 0xac,
	0x33, 0xd4, 0x80, 0x22, 0xa4, 0xec, 0x8a, 0x66, 0x3a, 0x41, 0xe5, 0x3f, 0xa2, 0x6a, 0xf4, 0x9b,
	0x61, 0x86, 0x79, 0x24, 0x0e, 0xd3, 0x22, 0xe1, 0xe6, 0x45, 0x41, 0x02, 0xee, 0x21, 0x74, 0x45,
	0x3b, 0x3a, 0xc2, 0x1c, 0x4f, 0xb7, 0xa4, 0x6a, 0x5c, 0x88, 0x30, 0xc7, 0x7e, 0x49, 0x89, 0xfe,
	0xe6, 0xd8, 0xf3, 0x86, 0x58, 0x9c, 0x51, 0x02, 0x1e, 0xc3, 0xb2, 0x49, 0x71, 0xa6, 0x65, 0x7f,
	0x6d, 0x3d, 0x5b, 0xea, 0x25, 0xfd, 0x00, 0x59, 0x52, 0xba, 0x87, 0xaa, 0x4d, 0x9e, 0x71, 0xcc,
	0x29, 0x93, 0xd7, 0xdb, 0xde, 0xc1, 0x46, 0xc5, 0xa7, 0xf0, 0x9c, 0x86, 0xcc, 0xb7, 0xe8, 0x04,
	0x97, 0xe8, 0x95, 0x9a, 0x6b, 0x61, 0x1e, 0x57, 0x45, 0xf7, 0xea, 0xc1, 0xc7, 0x4f, 0x3b, 0xce,
	0xdf, 0x3f, 0xed, 0x38, 0xff, 0xfc, 0xb4, 0xe3, 0x0c, 0x16, 0x25, 0xf9, 0xcf, 0xfe, 0x13, 0x00,
	0x00, 0xff, 0xff, 0x16, 0x8b, 0xa9, 0x76, 0x33, 0x18, 0x00, 0x00,
}
