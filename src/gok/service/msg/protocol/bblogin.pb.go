// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: bblogin.proto

package protocol

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// 服务端不允许login文件名存在,特改为bblogin
// 登录相关通讯协议
type Login_Result int32

const (
	Login_Result_lnone             Login_Result = 0
	Login_Result_loginSuccess      Login_Result = 1
	Login_Result_invalidUser       Login_Result = 2
	Login_Result_invalidPwd        Login_Result = 3
	Login_Result_forbiddenUser     Login_Result = 4
	Login_Result_invalidMaintain   Login_Result = 5
	Login_Result_invalidGameServer Login_Result = 6
)

var Login_Result_name = map[int32]string{
	0: "lnone",
	1: "loginSuccess",
	2: "invalidUser",
	3: "invalidPwd",
	4: "forbiddenUser",
	5: "invalidMaintain",
	6: "invalidGameServer",
}
var Login_Result_value = map[string]int32{
	"lnone":             0,
	"loginSuccess":      1,
	"invalidUser":       2,
	"invalidPwd":        3,
	"forbiddenUser":     4,
	"invalidMaintain":   5,
	"invalidGameServer": 6,
}

func (x Login_Result) String() string {
	return proto.EnumName(Login_Result_name, int32(x))
}
func (Login_Result) EnumDescriptor() ([]byte, []int) { return fileDescriptorBblogin, []int{0} }

type Register_Result int32

const (
	Register_Result_rnone           Register_Result = 0
	Register_Result_registerSuccess Register_Result = 1
	Register_Result_userExists      Register_Result = 2
	Register_Result_invalidFormat   Register_Result = 3
	Register_Result_invalidServer   Register_Result = 6
)

var Register_Result_name = map[int32]string{
	0: "rnone",
	1: "registerSuccess",
	2: "userExists",
	3: "invalidFormat",
	6: "invalidServer",
}
var Register_Result_value = map[string]int32{
	"rnone":           0,
	"registerSuccess": 1,
	"userExists":      2,
	"invalidFormat":   3,
	"invalidServer":   6,
}

func (x Register_Result) String() string {
	return proto.EnumName(Register_Result_name, int32(x))
}
func (Register_Result) EnumDescriptor() ([]byte, []int) { return fileDescriptorBblogin, []int{1} }

type Server_Result int32

const (
	Server_Result_snone       Server_Result = 0
	Server_Result_success     Server_Result = 1
	Server_Result_maintenance Server_Result = 2
	Server_Result_notLogin    Server_Result = 3
)

var Server_Result_name = map[int32]string{
	0: "snone",
	1: "success",
	2: "maintenance",
	3: "notLogin",
}
var Server_Result_value = map[string]int32{
	"snone":       0,
	"success":     1,
	"maintenance": 2,
	"notLogin":    3,
}

func (x Server_Result) String() string {
	return proto.EnumName(Server_Result_name, int32(x))
}
func (Server_Result) EnumDescriptor() ([]byte, []int) { return fileDescriptorBblogin, []int{2} }

// 登录服务器注册账号
type LoginRegister struct {
	Username string `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
	Password string `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"`
}

func (m *LoginRegister) Reset()                    { *m = LoginRegister{} }
func (m *LoginRegister) String() string            { return proto.CompactTextString(m) }
func (*LoginRegister) ProtoMessage()               {}
func (*LoginRegister) Descriptor() ([]byte, []int) { return fileDescriptorBblogin, []int{0} }

func (m *LoginRegister) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *LoginRegister) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

// 登录服务器注册账号返回
type LoginRegisterRet struct {
	Result     Register_Result `protobuf:"varint,1,opt,name=result,proto3,enum=protocol.Register_Result" json:"result,omitempty"`
	Uid        int32           `protobuf:"varint,2,opt,name=uid,proto3" json:"uid,omitempty"`
	Token      string          `protobuf:"bytes,3,opt,name=token,proto3" json:"token,omitempty"`
	GameServer string          `protobuf:"bytes,4,opt,name=gameServer,proto3" json:"gameServer,omitempty"`
	Msg        string          `protobuf:"bytes,5,opt,name=msg,proto3" json:"msg,omitempty"`
}

func (m *LoginRegisterRet) Reset()                    { *m = LoginRegisterRet{} }
func (m *LoginRegisterRet) String() string            { return proto.CompactTextString(m) }
func (*LoginRegisterRet) ProtoMessage()               {}
func (*LoginRegisterRet) Descriptor() ([]byte, []int) { return fileDescriptorBblogin, []int{1} }

func (m *LoginRegisterRet) GetResult() Register_Result {
	if m != nil {
		return m.Result
	}
	return Register_Result_rnone
}

func (m *LoginRegisterRet) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *LoginRegisterRet) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *LoginRegisterRet) GetGameServer() string {
	if m != nil {
		return m.GameServer
	}
	return ""
}

func (m *LoginRegisterRet) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

// 用户名密码登录服务器
type LoginLogin struct {
	Username string `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
	Password string `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"`
}

func (m *LoginLogin) Reset()                    { *m = LoginLogin{} }
func (m *LoginLogin) String() string            { return proto.CompactTextString(m) }
func (*LoginLogin) ProtoMessage()               {}
func (*LoginLogin) Descriptor() ([]byte, []int) { return fileDescriptorBblogin, []int{2} }

func (m *LoginLogin) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *LoginLogin) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

// 登录服务器返回
type LoginLoginRet struct {
	Result     Login_Result `protobuf:"varint,1,opt,name=result,proto3,enum=protocol.Login_Result" json:"result,omitempty"`
	Uid        int32        `protobuf:"varint,2,opt,name=uid,proto3" json:"uid,omitempty"`
	Token      string       `protobuf:"bytes,3,opt,name=token,proto3" json:"token,omitempty"`
	GameServer string       `protobuf:"bytes,4,opt,name=gameServer,proto3" json:"gameServer,omitempty"`
}

func (m *LoginLoginRet) Reset()                    { *m = LoginLoginRet{} }
func (m *LoginLoginRet) String() string            { return proto.CompactTextString(m) }
func (*LoginLoginRet) ProtoMessage()               {}
func (*LoginLoginRet) Descriptor() ([]byte, []int) { return fileDescriptorBblogin, []int{3} }

func (m *LoginLoginRet) GetResult() Login_Result {
	if m != nil {
		return m.Result
	}
	return Login_Result_lnone
}

func (m *LoginLoginRet) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *LoginLoginRet) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *LoginLoginRet) GetGameServer() string {
	if m != nil {
		return m.GameServer
	}
	return ""
}

// 登录游戏服务器
type LoginServer struct {
	Token      string      `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
	Platform   string      `protobuf:"bytes,2,opt,name=platform,proto3" json:"platform,omitempty"`
	Version    string      `protobuf:"bytes,3,opt,name=version,proto3" json:"version,omitempty"`
	ServerId   int32       `protobuf:"varint,4,opt,name=serverId,proto3" json:"serverId,omitempty"`
	DeviceId   string      `protobuf:"bytes,5,opt,name=deviceId,proto3" json:"deviceId,omitempty"`
	Channel    string      `protobuf:"bytes,6,opt,name=channel,proto3" json:"channel,omitempty"`
	UserId     int32       `protobuf:"varint,7,opt,name=userId,proto3" json:"userId,omitempty"`
	Ip         string      `protobuf:"bytes,9,opt,name=ip,proto3" json:"ip,omitempty"`
	InviteID   int32       `protobuf:"varint,10,opt,name=inviteID,proto3" json:"inviteID,omitempty"`
	InviteType *InviteType `protobuf:"bytes,11,opt,name=inviteType" json:"inviteType,omitempty"`
}

func (m *LoginServer) Reset()                    { *m = LoginServer{} }
func (m *LoginServer) String() string            { return proto.CompactTextString(m) }
func (*LoginServer) ProtoMessage()               {}
func (*LoginServer) Descriptor() ([]byte, []int) { return fileDescriptorBblogin, []int{4} }

func (m *LoginServer) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *LoginServer) GetPlatform() string {
	if m != nil {
		return m.Platform
	}
	return ""
}

func (m *LoginServer) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *LoginServer) GetServerId() int32 {
	if m != nil {
		return m.ServerId
	}
	return 0
}

func (m *LoginServer) GetDeviceId() string {
	if m != nil {
		return m.DeviceId
	}
	return ""
}

func (m *LoginServer) GetChannel() string {
	if m != nil {
		return m.Channel
	}
	return ""
}

func (m *LoginServer) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *LoginServer) GetIp() string {
	if m != nil {
		return m.Ip
	}
	return ""
}

func (m *LoginServer) GetInviteID() int32 {
	if m != nil {
		return m.InviteID
	}
	return 0
}

func (m *LoginServer) GetInviteType() *InviteType {
	if m != nil {
		return m.InviteType
	}
	return nil
}

// 登录游戏服务器返回
type LoginSeverRet struct {
	RoleInfo   *RoleInfo `protobuf:"bytes,1,opt,name=roleInfo" json:"roleInfo,omitempty"`
	UserId     int32     `protobuf:"varint,2,opt,name=userId,proto3" json:"userId,omitempty"`
	ServerTime int64     `protobuf:"varint,3,opt,name=serverTime,proto3" json:"serverTime,omitempty"`
}

func (m *LoginSeverRet) Reset()                    { *m = LoginSeverRet{} }
func (m *LoginSeverRet) String() string            { return proto.CompactTextString(m) }
func (*LoginSeverRet) ProtoMessage()               {}
func (*LoginSeverRet) Descriptor() ([]byte, []int) { return fileDescriptorBblogin, []int{5} }

func (m *LoginSeverRet) GetRoleInfo() *RoleInfo {
	if m != nil {
		return m.RoleInfo
	}
	return nil
}

func (m *LoginSeverRet) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *LoginSeverRet) GetServerTime() int64 {
	if m != nil {
		return m.ServerTime
	}
	return 0
}

// 渠道登录
type ChannelLogin struct {
	Channel    string `protobuf:"bytes,1,opt,name=channel,proto3" json:"channel,omitempty"`
	ChannelUID string `protobuf:"bytes,2,opt,name=channelUID,proto3" json:"channelUID,omitempty"`
	OpenID     string `protobuf:"bytes,3,opt,name=openID,proto3" json:"openID,omitempty"`
	Nickname   string `protobuf:"bytes,4,opt,name=nickname,proto3" json:"nickname,omitempty"`
	Avatar     string `protobuf:"bytes,5,opt,name=avatar,proto3" json:"avatar,omitempty"`
}

func (m *ChannelLogin) Reset()                    { *m = ChannelLogin{} }
func (m *ChannelLogin) String() string            { return proto.CompactTextString(m) }
func (*ChannelLogin) ProtoMessage()               {}
func (*ChannelLogin) Descriptor() ([]byte, []int) { return fileDescriptorBblogin, []int{6} }

func (m *ChannelLogin) GetChannel() string {
	if m != nil {
		return m.Channel
	}
	return ""
}

func (m *ChannelLogin) GetChannelUID() string {
	if m != nil {
		return m.ChannelUID
	}
	return ""
}

func (m *ChannelLogin) GetOpenID() string {
	if m != nil {
		return m.OpenID
	}
	return ""
}

func (m *ChannelLogin) GetNickname() string {
	if m != nil {
		return m.Nickname
	}
	return ""
}

func (m *ChannelLogin) GetAvatar() string {
	if m != nil {
		return m.Avatar
	}
	return ""
}

// 渠道登录结果
type ChannelLoginRet struct {
	Result     int32  `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
	Uid        int32  `protobuf:"varint,2,opt,name=uid,proto3" json:"uid,omitempty"`
	Token      string `protobuf:"bytes,3,opt,name=token,proto3" json:"token,omitempty"`
	New        bool   `protobuf:"varint,4,opt,name=new,proto3" json:"new,omitempty"`
	GameServer string `protobuf:"bytes,5,opt,name=gameServer,proto3" json:"gameServer,omitempty"`
}

func (m *ChannelLoginRet) Reset()                    { *m = ChannelLoginRet{} }
func (m *ChannelLoginRet) String() string            { return proto.CompactTextString(m) }
func (*ChannelLoginRet) ProtoMessage()               {}
func (*ChannelLoginRet) Descriptor() ([]byte, []int) { return fileDescriptorBblogin, []int{7} }

func (m *ChannelLoginRet) GetResult() int32 {
	if m != nil {
		return m.Result
	}
	return 0
}

func (m *ChannelLoginRet) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *ChannelLoginRet) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *ChannelLoginRet) GetNew() bool {
	if m != nil {
		return m.New
	}
	return false
}

func (m *ChannelLoginRet) GetGameServer() string {
	if m != nil {
		return m.GameServer
	}
	return ""
}

type ChangeUserState struct {
	Uid   int32 `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
	State int32 `protobuf:"varint,2,opt,name=state,proto3" json:"state,omitempty"`
}

func (m *ChangeUserState) Reset()                    { *m = ChangeUserState{} }
func (m *ChangeUserState) String() string            { return proto.CompactTextString(m) }
func (*ChangeUserState) ProtoMessage()               {}
func (*ChangeUserState) Descriptor() ([]byte, []int) { return fileDescriptorBblogin, []int{8} }

func (m *ChangeUserState) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *ChangeUserState) GetState() int32 {
	if m != nil {
		return m.State
	}
	return 0
}

type ChangeUserStateRet struct {
	Result bool `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
}

func (m *ChangeUserStateRet) Reset()                    { *m = ChangeUserStateRet{} }
func (m *ChangeUserStateRet) String() string            { return proto.CompactTextString(m) }
func (*ChangeUserStateRet) ProtoMessage()               {}
func (*ChangeUserStateRet) Descriptor() ([]byte, []int) { return fileDescriptorBblogin, []int{9} }

func (m *ChangeUserStateRet) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

// 转移用户会话数据
type TransferRemoteUserSession struct {
	Uid int32 `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
}

func (m *TransferRemoteUserSession) Reset()         { *m = TransferRemoteUserSession{} }
func (m *TransferRemoteUserSession) String() string { return proto.CompactTextString(m) }
func (*TransferRemoteUserSession) ProtoMessage()    {}
func (*TransferRemoteUserSession) Descriptor() ([]byte, []int) {
	return fileDescriptorBblogin, []int{10}
}

func (m *TransferRemoteUserSession) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

type TransferRemoteUserSessionRet struct {
	Session []byte `protobuf:"bytes,1,opt,name=session,proto3" json:"session,omitempty"`
}

func (m *TransferRemoteUserSessionRet) Reset()         { *m = TransferRemoteUserSessionRet{} }
func (m *TransferRemoteUserSessionRet) String() string { return proto.CompactTextString(m) }
func (*TransferRemoteUserSessionRet) ProtoMessage()    {}
func (*TransferRemoteUserSessionRet) Descriptor() ([]byte, []int) {
	return fileDescriptorBblogin, []int{11}
}

func (m *TransferRemoteUserSessionRet) GetSession() []byte {
	if m != nil {
		return m.Session
	}
	return nil
}

type RefreshClientVersion struct {
}

func (m *RefreshClientVersion) Reset()                    { *m = RefreshClientVersion{} }
func (m *RefreshClientVersion) String() string            { return proto.CompactTextString(m) }
func (*RefreshClientVersion) ProtoMessage()               {}
func (*RefreshClientVersion) Descriptor() ([]byte, []int) { return fileDescriptorBblogin, []int{12} }

type RefreshClientVersionRet struct {
	Result bool `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
}

func (m *RefreshClientVersionRet) Reset()                    { *m = RefreshClientVersionRet{} }
func (m *RefreshClientVersionRet) String() string            { return proto.CompactTextString(m) }
func (*RefreshClientVersionRet) ProtoMessage()               {}
func (*RefreshClientVersionRet) Descriptor() ([]byte, []int) { return fileDescriptorBblogin, []int{13} }

func (m *RefreshClientVersionRet) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

type WechatEventPush struct {
	Uid   int32  `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
	Event string `protobuf:"bytes,2,opt,name=event,proto3" json:"event,omitempty"`
	Delay int32  `protobuf:"varint,3,opt,name=delay,proto3" json:"delay,omitempty"`
}

func (m *WechatEventPush) Reset()                    { *m = WechatEventPush{} }
func (m *WechatEventPush) String() string            { return proto.CompactTextString(m) }
func (*WechatEventPush) ProtoMessage()               {}
func (*WechatEventPush) Descriptor() ([]byte, []int) { return fileDescriptorBblogin, []int{14} }

func (m *WechatEventPush) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *WechatEventPush) GetEvent() string {
	if m != nil {
		return m.Event
	}
	return ""
}

func (m *WechatEventPush) GetDelay() int32 {
	if m != nil {
		return m.Delay
	}
	return 0
}

type CleanTestAccount struct {
	Uid int32 `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
}

func (m *CleanTestAccount) Reset()                    { *m = CleanTestAccount{} }
func (m *CleanTestAccount) String() string            { return proto.CompactTextString(m) }
func (*CleanTestAccount) ProtoMessage()               {}
func (*CleanTestAccount) Descriptor() ([]byte, []int) { return fileDescriptorBblogin, []int{15} }

func (m *CleanTestAccount) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

type CleanTestAccountRet struct {
	Result  bool   `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
	Message string `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *CleanTestAccountRet) Reset()                    { *m = CleanTestAccountRet{} }
func (m *CleanTestAccountRet) String() string            { return proto.CompactTextString(m) }
func (*CleanTestAccountRet) ProtoMessage()               {}
func (*CleanTestAccountRet) Descriptor() ([]byte, []int) { return fileDescriptorBblogin, []int{16} }

func (m *CleanTestAccountRet) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func (m *CleanTestAccountRet) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type QueryByUsername struct {
	Username string `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
}

func (m *QueryByUsername) Reset()                    { *m = QueryByUsername{} }
func (m *QueryByUsername) String() string            { return proto.CompactTextString(m) }
func (*QueryByUsername) ProtoMessage()               {}
func (*QueryByUsername) Descriptor() ([]byte, []int) { return fileDescriptorBblogin, []int{17} }

func (m *QueryByUsername) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

type QueryByUsernameRet struct {
	Uids []int32 `protobuf:"varint,1,rep,packed,name=uids" json:"uids,omitempty"`
}

func (m *QueryByUsernameRet) Reset()                    { *m = QueryByUsernameRet{} }
func (m *QueryByUsernameRet) String() string            { return proto.CompactTextString(m) }
func (*QueryByUsernameRet) ProtoMessage()               {}
func (*QueryByUsernameRet) Descriptor() ([]byte, []int) { return fileDescriptorBblogin, []int{18} }

func (m *QueryByUsernameRet) GetUids() []int32 {
	if m != nil {
		return m.Uids
	}
	return nil
}

func init() {
	proto.RegisterType((*LoginRegister)(nil), "protocol.login_register")
	proto.RegisterType((*LoginRegisterRet)(nil), "protocol.login_register_ret")
	proto.RegisterType((*LoginLogin)(nil), "protocol.login_login")
	proto.RegisterType((*LoginLoginRet)(nil), "protocol.login_login_ret")
	proto.RegisterType((*LoginServer)(nil), "protocol.login_server")
	proto.RegisterType((*LoginSeverRet)(nil), "protocol.login_sever_ret")
	proto.RegisterType((*ChannelLogin)(nil), "protocol.channel_login")
	proto.RegisterType((*ChannelLoginRet)(nil), "protocol.channel_login_ret")
	proto.RegisterType((*ChangeUserState)(nil), "protocol.change_user_state")
	proto.RegisterType((*ChangeUserStateRet)(nil), "protocol.change_user_state_ret")
	proto.RegisterType((*TransferRemoteUserSession)(nil), "protocol.transfer_remote_user_session")
	proto.RegisterType((*TransferRemoteUserSessionRet)(nil), "protocol.transfer_remote_user_session_ret")
	proto.RegisterType((*RefreshClientVersion)(nil), "protocol.refresh_client_version")
	proto.RegisterType((*RefreshClientVersionRet)(nil), "protocol.refresh_client_version_ret")
	proto.RegisterType((*WechatEventPush)(nil), "protocol.wechat_event_push")
	proto.RegisterType((*CleanTestAccount)(nil), "protocol.clean_test_account")
	proto.RegisterType((*CleanTestAccountRet)(nil), "protocol.clean_test_account_ret")
	proto.RegisterType((*QueryByUsername)(nil), "protocol.query_by_username")
	proto.RegisterType((*QueryByUsernameRet)(nil), "protocol.query_by_username_ret")
	proto.RegisterEnum("protocol.Login_Result", Login_Result_name, Login_Result_value)
	proto.RegisterEnum("protocol.Register_Result", Register_Result_name, Register_Result_value)
	proto.RegisterEnum("protocol.Server_Result", Server_Result_name, Server_Result_value)
}
func (m *LoginRegister) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoginRegister) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Username) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBblogin(dAtA, i, uint64(len(m.Username)))
		i += copy(dAtA[i:], m.Username)
	}
	if len(m.Password) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBblogin(dAtA, i, uint64(len(m.Password)))
		i += copy(dAtA[i:], m.Password)
	}
	return i, nil
}

func (m *LoginRegisterRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoginRegisterRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBblogin(dAtA, i, uint64(m.Result))
	}
	if m.Uid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBblogin(dAtA, i, uint64(m.Uid))
	}
	if len(m.Token) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBblogin(dAtA, i, uint64(len(m.Token)))
		i += copy(dAtA[i:], m.Token)
	}
	if len(m.GameServer) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintBblogin(dAtA, i, uint64(len(m.GameServer)))
		i += copy(dAtA[i:], m.GameServer)
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintBblogin(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	return i, nil
}

func (m *LoginLogin) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoginLogin) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Username) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBblogin(dAtA, i, uint64(len(m.Username)))
		i += copy(dAtA[i:], m.Username)
	}
	if len(m.Password) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBblogin(dAtA, i, uint64(len(m.Password)))
		i += copy(dAtA[i:], m.Password)
	}
	return i, nil
}

func (m *LoginLoginRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoginLoginRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBblogin(dAtA, i, uint64(m.Result))
	}
	if m.Uid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBblogin(dAtA, i, uint64(m.Uid))
	}
	if len(m.Token) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBblogin(dAtA, i, uint64(len(m.Token)))
		i += copy(dAtA[i:], m.Token)
	}
	if len(m.GameServer) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintBblogin(dAtA, i, uint64(len(m.GameServer)))
		i += copy(dAtA[i:], m.GameServer)
	}
	return i, nil
}

func (m *LoginServer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoginServer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Token) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBblogin(dAtA, i, uint64(len(m.Token)))
		i += copy(dAtA[i:], m.Token)
	}
	if len(m.Platform) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBblogin(dAtA, i, uint64(len(m.Platform)))
		i += copy(dAtA[i:], m.Platform)
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBblogin(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if m.ServerId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintBblogin(dAtA, i, uint64(m.ServerId))
	}
	if len(m.DeviceId) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintBblogin(dAtA, i, uint64(len(m.DeviceId)))
		i += copy(dAtA[i:], m.DeviceId)
	}
	if len(m.Channel) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintBblogin(dAtA, i, uint64(len(m.Channel)))
		i += copy(dAtA[i:], m.Channel)
	}
	if m.UserId != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintBblogin(dAtA, i, uint64(m.UserId))
	}
	if len(m.Ip) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintBblogin(dAtA, i, uint64(len(m.Ip)))
		i += copy(dAtA[i:], m.Ip)
	}
	if m.InviteID != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintBblogin(dAtA, i, uint64(m.InviteID))
	}
	if m.InviteType != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintBblogin(dAtA, i, uint64(m.InviteType.Size()))
		n1, err := m.InviteType.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *LoginSeverRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoginSeverRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RoleInfo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBblogin(dAtA, i, uint64(m.RoleInfo.Size()))
		n2, err := m.RoleInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.UserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBblogin(dAtA, i, uint64(m.UserId))
	}
	if m.ServerTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBblogin(dAtA, i, uint64(m.ServerTime))
	}
	return i, nil
}

func (m *ChannelLogin) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChannelLogin) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Channel) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBblogin(dAtA, i, uint64(len(m.Channel)))
		i += copy(dAtA[i:], m.Channel)
	}
	if len(m.ChannelUID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBblogin(dAtA, i, uint64(len(m.ChannelUID)))
		i += copy(dAtA[i:], m.ChannelUID)
	}
	if len(m.OpenID) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBblogin(dAtA, i, uint64(len(m.OpenID)))
		i += copy(dAtA[i:], m.OpenID)
	}
	if len(m.Nickname) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintBblogin(dAtA, i, uint64(len(m.Nickname)))
		i += copy(dAtA[i:], m.Nickname)
	}
	if len(m.Avatar) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintBblogin(dAtA, i, uint64(len(m.Avatar)))
		i += copy(dAtA[i:], m.Avatar)
	}
	return i, nil
}

func (m *ChannelLoginRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChannelLoginRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBblogin(dAtA, i, uint64(m.Result))
	}
	if m.Uid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBblogin(dAtA, i, uint64(m.Uid))
	}
	if len(m.Token) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBblogin(dAtA, i, uint64(len(m.Token)))
		i += copy(dAtA[i:], m.Token)
	}
	if m.New {
		dAtA[i] = 0x20
		i++
		if m.New {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.GameServer) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintBblogin(dAtA, i, uint64(len(m.GameServer)))
		i += copy(dAtA[i:], m.GameServer)
	}
	return i, nil
}

func (m *ChangeUserState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChangeUserState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBblogin(dAtA, i, uint64(m.Uid))
	}
	if m.State != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBblogin(dAtA, i, uint64(m.State))
	}
	return i, nil
}

func (m *ChangeUserStateRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChangeUserStateRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result {
		dAtA[i] = 0x8
		i++
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *TransferRemoteUserSession) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransferRemoteUserSession) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBblogin(dAtA, i, uint64(m.Uid))
	}
	return i, nil
}

func (m *TransferRemoteUserSessionRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransferRemoteUserSessionRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Session) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBblogin(dAtA, i, uint64(len(m.Session)))
		i += copy(dAtA[i:], m.Session)
	}
	return i, nil
}

func (m *RefreshClientVersion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RefreshClientVersion) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *RefreshClientVersionRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RefreshClientVersionRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result {
		dAtA[i] = 0x8
		i++
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *WechatEventPush) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WechatEventPush) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBblogin(dAtA, i, uint64(m.Uid))
	}
	if len(m.Event) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBblogin(dAtA, i, uint64(len(m.Event)))
		i += copy(dAtA[i:], m.Event)
	}
	if m.Delay != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBblogin(dAtA, i, uint64(m.Delay))
	}
	return i, nil
}

func (m *CleanTestAccount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CleanTestAccount) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBblogin(dAtA, i, uint64(m.Uid))
	}
	return i, nil
}

func (m *CleanTestAccountRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CleanTestAccountRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result {
		dAtA[i] = 0x8
		i++
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBblogin(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	return i, nil
}

func (m *QueryByUsername) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryByUsername) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Username) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBblogin(dAtA, i, uint64(len(m.Username)))
		i += copy(dAtA[i:], m.Username)
	}
	return i, nil
}

func (m *QueryByUsernameRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryByUsernameRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uids) > 0 {
		dAtA4 := make([]byte, len(m.Uids)*10)
		var j3 int
		for _, num1 := range m.Uids {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintBblogin(dAtA, i, uint64(j3))
		i += copy(dAtA[i:], dAtA4[:j3])
	}
	return i, nil
}

func encodeVarintBblogin(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *LoginRegister) Size() (n int) {
	var l int
	_ = l
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovBblogin(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovBblogin(uint64(l))
	}
	return n
}

func (m *LoginRegisterRet) Size() (n int) {
	var l int
	_ = l
	if m.Result != 0 {
		n += 1 + sovBblogin(uint64(m.Result))
	}
	if m.Uid != 0 {
		n += 1 + sovBblogin(uint64(m.Uid))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovBblogin(uint64(l))
	}
	l = len(m.GameServer)
	if l > 0 {
		n += 1 + l + sovBblogin(uint64(l))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovBblogin(uint64(l))
	}
	return n
}

func (m *LoginLogin) Size() (n int) {
	var l int
	_ = l
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovBblogin(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovBblogin(uint64(l))
	}
	return n
}

func (m *LoginLoginRet) Size() (n int) {
	var l int
	_ = l
	if m.Result != 0 {
		n += 1 + sovBblogin(uint64(m.Result))
	}
	if m.Uid != 0 {
		n += 1 + sovBblogin(uint64(m.Uid))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovBblogin(uint64(l))
	}
	l = len(m.GameServer)
	if l > 0 {
		n += 1 + l + sovBblogin(uint64(l))
	}
	return n
}

func (m *LoginServer) Size() (n int) {
	var l int
	_ = l
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovBblogin(uint64(l))
	}
	l = len(m.Platform)
	if l > 0 {
		n += 1 + l + sovBblogin(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovBblogin(uint64(l))
	}
	if m.ServerId != 0 {
		n += 1 + sovBblogin(uint64(m.ServerId))
	}
	l = len(m.DeviceId)
	if l > 0 {
		n += 1 + l + sovBblogin(uint64(l))
	}
	l = len(m.Channel)
	if l > 0 {
		n += 1 + l + sovBblogin(uint64(l))
	}
	if m.UserId != 0 {
		n += 1 + sovBblogin(uint64(m.UserId))
	}
	l = len(m.Ip)
	if l > 0 {
		n += 1 + l + sovBblogin(uint64(l))
	}
	if m.InviteID != 0 {
		n += 1 + sovBblogin(uint64(m.InviteID))
	}
	if m.InviteType != nil {
		l = m.InviteType.Size()
		n += 1 + l + sovBblogin(uint64(l))
	}
	return n
}

func (m *LoginSeverRet) Size() (n int) {
	var l int
	_ = l
	if m.RoleInfo != nil {
		l = m.RoleInfo.Size()
		n += 1 + l + sovBblogin(uint64(l))
	}
	if m.UserId != 0 {
		n += 1 + sovBblogin(uint64(m.UserId))
	}
	if m.ServerTime != 0 {
		n += 1 + sovBblogin(uint64(m.ServerTime))
	}
	return n
}

func (m *ChannelLogin) Size() (n int) {
	var l int
	_ = l
	l = len(m.Channel)
	if l > 0 {
		n += 1 + l + sovBblogin(uint64(l))
	}
	l = len(m.ChannelUID)
	if l > 0 {
		n += 1 + l + sovBblogin(uint64(l))
	}
	l = len(m.OpenID)
	if l > 0 {
		n += 1 + l + sovBblogin(uint64(l))
	}
	l = len(m.Nickname)
	if l > 0 {
		n += 1 + l + sovBblogin(uint64(l))
	}
	l = len(m.Avatar)
	if l > 0 {
		n += 1 + l + sovBblogin(uint64(l))
	}
	return n
}

func (m *ChannelLoginRet) Size() (n int) {
	var l int
	_ = l
	if m.Result != 0 {
		n += 1 + sovBblogin(uint64(m.Result))
	}
	if m.Uid != 0 {
		n += 1 + sovBblogin(uint64(m.Uid))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovBblogin(uint64(l))
	}
	if m.New {
		n += 2
	}
	l = len(m.GameServer)
	if l > 0 {
		n += 1 + l + sovBblogin(uint64(l))
	}
	return n
}

func (m *ChangeUserState) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovBblogin(uint64(m.Uid))
	}
	if m.State != 0 {
		n += 1 + sovBblogin(uint64(m.State))
	}
	return n
}

func (m *ChangeUserStateRet) Size() (n int) {
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	return n
}

func (m *TransferRemoteUserSession) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovBblogin(uint64(m.Uid))
	}
	return n
}

func (m *TransferRemoteUserSessionRet) Size() (n int) {
	var l int
	_ = l
	l = len(m.Session)
	if l > 0 {
		n += 1 + l + sovBblogin(uint64(l))
	}
	return n
}

func (m *RefreshClientVersion) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *RefreshClientVersionRet) Size() (n int) {
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	return n
}

func (m *WechatEventPush) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovBblogin(uint64(m.Uid))
	}
	l = len(m.Event)
	if l > 0 {
		n += 1 + l + sovBblogin(uint64(l))
	}
	if m.Delay != 0 {
		n += 1 + sovBblogin(uint64(m.Delay))
	}
	return n
}

func (m *CleanTestAccount) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovBblogin(uint64(m.Uid))
	}
	return n
}

func (m *CleanTestAccountRet) Size() (n int) {
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovBblogin(uint64(l))
	}
	return n
}

func (m *QueryByUsername) Size() (n int) {
	var l int
	_ = l
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovBblogin(uint64(l))
	}
	return n
}

func (m *QueryByUsernameRet) Size() (n int) {
	var l int
	_ = l
	if len(m.Uids) > 0 {
		l = 0
		for _, e := range m.Uids {
			l += sovBblogin(uint64(e))
		}
		n += 1 + sovBblogin(uint64(l)) + l
	}
	return n
}

func sovBblogin(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozBblogin(x uint64) (n int) {
	return sovBblogin(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *LoginRegister) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBblogin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: login_register: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: login_register: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBblogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBblogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBblogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBblogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBblogin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBblogin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoginRegisterRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBblogin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: login_register_ret: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: login_register_ret: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBblogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= (Register_Result(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBblogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBblogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBblogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameServer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBblogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBblogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GameServer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBblogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBblogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBblogin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBblogin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoginLogin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBblogin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: login_login: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: login_login: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBblogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBblogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBblogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBblogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBblogin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBblogin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoginLoginRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBblogin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: login_login_ret: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: login_login_ret: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBblogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= (Login_Result(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBblogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBblogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBblogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameServer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBblogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBblogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GameServer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBblogin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBblogin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoginServer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBblogin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: login_server: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: login_server: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBblogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBblogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Platform", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBblogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBblogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Platform = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBblogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBblogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerId", wireType)
			}
			m.ServerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBblogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBblogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBblogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBblogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBblogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBblogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBblogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBblogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InviteID", wireType)
			}
			m.InviteID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBblogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InviteID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InviteType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBblogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBblogin
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InviteType == nil {
				m.InviteType = &InviteType{}
			}
			if err := m.InviteType.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBblogin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBblogin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoginSeverRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBblogin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: login_sever_ret: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: login_sever_ret: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoleInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBblogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBblogin
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RoleInfo == nil {
				m.RoleInfo = &RoleInfo{}
			}
			if err := m.RoleInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBblogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerTime", wireType)
			}
			m.ServerTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBblogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBblogin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBblogin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChannelLogin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBblogin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: channel_login: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: channel_login: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBblogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBblogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelUID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBblogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBblogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChannelUID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBblogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBblogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpenID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nickname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBblogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBblogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nickname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Avatar", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBblogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBblogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Avatar = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBblogin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBblogin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChannelLoginRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBblogin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: channel_login_ret: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: channel_login_ret: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBblogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBblogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBblogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBblogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field New", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBblogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.New = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameServer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBblogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBblogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GameServer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBblogin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBblogin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangeUserState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBblogin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: change_user_state: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: change_user_state: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBblogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBblogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBblogin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBblogin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangeUserStateRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBblogin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: change_user_state_ret: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: change_user_state_ret: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBblogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipBblogin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBblogin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransferRemoteUserSession) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBblogin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: transfer_remote_user_session: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: transfer_remote_user_session: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBblogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBblogin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBblogin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransferRemoteUserSessionRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBblogin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: transfer_remote_user_session_ret: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: transfer_remote_user_session_ret: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Session", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBblogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBblogin
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Session = append(m.Session[:0], dAtA[iNdEx:postIndex]...)
			if m.Session == nil {
				m.Session = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBblogin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBblogin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RefreshClientVersion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBblogin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: refresh_client_version: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: refresh_client_version: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipBblogin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBblogin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RefreshClientVersionRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBblogin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: refresh_client_version_ret: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: refresh_client_version_ret: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBblogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipBblogin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBblogin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WechatEventPush) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBblogin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: wechat_event_push: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: wechat_event_push: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBblogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Event", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBblogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBblogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Event = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delay", wireType)
			}
			m.Delay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBblogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Delay |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBblogin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBblogin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CleanTestAccount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBblogin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: clean_test_account: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: clean_test_account: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBblogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBblogin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBblogin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CleanTestAccountRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBblogin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: clean_test_account_ret: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: clean_test_account_ret: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBblogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBblogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBblogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBblogin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBblogin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryByUsername) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBblogin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: query_by_username: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: query_by_username: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBblogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBblogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBblogin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBblogin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryByUsernameRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBblogin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: query_by_username_ret: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: query_by_username_ret: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBblogin
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Uids = append(m.Uids, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBblogin
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBblogin
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBblogin
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Uids = append(m.Uids, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Uids", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBblogin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBblogin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBblogin(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBblogin
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBblogin
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBblogin
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthBblogin
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowBblogin
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipBblogin(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthBblogin = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBblogin   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("bblogin.proto", fileDescriptorBblogin) }

var fileDescriptorBblogin = []byte{
	// 886 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x55, 0xcd, 0x6e, 0xeb, 0x44,
	0x14, 0xc6, 0x49, 0xdd, 0xa6, 0x27, 0x6d, 0xea, 0x4c, 0x69, 0x64, 0x2a, 0x14, 0x55, 0x5e, 0xa0,
	0xea, 0x22, 0xb5, 0x50, 0x60, 0x05, 0x2b, 0xd4, 0x7b, 0x21, 0x08, 0x24, 0xf0, 0xbd, 0x77, 0x6d,
	0x4d, 0xec, 0x93, 0x74, 0x74, 0xed, 0x99, 0x30, 0x33, 0x49, 0x09, 0x7b, 0x16, 0x88, 0x35, 0x0f,
	0xc0, 0x8a, 0x57, 0x61, 0xc9, 0x23, 0xa0, 0x3e, 0x09, 0x9a, 0x1f, 0xbb, 0x4e, 0x53, 0x2a, 0x81,
	0xc4, 0x26, 0x99, 0x6f, 0xce, 0xdf, 0x77, 0xbe, 0x39, 0x39, 0x81, 0xc3, 0xe9, 0xb4, 0x14, 0x73,
	0xc6, 0x2f, 0x16, 0x52, 0x68, 0x41, 0x7a, 0xf6, 0x2b, 0x17, 0xe5, 0xe9, 0x80, 0xd2, 0x5c, 0x54,
	0x95, 0xf0, 0x96, 0xe4, 0x4b, 0x18, 0x58, 0xc7, 0x4c, 0xe2, 0x9c, 0x29, 0x8d, 0x92, 0x9c, 0x42,
	0x6f, 0xa9, 0x50, 0x72, 0x5a, 0x61, 0x1c, 0x9c, 0x05, 0xe7, 0xfb, 0x69, 0x83, 0x8d, 0x6d, 0x41,
	0x95, 0xba, 0x15, 0xb2, 0x88, 0x3b, 0xce, 0x56, 0xe3, 0xe4, 0xb7, 0x00, 0xc8, 0x66, 0xaa, 0x4c,
	0xa2, 0x26, 0x1f, 0xc2, 0xae, 0x44, 0xb5, 0x2c, 0xb5, 0x4d, 0x36, 0xb8, 0x7a, 0xe7, 0xa2, 0xe6,
	0x72, 0xd1, 0xf8, 0xa5, 0xd6, 0x21, 0xf5, 0x8e, 0x24, 0x82, 0xee, 0x92, 0xb9, 0x02, 0x61, 0x6a,
	0x8e, 0xe4, 0x6d, 0x08, 0xb5, 0x78, 0x83, 0x3c, 0xee, 0xda, 0xa2, 0x0e, 0x90, 0x31, 0xc0, 0x9c,
	0x56, 0xf8, 0x12, 0xe5, 0x0a, 0x65, 0xbc, 0x63, 0x4d, 0xad, 0x1b, 0x93, 0xa7, 0x52, 0xf3, 0x38,
	0xb4, 0x06, 0x73, 0x4c, 0x9e, 0x43, 0xdf, 0x51, 0xb4, 0x9f, 0xff, 0xb9, 0xd5, 0x9f, 0x03, 0x38,
	0x6a, 0xe5, 0xb1, 0x7d, 0x5e, 0x3c, 0xe8, 0x73, 0x74, 0xdf, 0xa7, 0x73, 0xfa, 0x7f, 0x9a, 0x4c,
	0x7e, 0xef, 0xc0, 0x81, 0x2b, 0xa0, 0x5c, 0xd7, 0x4d, 0x9a, 0xa0, 0x9d, 0xc6, 0xb4, 0x53, 0x52,
	0x3d, 0x13, 0xb2, 0x6a, 0xda, 0xf1, 0x98, 0xc4, 0xb0, 0xb7, 0x42, 0xa9, 0x98, 0xa8, 0x4b, 0xd7,
	0xd0, 0x44, 0xb9, 0xac, 0x93, 0xc2, 0x96, 0x0e, 0xd3, 0x06, 0x1b, 0x5b, 0x81, 0x2b, 0x96, 0xe3,
	0xa4, 0xf0, 0x12, 0x37, 0xd8, 0x64, 0xcc, 0x6f, 0x28, 0xe7, 0x58, 0xc6, 0xbb, 0x2e, 0xa3, 0x87,
	0x64, 0x04, 0xbb, 0x46, 0xe2, 0x49, 0x11, 0xef, 0xd9, 0x7c, 0x1e, 0x91, 0x01, 0x74, 0xd8, 0x22,
	0xde, 0xb7, 0xce, 0x1d, 0xb6, 0x30, 0xd9, 0x19, 0x5f, 0x31, 0x8d, 0x93, 0xeb, 0x18, 0x5c, 0xe5,
	0x1a, 0x93, 0x4f, 0x00, 0xdc, 0xf9, 0xd5, 0x7a, 0x81, 0x71, 0xff, 0x2c, 0x38, 0xef, 0x5f, 0x9d,
	0xdc, 0xcb, 0xed, 0x6c, 0x99, 0x5e, 0x2f, 0x30, 0x6d, 0x39, 0x26, 0x3f, 0xd6, 0x8f, 0xa6, 0x70,
	0xe5, 0x87, 0xf3, 0x12, 0x7a, 0x52, 0x94, 0x38, 0xe1, 0x33, 0x61, 0xe5, 0xea, 0x5f, 0x1d, 0xb7,
	0xc6, 0x53, 0x94, 0x98, 0x31, 0x3e, 0x13, 0x69, 0xe3, 0xd4, 0xa2, 0xdf, 0xd9, 0xa0, 0x3f, 0x06,
	0x70, 0xc2, 0xbc, 0x62, 0x15, 0x5a, 0x15, 0xbb, 0x69, 0xeb, 0x26, 0xf9, 0x35, 0x80, 0x43, 0x2f,
	0x81, 0x9f, 0xbd, 0x96, 0x44, 0xc1, 0xa6, 0x44, 0x63, 0x00, 0x7f, 0x7c, 0x3d, 0xb9, 0xf6, 0x8f,
	0xd5, 0xba, 0x31, 0x1c, 0xc4, 0x02, 0xf9, 0xe4, 0xda, 0xbf, 0x96, 0x47, 0x46, 0x32, 0xce, 0xf2,
	0x37, 0x76, 0x9a, 0xdd, 0x9c, 0x34, 0xd8, 0xc4, 0xd0, 0x15, 0xd5, 0x54, 0xfa, 0xa7, 0xf2, 0x28,
	0xf9, 0x29, 0x80, 0xe1, 0x06, 0x2f, 0x2b, 0xcb, 0x68, 0x63, 0x96, 0xc3, 0x7f, 0x3d, 0xb3, 0x11,
	0x74, 0x39, 0xde, 0x5a, 0x12, 0xbd, 0xd4, 0x1c, 0x1f, 0x4c, 0x71, 0xb8, 0x35, 0xc5, 0x9f, 0x3a,
	0x1a, 0x73, 0xcc, 0x8c, 0xa0, 0x99, 0xd2, 0x54, 0x63, 0x5d, 0x2e, 0xd8, 0x28, 0x67, 0x4d, 0x9e,
	0x82, 0x03, 0xc9, 0x25, 0x9c, 0x6c, 0x05, 0x3f, 0xd2, 0x47, 0xaf, 0xee, 0x23, 0xf9, 0x00, 0xde,
	0xd5, 0x92, 0x72, 0x35, 0xb3, 0x63, 0x50, 0x09, 0x5d, 0x47, 0xa2, 0xb2, 0x63, 0xbf, 0x55, 0x38,
	0xf9, 0x0c, 0xce, 0x9e, 0x8a, 0xb0, 0xd5, 0x62, 0xd8, 0xf3, 0xd0, 0x46, 0x1e, 0xa4, 0x35, 0x4c,
	0x62, 0x18, 0x49, 0x9c, 0x49, 0x54, 0x37, 0x59, 0x5e, 0x32, 0xe4, 0x3a, 0xf3, 0x3f, 0xb0, 0xe4,
	0x63, 0x38, 0x7d, 0xdc, 0xf2, 0x24, 0xff, 0xef, 0x60, 0x78, 0x8b, 0xf9, 0x0d, 0xd5, 0x19, 0xae,
	0x4c, 0xcc, 0x62, 0xa9, 0x6e, 0x1e, 0x57, 0xcb, 0xda, 0xfd, 0x0c, 0x39, 0x60, 0x6e, 0x0b, 0x2c,
	0xe9, 0xda, 0x3e, 0x59, 0x98, 0x3a, 0x90, 0xbc, 0x07, 0x24, 0x2f, 0x91, 0xf2, 0x4c, 0xa3, 0xd2,
	0x19, 0xcd, 0x73, 0xb1, 0xe4, 0xfa, 0x11, 0x21, 0xbe, 0x82, 0xd1, 0xb6, 0xdf, 0x53, 0x64, 0x8d,
	0x2c, 0x15, 0x2a, 0x45, 0xe7, 0xe8, 0x79, 0xd4, 0x30, 0xb9, 0x84, 0xe1, 0xf7, 0x4b, 0x94, 0xeb,
	0x6c, 0xba, 0xce, 0xda, 0x7b, 0xf7, 0x9f, 0x76, 0x72, 0xf2, 0x3e, 0x9c, 0x6c, 0x05, 0xd8, 0xda,
	0x04, 0x76, 0x96, 0xac, 0x50, 0x71, 0x70, 0xd6, 0x3d, 0x0f, 0x53, 0x7b, 0x7e, 0xf6, 0x4b, 0x50,
	0x2f, 0x46, 0xb7, 0x79, 0xc9, 0x3e, 0x84, 0x25, 0x17, 0x1c, 0xa3, 0xb7, 0x48, 0xe4, 0x4d, 0x2f,
	0x97, 0x79, 0x8e, 0x4a, 0x45, 0x01, 0x39, 0x82, 0x3e, 0xe3, 0x2b, 0x5a, 0xb2, 0xe2, 0xb5, 0x42,
	0x19, 0x75, 0xc8, 0xc0, 0x2e, 0x19, 0x73, 0xf1, 0xed, 0x6d, 0x11, 0x75, 0xc9, 0x10, 0x0e, 0x67,
	0x42, 0x4e, 0x59, 0x51, 0x20, 0xb7, 0x2e, 0x3b, 0xe4, 0x18, 0x8e, 0xbc, 0xcb, 0x37, 0x94, 0x71,
	0x4d, 0x19, 0x8f, 0x42, 0x72, 0x02, 0x43, 0x7f, 0xf9, 0x45, 0x33, 0xde, 0xd1, 0xee, 0xb3, 0x39,
	0x1c, 0x3d, 0xf8, 0xbb, 0x33, 0x7c, 0xa4, 0xe7, 0x73, 0x7c, 0x6f, 0xbd, 0xa7, 0x34, 0x00, 0x30,
	0x4d, 0x3e, 0xff, 0x81, 0x29, 0xad, 0xa2, 0x8e, 0x61, 0xe0, 0x33, 0xbf, 0x10, 0xb2, 0xa2, 0xda,
	0x91, 0xf2, 0x57, 0x4d, 0xa1, 0x17, 0x70, 0xe8, 0xf6, 0x4e, 0xab, 0x8c, 0xf2, 0x65, 0xfa, 0xb0,
	0xa7, 0xda, 0x1d, 0x57, 0x86, 0x36, 0x72, 0xca, 0x73, 0x8c, 0x3a, 0xe4, 0x00, 0x7a, 0x5c, 0xe8,
	0xaf, 0x8d, 0x2e, 0x51, 0xf7, 0xf3, 0x83, 0x3f, 0xee, 0xc6, 0xc1, 0x9f, 0x77, 0xe3, 0xe0, 0xaf,
	0xbb, 0x71, 0x30, 0xdd, 0xb5, 0x5b, 0xf1, 0xa3, 0xbf, 0x03, 0x00, 0x00, 0xff, 0xff, 0x70, 0x57,
	0x38, 0x10, 0x58, 0x08, 0x00, 0x00,
}
