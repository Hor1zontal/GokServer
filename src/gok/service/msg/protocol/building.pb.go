// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: building.proto

package protocol

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// 建筑销毁
type BuildingReset struct {
	Building   []*BuildingInfo `protobuf:"bytes,1,rep,name=building" json:"building,omitempty"`
	ItemID     []int32         `protobuf:"varint,2,rep,packed,name=itemID" json:"itemID,omitempty"`
	PowerLimit int32           `protobuf:"varint,3,opt,name=powerLimit,proto3" json:"powerLimit,omitempty"`
}

func (m *BuildingReset) Reset()                    { *m = BuildingReset{} }
func (m *BuildingReset) String() string            { return proto.CompactTextString(m) }
func (*BuildingReset) ProtoMessage()               {}
func (*BuildingReset) Descriptor() ([]byte, []int) { return fileDescriptorBuilding, []int{0} }

func (m *BuildingReset) GetBuilding() []*BuildingInfo {
	if m != nil {
		return m.Building
	}
	return nil
}

func (m *BuildingReset) GetItemID() []int32 {
	if m != nil {
		return m.ItemID
	}
	return nil
}

func (m *BuildingReset) GetPowerLimit() int32 {
	if m != nil {
		return m.PowerLimit
	}
	return 0
}

// 建造建筑
type BuildStarBuilding struct {
	StarID       int32    `protobuf:"varint,1,opt,name=starID,proto3" json:"starID,omitempty"`
	BuildingType int32    `protobuf:"varint,2,opt,name=buildingType,proto3" json:"buildingType,omitempty"`
	Level        int32    `protobuf:"varint,3,opt,name=level,proto3" json:"level,omitempty"`
	BelieverId   []string `protobuf:"bytes,4,rep,name=believerId" json:"believerId,omitempty"`
	Faith        int32    `protobuf:"varint,5,opt,name=faith,proto3" json:"faith,omitempty"`
	Guide        bool     `protobuf:"varint,6,opt,name=guide,proto3" json:"guide,omitempty"`
}

func (m *BuildStarBuilding) Reset()                    { *m = BuildStarBuilding{} }
func (m *BuildStarBuilding) String() string            { return proto.CompactTextString(m) }
func (*BuildStarBuilding) ProtoMessage()               {}
func (*BuildStarBuilding) Descriptor() ([]byte, []int) { return fileDescriptorBuilding, []int{1} }

func (m *BuildStarBuilding) GetStarID() int32 {
	if m != nil {
		return m.StarID
	}
	return 0
}

func (m *BuildStarBuilding) GetBuildingType() int32 {
	if m != nil {
		return m.BuildingType
	}
	return 0
}

func (m *BuildStarBuilding) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *BuildStarBuilding) GetBelieverId() []string {
	if m != nil {
		return m.BelieverId
	}
	return nil
}

func (m *BuildStarBuilding) GetFaith() int32 {
	if m != nil {
		return m.Faith
	}
	return 0
}

func (m *BuildStarBuilding) GetGuide() bool {
	if m != nil {
		return m.Guide
	}
	return false
}

// 建造建筑结果
type BuildStarBuildingRet struct {
	Result           bool              `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
	UpdateTime       int64             `protobuf:"varint,2,opt,name=updateTime,proto3" json:"updateTime,omitempty"`
	Builidng         *BuildingInfo     `protobuf:"bytes,3,opt,name=builidng" json:"builidng,omitempty"`
	PowerLimit       int32             `protobuf:"varint,4,opt,name=powerLimit,proto3" json:"powerLimit,omitempty"`
	Cost             int32             `protobuf:"varint,5,opt,name=cost,proto3" json:"cost,omitempty"`
	Done             bool              `protobuf:"varint,6,opt,name=done,proto3" json:"done,omitempty"`
	CivilizationInfo *CivilizationInfo `protobuf:"bytes,7,opt,name=civilizationInfo" json:"civilizationInfo,omitempty"`
	ItemID           int32             `protobuf:"varint,8,opt,name=itemID,proto3" json:"itemID,omitempty"`
}

func (m *BuildStarBuildingRet) Reset()                    { *m = BuildStarBuildingRet{} }
func (m *BuildStarBuildingRet) String() string            { return proto.CompactTextString(m) }
func (*BuildStarBuildingRet) ProtoMessage()               {}
func (*BuildStarBuildingRet) Descriptor() ([]byte, []int) { return fileDescriptorBuilding, []int{2} }

func (m *BuildStarBuildingRet) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func (m *BuildStarBuildingRet) GetUpdateTime() int64 {
	if m != nil {
		return m.UpdateTime
	}
	return 0
}

func (m *BuildStarBuildingRet) GetBuilidng() *BuildingInfo {
	if m != nil {
		return m.Builidng
	}
	return nil
}

func (m *BuildStarBuildingRet) GetPowerLimit() int32 {
	if m != nil {
		return m.PowerLimit
	}
	return 0
}

func (m *BuildStarBuildingRet) GetCost() int32 {
	if m != nil {
		return m.Cost
	}
	return 0
}

func (m *BuildStarBuildingRet) GetDone() bool {
	if m != nil {
		return m.Done
	}
	return false
}

func (m *BuildStarBuildingRet) GetCivilizationInfo() *CivilizationInfo {
	if m != nil {
		return m.CivilizationInfo
	}
	return nil
}

func (m *BuildStarBuildingRet) GetItemID() int32 {
	if m != nil {
		return m.ItemID
	}
	return 0
}

// 加速修理星球建筑
type AccRepairStarBuild struct {
	Uid          int32    `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
	BuildingType int32    `protobuf:"varint,2,opt,name=buildingType,proto3" json:"buildingType,omitempty"`
	BelieverId   []string `protobuf:"bytes,3,rep,name=believerId" json:"believerId,omitempty"`
}

func (m *AccRepairStarBuild) Reset()                    { *m = AccRepairStarBuild{} }
func (m *AccRepairStarBuild) String() string            { return proto.CompactTextString(m) }
func (*AccRepairStarBuild) ProtoMessage()               {}
func (*AccRepairStarBuild) Descriptor() ([]byte, []int) { return fileDescriptorBuilding, []int{3} }

func (m *AccRepairStarBuild) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *AccRepairStarBuild) GetBuildingType() int32 {
	if m != nil {
		return m.BuildingType
	}
	return 0
}

func (m *AccRepairStarBuild) GetBelieverId() []string {
	if m != nil {
		return m.BelieverId
	}
	return nil
}

type AccRepairStarBuildRet struct {
	Uid              int32             `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
	BuildingType     int32             `protobuf:"varint,2,opt,name=buildingType,proto3" json:"buildingType,omitempty"`
	RepairTime       int64             `protobuf:"varint,3,opt,name=repairTime,proto3" json:"repairTime,omitempty"`
	BelieverNum      int32             `protobuf:"varint,4,opt,name=believerNum,proto3" json:"believerNum,omitempty"`
	Done             bool              `protobuf:"varint,5,opt,name=done,proto3" json:"done,omitempty"`
	BuildingLevel    int32             `protobuf:"varint,6,opt,name=buildingLevel,proto3" json:"buildingLevel,omitempty"`
	CivilizationInfo *CivilizationInfo `protobuf:"bytes,7,opt,name=civilizationInfo" json:"civilizationInfo,omitempty"`
	ItemID           int32             `protobuf:"varint,8,opt,name=itemID,proto3" json:"itemID,omitempty"`
}

func (m *AccRepairStarBuildRet) Reset()                    { *m = AccRepairStarBuildRet{} }
func (m *AccRepairStarBuildRet) String() string            { return proto.CompactTextString(m) }
func (*AccRepairStarBuildRet) ProtoMessage()               {}
func (*AccRepairStarBuildRet) Descriptor() ([]byte, []int) { return fileDescriptorBuilding, []int{4} }

func (m *AccRepairStarBuildRet) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *AccRepairStarBuildRet) GetBuildingType() int32 {
	if m != nil {
		return m.BuildingType
	}
	return 0
}

func (m *AccRepairStarBuildRet) GetRepairTime() int64 {
	if m != nil {
		return m.RepairTime
	}
	return 0
}

func (m *AccRepairStarBuildRet) GetBelieverNum() int32 {
	if m != nil {
		return m.BelieverNum
	}
	return 0
}

func (m *AccRepairStarBuildRet) GetDone() bool {
	if m != nil {
		return m.Done
	}
	return false
}

func (m *AccRepairStarBuildRet) GetBuildingLevel() int32 {
	if m != nil {
		return m.BuildingLevel
	}
	return 0
}

func (m *AccRepairStarBuildRet) GetCivilizationInfo() *CivilizationInfo {
	if m != nil {
		return m.CivilizationInfo
	}
	return nil
}

func (m *AccRepairStarBuildRet) GetItemID() int32 {
	if m != nil {
		return m.ItemID
	}
	return 0
}

// 请求开始维护星球建筑
type RepairStarBuild struct {
	Uid          int32    `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
	Faith        int32    `protobuf:"varint,2,opt,name=faith,proto3" json:"faith,omitempty"`
	BuildingType int32    `protobuf:"varint,3,opt,name=buildingType,proto3" json:"buildingType,omitempty"`
	BelieverId   []string `protobuf:"bytes,4,rep,name=believerId" json:"believerId,omitempty"`
}

func (m *RepairStarBuild) Reset()                    { *m = RepairStarBuild{} }
func (m *RepairStarBuild) String() string            { return proto.CompactTextString(m) }
func (*RepairStarBuild) ProtoMessage()               {}
func (*RepairStarBuild) Descriptor() ([]byte, []int) { return fileDescriptorBuilding, []int{5} }

func (m *RepairStarBuild) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *RepairStarBuild) GetFaith() int32 {
	if m != nil {
		return m.Faith
	}
	return 0
}

func (m *RepairStarBuild) GetBuildingType() int32 {
	if m != nil {
		return m.BuildingType
	}
	return 0
}

func (m *RepairStarBuild) GetBelieverId() []string {
	if m != nil {
		return m.BelieverId
	}
	return nil
}

type RepairStarBuildRet struct {
	Uid              int32             `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
	Cost             int32             `protobuf:"varint,2,opt,name=cost,proto3" json:"cost,omitempty"`
	BuildingType     int32             `protobuf:"varint,3,opt,name=buildingType,proto3" json:"buildingType,omitempty"`
	RepairTime       int64             `protobuf:"varint,4,opt,name=repairTime,proto3" json:"repairTime,omitempty"`
	Done             bool              `protobuf:"varint,5,opt,name=done,proto3" json:"done,omitempty"`
	BuildingLevel    int32             `protobuf:"varint,6,opt,name=buildingLevel,proto3" json:"buildingLevel,omitempty"`
	CivilizationInfo *CivilizationInfo `protobuf:"bytes,7,opt,name=civilizationInfo" json:"civilizationInfo,omitempty"`
	ItemID           int32             `protobuf:"varint,8,opt,name=itemID,proto3" json:"itemID,omitempty"`
}

func (m *RepairStarBuildRet) Reset()                    { *m = RepairStarBuildRet{} }
func (m *RepairStarBuildRet) String() string            { return proto.CompactTextString(m) }
func (*RepairStarBuildRet) ProtoMessage()               {}
func (*RepairStarBuildRet) Descriptor() ([]byte, []int) { return fileDescriptorBuilding, []int{6} }

func (m *RepairStarBuildRet) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *RepairStarBuildRet) GetCost() int32 {
	if m != nil {
		return m.Cost
	}
	return 0
}

func (m *RepairStarBuildRet) GetBuildingType() int32 {
	if m != nil {
		return m.BuildingType
	}
	return 0
}

func (m *RepairStarBuildRet) GetRepairTime() int64 {
	if m != nil {
		return m.RepairTime
	}
	return 0
}

func (m *RepairStarBuildRet) GetDone() bool {
	if m != nil {
		return m.Done
	}
	return false
}

func (m *RepairStarBuildRet) GetBuildingLevel() int32 {
	if m != nil {
		return m.BuildingLevel
	}
	return 0
}

func (m *RepairStarBuildRet) GetCivilizationInfo() *CivilizationInfo {
	if m != nil {
		return m.CivilizationInfo
	}
	return nil
}

func (m *RepairStarBuildRet) GetItemID() int32 {
	if m != nil {
		return m.ItemID
	}
	return 0
}

// 请求星球建筑修理完毕
type RepairStarBuildEnd struct {
	Uid          int32 `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
	BuildingType int32 `protobuf:"varint,2,opt,name=buildingType,proto3" json:"buildingType,omitempty"`
}

func (m *RepairStarBuildEnd) Reset()                    { *m = RepairStarBuildEnd{} }
func (m *RepairStarBuildEnd) String() string            { return proto.CompactTextString(m) }
func (*RepairStarBuildEnd) ProtoMessage()               {}
func (*RepairStarBuildEnd) Descriptor() ([]byte, []int) { return fileDescriptorBuilding, []int{7} }

func (m *RepairStarBuildEnd) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *RepairStarBuildEnd) GetBuildingType() int32 {
	if m != nil {
		return m.BuildingType
	}
	return 0
}

// 请求星球建筑修理完毕
type RepairStarBuildEndRet struct {
	Done             bool              `protobuf:"varint,1,opt,name=done,proto3" json:"done,omitempty"`
	RepairTime       int64             `protobuf:"varint,2,opt,name=repairTime,proto3" json:"repairTime,omitempty"`
	BuildingLevel    int32             `protobuf:"varint,6,opt,name=buildingLevel,proto3" json:"buildingLevel,omitempty"`
	CivilizationInfo *CivilizationInfo `protobuf:"bytes,7,opt,name=civilizationInfo" json:"civilizationInfo,omitempty"`
	ItemID           int32             `protobuf:"varint,8,opt,name=itemID,proto3" json:"itemID,omitempty"`
}

func (m *RepairStarBuildEndRet) Reset()                    { *m = RepairStarBuildEndRet{} }
func (m *RepairStarBuildEndRet) String() string            { return proto.CompactTextString(m) }
func (*RepairStarBuildEndRet) ProtoMessage()               {}
func (*RepairStarBuildEndRet) Descriptor() ([]byte, []int) { return fileDescriptorBuilding, []int{8} }

func (m *RepairStarBuildEndRet) GetDone() bool {
	if m != nil {
		return m.Done
	}
	return false
}

func (m *RepairStarBuildEndRet) GetRepairTime() int64 {
	if m != nil {
		return m.RepairTime
	}
	return 0
}

func (m *RepairStarBuildEndRet) GetBuildingLevel() int32 {
	if m != nil {
		return m.BuildingLevel
	}
	return 0
}

func (m *RepairStarBuildEndRet) GetCivilizationInfo() *CivilizationInfo {
	if m != nil {
		return m.CivilizationInfo
	}
	return nil
}

func (m *RepairStarBuildEndRet) GetItemID() int32 {
	if m != nil {
		return m.ItemID
	}
	return 0
}

// 请求升级星球建筑结束
type UpdateStarBuildEnd struct {
	Uid          int32 `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
	BuildingType int32 `protobuf:"varint,2,opt,name=buildingType,proto3" json:"buildingType,omitempty"`
}

func (m *UpdateStarBuildEnd) Reset()                    { *m = UpdateStarBuildEnd{} }
func (m *UpdateStarBuildEnd) String() string            { return proto.CompactTextString(m) }
func (*UpdateStarBuildEnd) ProtoMessage()               {}
func (*UpdateStarBuildEnd) Descriptor() ([]byte, []int) { return fileDescriptorBuilding, []int{9} }

func (m *UpdateStarBuildEnd) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *UpdateStarBuildEnd) GetBuildingType() int32 {
	if m != nil {
		return m.BuildingType
	}
	return 0
}

// 请求升级星球建筑结束
type UpdateStarBuildEndRet struct {
	Uid          int32 `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
	BuildingType int32 `protobuf:"varint,2,opt,name=buildingType,proto3" json:"buildingType,omitempty"`
	Level        int32 `protobuf:"varint,3,opt,name=level,proto3" json:"level,omitempty"`
	UpdateTime   int64 `protobuf:"varint,4,opt,name=updateTime,proto3" json:"updateTime,omitempty"`
	PowerLimit   int32 `protobuf:"varint,5,opt,name=powerLimit,proto3" json:"powerLimit,omitempty"`
	// repeated item_groove itemGroove = 6; //有更新的物品槽
	Done             bool              `protobuf:"varint,7,opt,name=done,proto3" json:"done,omitempty"`
	CivilizationInfo *CivilizationInfo `protobuf:"bytes,8,opt,name=civilizationInfo" json:"civilizationInfo,omitempty"`
	ItemID           int32             `protobuf:"varint,9,opt,name=itemID,proto3" json:"itemID,omitempty"`
	PowerReward      int32             `protobuf:"varint,10,opt,name=powerReward,proto3" json:"powerReward,omitempty"`
}

func (m *UpdateStarBuildEndRet) Reset()                    { *m = UpdateStarBuildEndRet{} }
func (m *UpdateStarBuildEndRet) String() string            { return proto.CompactTextString(m) }
func (*UpdateStarBuildEndRet) ProtoMessage()               {}
func (*UpdateStarBuildEndRet) Descriptor() ([]byte, []int) { return fileDescriptorBuilding, []int{10} }

func (m *UpdateStarBuildEndRet) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *UpdateStarBuildEndRet) GetBuildingType() int32 {
	if m != nil {
		return m.BuildingType
	}
	return 0
}

func (m *UpdateStarBuildEndRet) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *UpdateStarBuildEndRet) GetUpdateTime() int64 {
	if m != nil {
		return m.UpdateTime
	}
	return 0
}

func (m *UpdateStarBuildEndRet) GetPowerLimit() int32 {
	if m != nil {
		return m.PowerLimit
	}
	return 0
}

func (m *UpdateStarBuildEndRet) GetDone() bool {
	if m != nil {
		return m.Done
	}
	return false
}

func (m *UpdateStarBuildEndRet) GetCivilizationInfo() *CivilizationInfo {
	if m != nil {
		return m.CivilizationInfo
	}
	return nil
}

func (m *UpdateStarBuildEndRet) GetItemID() int32 {
	if m != nil {
		return m.ItemID
	}
	return 0
}

func (m *UpdateStarBuildEndRet) GetPowerReward() int32 {
	if m != nil {
		return m.PowerReward
	}
	return 0
}

// 请求升级星球建筑加速
type AccUpdateStarBuild struct {
	Uid          int32    `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
	BuildingType int32    `protobuf:"varint,2,opt,name=buildingType,proto3" json:"buildingType,omitempty"`
	BelieverId   []string `protobuf:"bytes,3,rep,name=believerId" json:"believerId,omitempty"`
	Guide        bool     `protobuf:"varint,4,opt,name=guide,proto3" json:"guide,omitempty"`
}

func (m *AccUpdateStarBuild) Reset()                    { *m = AccUpdateStarBuild{} }
func (m *AccUpdateStarBuild) String() string            { return proto.CompactTextString(m) }
func (*AccUpdateStarBuild) ProtoMessage()               {}
func (*AccUpdateStarBuild) Descriptor() ([]byte, []int) { return fileDescriptorBuilding, []int{11} }

func (m *AccUpdateStarBuild) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *AccUpdateStarBuild) GetBuildingType() int32 {
	if m != nil {
		return m.BuildingType
	}
	return 0
}

func (m *AccUpdateStarBuild) GetBelieverId() []string {
	if m != nil {
		return m.BelieverId
	}
	return nil
}

func (m *AccUpdateStarBuild) GetGuide() bool {
	if m != nil {
		return m.Guide
	}
	return false
}

// 请求升级星球建筑加速
type AccUpdateStarBuildRet struct {
	Uid          int32 `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
	BuildingType int32 `protobuf:"varint,2,opt,name=buildingType,proto3" json:"buildingType,omitempty"`
	Level        int32 `protobuf:"varint,3,opt,name=level,proto3" json:"level,omitempty"`
	PowerLimit   int32 `protobuf:"varint,4,opt,name=powerLimit,proto3" json:"powerLimit,omitempty"`
	UpdateTime   int64 `protobuf:"varint,5,opt,name=updateTime,proto3" json:"updateTime,omitempty"`
	BelieverNum  int32 `protobuf:"varint,6,opt,name=believerNum,proto3" json:"believerNum,omitempty"`
	// repeated item_groove itemGroove = 7; //有更新的物品槽
	Done             bool              `protobuf:"varint,8,opt,name=done,proto3" json:"done,omitempty"`
	CivilizationInfo *CivilizationInfo `protobuf:"bytes,9,opt,name=civilizationInfo" json:"civilizationInfo,omitempty"`
	ItemID           int32             `protobuf:"varint,10,opt,name=itemID,proto3" json:"itemID,omitempty"`
}

func (m *AccUpdateStarBuildRet) Reset()                    { *m = AccUpdateStarBuildRet{} }
func (m *AccUpdateStarBuildRet) String() string            { return proto.CompactTextString(m) }
func (*AccUpdateStarBuildRet) ProtoMessage()               {}
func (*AccUpdateStarBuildRet) Descriptor() ([]byte, []int) { return fileDescriptorBuilding, []int{12} }

func (m *AccUpdateStarBuildRet) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *AccUpdateStarBuildRet) GetBuildingType() int32 {
	if m != nil {
		return m.BuildingType
	}
	return 0
}

func (m *AccUpdateStarBuildRet) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *AccUpdateStarBuildRet) GetPowerLimit() int32 {
	if m != nil {
		return m.PowerLimit
	}
	return 0
}

func (m *AccUpdateStarBuildRet) GetUpdateTime() int64 {
	if m != nil {
		return m.UpdateTime
	}
	return 0
}

func (m *AccUpdateStarBuildRet) GetBelieverNum() int32 {
	if m != nil {
		return m.BelieverNum
	}
	return 0
}

func (m *AccUpdateStarBuildRet) GetDone() bool {
	if m != nil {
		return m.Done
	}
	return false
}

func (m *AccUpdateStarBuildRet) GetCivilizationInfo() *CivilizationInfo {
	if m != nil {
		return m.CivilizationInfo
	}
	return nil
}

func (m *AccUpdateStarBuildRet) GetItemID() int32 {
	if m != nil {
		return m.ItemID
	}
	return 0
}

// 请求取消星球建筑升级
type CancelUpgradeStarBuild struct {
	BuildingType int32 `protobuf:"varint,1,opt,name=buildingType,proto3" json:"buildingType,omitempty"`
}

func (m *CancelUpgradeStarBuild) Reset()                    { *m = CancelUpgradeStarBuild{} }
func (m *CancelUpgradeStarBuild) String() string            { return proto.CompactTextString(m) }
func (*CancelUpgradeStarBuild) ProtoMessage()               {}
func (*CancelUpgradeStarBuild) Descriptor() ([]byte, []int) { return fileDescriptorBuilding, []int{13} }

func (m *CancelUpgradeStarBuild) GetBuildingType() int32 {
	if m != nil {
		return m.BuildingType
	}
	return 0
}

type CancelUpgradeStarBuildRet struct {
	BackFaith     int32 `protobuf:"varint,1,opt,name=backFaith,proto3" json:"backFaith,omitempty"`
	BuildingType  int32 `protobuf:"varint,2,opt,name=buildingType,proto3" json:"buildingType,omitempty"`
	BuildingLevel int32 `protobuf:"varint,3,opt,name=buildingLevel,proto3" json:"buildingLevel,omitempty"`
	UpdateTime    int64 `protobuf:"varint,4,opt,name=updateTime,proto3" json:"updateTime,omitempty"`
}

func (m *CancelUpgradeStarBuildRet) Reset()         { *m = CancelUpgradeStarBuildRet{} }
func (m *CancelUpgradeStarBuildRet) String() string { return proto.CompactTextString(m) }
func (*CancelUpgradeStarBuildRet) ProtoMessage()    {}
func (*CancelUpgradeStarBuildRet) Descriptor() ([]byte, []int) {
	return fileDescriptorBuilding, []int{14}
}

func (m *CancelUpgradeStarBuildRet) GetBackFaith() int32 {
	if m != nil {
		return m.BackFaith
	}
	return 0
}

func (m *CancelUpgradeStarBuildRet) GetBuildingType() int32 {
	if m != nil {
		return m.BuildingType
	}
	return 0
}

func (m *CancelUpgradeStarBuildRet) GetBuildingLevel() int32 {
	if m != nil {
		return m.BuildingLevel
	}
	return 0
}

func (m *CancelUpgradeStarBuildRet) GetUpdateTime() int64 {
	if m != nil {
		return m.UpdateTime
	}
	return 0
}

// 请求取消星球建筑修理
type CancelRepairStarBuild struct {
	BuildingType int32 `protobuf:"varint,1,opt,name=buildingType,proto3" json:"buildingType,omitempty"`
}

func (m *CancelRepairStarBuild) Reset()                    { *m = CancelRepairStarBuild{} }
func (m *CancelRepairStarBuild) String() string            { return proto.CompactTextString(m) }
func (*CancelRepairStarBuild) ProtoMessage()               {}
func (*CancelRepairStarBuild) Descriptor() ([]byte, []int) { return fileDescriptorBuilding, []int{15} }

func (m *CancelRepairStarBuild) GetBuildingType() int32 {
	if m != nil {
		return m.BuildingType
	}
	return 0
}

type CancelRepairStarBuildRet struct {
	BackFaith     int32 `protobuf:"varint,1,opt,name=backFaith,proto3" json:"backFaith,omitempty"`
	BuildingType  int32 `protobuf:"varint,2,opt,name=buildingType,proto3" json:"buildingType,omitempty"`
	BuildingLevel int32 `protobuf:"varint,3,opt,name=buildingLevel,proto3" json:"buildingLevel,omitempty"`
	RepairTime    int64 `protobuf:"varint,4,opt,name=repairTime,proto3" json:"repairTime,omitempty"`
	BrokenTime    int64 `protobuf:"varint,5,opt,name=brokenTime,proto3" json:"brokenTime,omitempty"`
}

func (m *CancelRepairStarBuildRet) Reset()         { *m = CancelRepairStarBuildRet{} }
func (m *CancelRepairStarBuildRet) String() string { return proto.CompactTextString(m) }
func (*CancelRepairStarBuildRet) ProtoMessage()    {}
func (*CancelRepairStarBuildRet) Descriptor() ([]byte, []int) {
	return fileDescriptorBuilding, []int{16}
}

func (m *CancelRepairStarBuildRet) GetBackFaith() int32 {
	if m != nil {
		return m.BackFaith
	}
	return 0
}

func (m *CancelRepairStarBuildRet) GetBuildingType() int32 {
	if m != nil {
		return m.BuildingType
	}
	return 0
}

func (m *CancelRepairStarBuildRet) GetBuildingLevel() int32 {
	if m != nil {
		return m.BuildingLevel
	}
	return 0
}

func (m *CancelRepairStarBuildRet) GetRepairTime() int64 {
	if m != nil {
		return m.RepairTime
	}
	return 0
}

func (m *CancelRepairStarBuildRet) GetBrokenTime() int64 {
	if m != nil {
		return m.BrokenTime
	}
	return 0
}

// 星球建筑信息变更推送
type BuildingInfoPush struct {
	Uid      int32           `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
	StarID   int32           `protobuf:"varint,2,opt,name=starID,proto3" json:"starID,omitempty"`
	Type     int32           `protobuf:"varint,3,opt,name=type,proto3" json:"type,omitempty"`
	Building []*BuildingInfo `protobuf:"bytes,4,rep,name=building" json:"building,omitempty"`
}

func (m *BuildingInfoPush) Reset()                    { *m = BuildingInfoPush{} }
func (m *BuildingInfoPush) String() string            { return proto.CompactTextString(m) }
func (*BuildingInfoPush) ProtoMessage()               {}
func (*BuildingInfoPush) Descriptor() ([]byte, []int) { return fileDescriptorBuilding, []int{17} }

func (m *BuildingInfoPush) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *BuildingInfoPush) GetStarID() int32 {
	if m != nil {
		return m.StarID
	}
	return 0
}

func (m *BuildingInfoPush) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *BuildingInfoPush) GetBuilding() []*BuildingInfo {
	if m != nil {
		return m.Building
	}
	return nil
}

// 获取星球建筑当前存储的信仰值
type GetBuildingFaith struct {
	Uid          int32 `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
	BuildingType int32 `protobuf:"varint,2,opt,name=buildingType,proto3" json:"buildingType,omitempty"`
}

func (m *GetBuildingFaith) Reset()                    { *m = GetBuildingFaith{} }
func (m *GetBuildingFaith) String() string            { return proto.CompactTextString(m) }
func (*GetBuildingFaith) ProtoMessage()               {}
func (*GetBuildingFaith) Descriptor() ([]byte, []int) { return fileDescriptorBuilding, []int{18} }

func (m *GetBuildingFaith) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *GetBuildingFaith) GetBuildingType() int32 {
	if m != nil {
		return m.BuildingType
	}
	return 0
}

// 获取星球建筑当前存储的信仰值
type GetBuildingFaithRet struct {
	Uid            int32            `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
	BuildingsFaith []*BuildingFaith `protobuf:"bytes,2,rep,name=buildingsFaith" json:"buildingsFaith,omitempty"`
}

func (m *GetBuildingFaithRet) Reset()                    { *m = GetBuildingFaithRet{} }
func (m *GetBuildingFaithRet) String() string            { return proto.CompactTextString(m) }
func (*GetBuildingFaithRet) ProtoMessage()               {}
func (*GetBuildingFaithRet) Descriptor() ([]byte, []int) { return fileDescriptorBuilding, []int{19} }

func (m *GetBuildingFaithRet) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *GetBuildingFaithRet) GetBuildingsFaith() []*BuildingFaith {
	if m != nil {
		return m.BuildingsFaith
	}
	return nil
}

// 领取星球建筑当前存储的信仰值
type ReceiveBuildingFaith struct {
	Uid          int32 `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
	BuildingType int32 `protobuf:"varint,2,opt,name=buildingType,proto3" json:"buildingType,omitempty"`
}

func (m *ReceiveBuildingFaith) Reset()                    { *m = ReceiveBuildingFaith{} }
func (m *ReceiveBuildingFaith) String() string            { return proto.CompactTextString(m) }
func (*ReceiveBuildingFaith) ProtoMessage()               {}
func (*ReceiveBuildingFaith) Descriptor() ([]byte, []int) { return fileDescriptorBuilding, []int{20} }

func (m *ReceiveBuildingFaith) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *ReceiveBuildingFaith) GetBuildingType() int32 {
	if m != nil {
		return m.BuildingType
	}
	return 0
}

// 领取星球建筑当前存储的信仰值
type ReceiveBuildingFaithRet struct {
	Result          bool  `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
	BuildingFaith   int32 `protobuf:"varint,2,opt,name=buildingFaith,proto3" json:"buildingFaith,omitempty"`
	FaithUpdateTime int64 `protobuf:"varint,4,opt,name=faithUpdateTime,proto3" json:"faithUpdateTime,omitempty"`
}

func (m *ReceiveBuildingFaithRet) Reset()                    { *m = ReceiveBuildingFaithRet{} }
func (m *ReceiveBuildingFaithRet) String() string            { return proto.CompactTextString(m) }
func (*ReceiveBuildingFaithRet) ProtoMessage()               {}
func (*ReceiveBuildingFaithRet) Descriptor() ([]byte, []int) { return fileDescriptorBuilding, []int{21} }

func (m *ReceiveBuildingFaithRet) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func (m *ReceiveBuildingFaithRet) GetBuildingFaith() int32 {
	if m != nil {
		return m.BuildingFaith
	}
	return 0
}

func (m *ReceiveBuildingFaithRet) GetFaithUpdateTime() int64 {
	if m != nil {
		return m.FaithUpdateTime
	}
	return 0
}

// 激活图鉴物品
type ActiveGroupItem struct {
	GroupID int32   `protobuf:"varint,1,opt,name=groupID,proto3" json:"groupID,omitempty"`
	ItemID  []int32 `protobuf:"varint,2,rep,packed,name=itemID" json:"itemID,omitempty"`
}

func (m *ActiveGroupItem) Reset()                    { *m = ActiveGroupItem{} }
func (m *ActiveGroupItem) String() string            { return proto.CompactTextString(m) }
func (*ActiveGroupItem) ProtoMessage()               {}
func (*ActiveGroupItem) Descriptor() ([]byte, []int) { return fileDescriptorBuilding, []int{22} }

func (m *ActiveGroupItem) GetGroupID() int32 {
	if m != nil {
		return m.GroupID
	}
	return 0
}

func (m *ActiveGroupItem) GetItemID() []int32 {
	if m != nil {
		return m.ItemID
	}
	return nil
}

type ActiveGroupItemRet struct {
	GroupID int32 `protobuf:"varint,1,opt,name=groupID,proto3" json:"groupID,omitempty"`
}

func (m *ActiveGroupItemRet) Reset()                    { *m = ActiveGroupItemRet{} }
func (m *ActiveGroupItemRet) String() string            { return proto.CompactTextString(m) }
func (*ActiveGroupItemRet) ProtoMessage()               {}
func (*ActiveGroupItemRet) Descriptor() ([]byte, []int) { return fileDescriptorBuilding, []int{23} }

func (m *ActiveGroupItemRet) GetGroupID() int32 {
	if m != nil {
		return m.GroupID
	}
	return 0
}

func init() {
	proto.RegisterType((*BuildingReset)(nil), "protocol.building_reset")
	proto.RegisterType((*BuildStarBuilding)(nil), "protocol.build_star_building")
	proto.RegisterType((*BuildStarBuildingRet)(nil), "protocol.build_star_building_ret")
	proto.RegisterType((*AccRepairStarBuild)(nil), "protocol.acc_repair_star_build")
	proto.RegisterType((*AccRepairStarBuildRet)(nil), "protocol.acc_repair_star_build_ret")
	proto.RegisterType((*RepairStarBuild)(nil), "protocol.repair_star_build")
	proto.RegisterType((*RepairStarBuildRet)(nil), "protocol.repair_star_build_ret")
	proto.RegisterType((*RepairStarBuildEnd)(nil), "protocol.repair_star_build_end")
	proto.RegisterType((*RepairStarBuildEndRet)(nil), "protocol.repair_star_build_end_ret")
	proto.RegisterType((*UpdateStarBuildEnd)(nil), "protocol.update_star_build_end")
	proto.RegisterType((*UpdateStarBuildEndRet)(nil), "protocol.update_star_build_end_ret")
	proto.RegisterType((*AccUpdateStarBuild)(nil), "protocol.acc_update_star_build")
	proto.RegisterType((*AccUpdateStarBuildRet)(nil), "protocol.acc_update_star_build_ret")
	proto.RegisterType((*CancelUpgradeStarBuild)(nil), "protocol.cancel_upgrade_star_build")
	proto.RegisterType((*CancelUpgradeStarBuildRet)(nil), "protocol.cancel_upgrade_star_build_ret")
	proto.RegisterType((*CancelRepairStarBuild)(nil), "protocol.cancel_repair_star_build")
	proto.RegisterType((*CancelRepairStarBuildRet)(nil), "protocol.cancel_repair_star_build_ret")
	proto.RegisterType((*BuildingInfoPush)(nil), "protocol.building_info_push")
	proto.RegisterType((*GetBuildingFaith)(nil), "protocol.get_building_faith")
	proto.RegisterType((*GetBuildingFaithRet)(nil), "protocol.get_building_faith_ret")
	proto.RegisterType((*ReceiveBuildingFaith)(nil), "protocol.receive_building_faith")
	proto.RegisterType((*ReceiveBuildingFaithRet)(nil), "protocol.receive_building_faith_ret")
	proto.RegisterType((*ActiveGroupItem)(nil), "protocol.active_group_item")
	proto.RegisterType((*ActiveGroupItemRet)(nil), "protocol.active_group_item_ret")
}
func (m *BuildingReset) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuildingReset) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Building) > 0 {
		for _, msg := range m.Building {
			dAtA[i] = 0xa
			i++
			i = encodeVarintBuilding(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ItemID) > 0 {
		dAtA2 := make([]byte, len(m.ItemID)*10)
		var j1 int
		for _, num1 := range m.ItemID {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	if m.PowerLimit != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.PowerLimit))
	}
	return i, nil
}

func (m *BuildStarBuilding) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuildStarBuilding) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StarID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.StarID))
	}
	if m.BuildingType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.BuildingType))
	}
	if m.Level != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.Level))
	}
	if len(m.BelieverId) > 0 {
		for _, s := range m.BelieverId {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Faith != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.Faith))
	}
	if m.Guide {
		dAtA[i] = 0x30
		i++
		if m.Guide {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *BuildStarBuildingRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuildStarBuildingRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result {
		dAtA[i] = 0x8
		i++
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.UpdateTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.UpdateTime))
	}
	if m.Builidng != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.Builidng.Size()))
		n3, err := m.Builidng.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.PowerLimit != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.PowerLimit))
	}
	if m.Cost != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.Cost))
	}
	if m.Done {
		dAtA[i] = 0x30
		i++
		if m.Done {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CivilizationInfo != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.CivilizationInfo.Size()))
		n4, err := m.CivilizationInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.ItemID != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.ItemID))
	}
	return i, nil
}

func (m *AccRepairStarBuild) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccRepairStarBuild) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.Uid))
	}
	if m.BuildingType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.BuildingType))
	}
	if len(m.BelieverId) > 0 {
		for _, s := range m.BelieverId {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *AccRepairStarBuildRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccRepairStarBuildRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.Uid))
	}
	if m.BuildingType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.BuildingType))
	}
	if m.RepairTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.RepairTime))
	}
	if m.BelieverNum != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.BelieverNum))
	}
	if m.Done {
		dAtA[i] = 0x28
		i++
		if m.Done {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.BuildingLevel != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.BuildingLevel))
	}
	if m.CivilizationInfo != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.CivilizationInfo.Size()))
		n5, err := m.CivilizationInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.ItemID != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.ItemID))
	}
	return i, nil
}

func (m *RepairStarBuild) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RepairStarBuild) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.Uid))
	}
	if m.Faith != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.Faith))
	}
	if m.BuildingType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.BuildingType))
	}
	if len(m.BelieverId) > 0 {
		for _, s := range m.BelieverId {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *RepairStarBuildRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RepairStarBuildRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.Uid))
	}
	if m.Cost != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.Cost))
	}
	if m.BuildingType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.BuildingType))
	}
	if m.RepairTime != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.RepairTime))
	}
	if m.Done {
		dAtA[i] = 0x28
		i++
		if m.Done {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.BuildingLevel != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.BuildingLevel))
	}
	if m.CivilizationInfo != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.CivilizationInfo.Size()))
		n6, err := m.CivilizationInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.ItemID != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.ItemID))
	}
	return i, nil
}

func (m *RepairStarBuildEnd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RepairStarBuildEnd) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.Uid))
	}
	if m.BuildingType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.BuildingType))
	}
	return i, nil
}

func (m *RepairStarBuildEndRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RepairStarBuildEndRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Done {
		dAtA[i] = 0x8
		i++
		if m.Done {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.RepairTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.RepairTime))
	}
	if m.BuildingLevel != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.BuildingLevel))
	}
	if m.CivilizationInfo != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.CivilizationInfo.Size()))
		n7, err := m.CivilizationInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.ItemID != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.ItemID))
	}
	return i, nil
}

func (m *UpdateStarBuildEnd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateStarBuildEnd) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.Uid))
	}
	if m.BuildingType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.BuildingType))
	}
	return i, nil
}

func (m *UpdateStarBuildEndRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateStarBuildEndRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.Uid))
	}
	if m.BuildingType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.BuildingType))
	}
	if m.Level != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.Level))
	}
	if m.UpdateTime != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.UpdateTime))
	}
	if m.PowerLimit != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.PowerLimit))
	}
	if m.Done {
		dAtA[i] = 0x38
		i++
		if m.Done {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CivilizationInfo != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.CivilizationInfo.Size()))
		n8, err := m.CivilizationInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.ItemID != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.ItemID))
	}
	if m.PowerReward != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.PowerReward))
	}
	return i, nil
}

func (m *AccUpdateStarBuild) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccUpdateStarBuild) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.Uid))
	}
	if m.BuildingType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.BuildingType))
	}
	if len(m.BelieverId) > 0 {
		for _, s := range m.BelieverId {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Guide {
		dAtA[i] = 0x20
		i++
		if m.Guide {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *AccUpdateStarBuildRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccUpdateStarBuildRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.Uid))
	}
	if m.BuildingType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.BuildingType))
	}
	if m.Level != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.Level))
	}
	if m.PowerLimit != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.PowerLimit))
	}
	if m.UpdateTime != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.UpdateTime))
	}
	if m.BelieverNum != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.BelieverNum))
	}
	if m.Done {
		dAtA[i] = 0x40
		i++
		if m.Done {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CivilizationInfo != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.CivilizationInfo.Size()))
		n9, err := m.CivilizationInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.ItemID != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.ItemID))
	}
	return i, nil
}

func (m *CancelUpgradeStarBuild) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CancelUpgradeStarBuild) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BuildingType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.BuildingType))
	}
	return i, nil
}

func (m *CancelUpgradeStarBuildRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CancelUpgradeStarBuildRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BackFaith != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.BackFaith))
	}
	if m.BuildingType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.BuildingType))
	}
	if m.BuildingLevel != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.BuildingLevel))
	}
	if m.UpdateTime != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.UpdateTime))
	}
	return i, nil
}

func (m *CancelRepairStarBuild) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CancelRepairStarBuild) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BuildingType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.BuildingType))
	}
	return i, nil
}

func (m *CancelRepairStarBuildRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CancelRepairStarBuildRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BackFaith != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.BackFaith))
	}
	if m.BuildingType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.BuildingType))
	}
	if m.BuildingLevel != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.BuildingLevel))
	}
	if m.RepairTime != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.RepairTime))
	}
	if m.BrokenTime != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.BrokenTime))
	}
	return i, nil
}

func (m *BuildingInfoPush) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuildingInfoPush) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.Uid))
	}
	if m.StarID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.StarID))
	}
	if m.Type != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.Type))
	}
	if len(m.Building) > 0 {
		for _, msg := range m.Building {
			dAtA[i] = 0x22
			i++
			i = encodeVarintBuilding(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GetBuildingFaith) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetBuildingFaith) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.Uid))
	}
	if m.BuildingType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.BuildingType))
	}
	return i, nil
}

func (m *GetBuildingFaithRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetBuildingFaithRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.Uid))
	}
	if len(m.BuildingsFaith) > 0 {
		for _, msg := range m.BuildingsFaith {
			dAtA[i] = 0x12
			i++
			i = encodeVarintBuilding(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ReceiveBuildingFaith) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReceiveBuildingFaith) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.Uid))
	}
	if m.BuildingType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.BuildingType))
	}
	return i, nil
}

func (m *ReceiveBuildingFaithRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReceiveBuildingFaithRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result {
		dAtA[i] = 0x8
		i++
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.BuildingFaith != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.BuildingFaith))
	}
	if m.FaithUpdateTime != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.FaithUpdateTime))
	}
	return i, nil
}

func (m *ActiveGroupItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActiveGroupItem) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.GroupID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.GroupID))
	}
	if len(m.ItemID) > 0 {
		dAtA11 := make([]byte, len(m.ItemID)*10)
		var j10 int
		for _, num1 := range m.ItemID {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA11[j10] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j10++
			}
			dAtA11[j10] = uint8(num)
			j10++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(j10))
		i += copy(dAtA[i:], dAtA11[:j10])
	}
	return i, nil
}

func (m *ActiveGroupItemRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActiveGroupItemRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.GroupID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBuilding(dAtA, i, uint64(m.GroupID))
	}
	return i, nil
}

func encodeVarintBuilding(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *BuildingReset) Size() (n int) {
	var l int
	_ = l
	if len(m.Building) > 0 {
		for _, e := range m.Building {
			l = e.Size()
			n += 1 + l + sovBuilding(uint64(l))
		}
	}
	if len(m.ItemID) > 0 {
		l = 0
		for _, e := range m.ItemID {
			l += sovBuilding(uint64(e))
		}
		n += 1 + sovBuilding(uint64(l)) + l
	}
	if m.PowerLimit != 0 {
		n += 1 + sovBuilding(uint64(m.PowerLimit))
	}
	return n
}

func (m *BuildStarBuilding) Size() (n int) {
	var l int
	_ = l
	if m.StarID != 0 {
		n += 1 + sovBuilding(uint64(m.StarID))
	}
	if m.BuildingType != 0 {
		n += 1 + sovBuilding(uint64(m.BuildingType))
	}
	if m.Level != 0 {
		n += 1 + sovBuilding(uint64(m.Level))
	}
	if len(m.BelieverId) > 0 {
		for _, s := range m.BelieverId {
			l = len(s)
			n += 1 + l + sovBuilding(uint64(l))
		}
	}
	if m.Faith != 0 {
		n += 1 + sovBuilding(uint64(m.Faith))
	}
	if m.Guide {
		n += 2
	}
	return n
}

func (m *BuildStarBuildingRet) Size() (n int) {
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	if m.UpdateTime != 0 {
		n += 1 + sovBuilding(uint64(m.UpdateTime))
	}
	if m.Builidng != nil {
		l = m.Builidng.Size()
		n += 1 + l + sovBuilding(uint64(l))
	}
	if m.PowerLimit != 0 {
		n += 1 + sovBuilding(uint64(m.PowerLimit))
	}
	if m.Cost != 0 {
		n += 1 + sovBuilding(uint64(m.Cost))
	}
	if m.Done {
		n += 2
	}
	if m.CivilizationInfo != nil {
		l = m.CivilizationInfo.Size()
		n += 1 + l + sovBuilding(uint64(l))
	}
	if m.ItemID != 0 {
		n += 1 + sovBuilding(uint64(m.ItemID))
	}
	return n
}

func (m *AccRepairStarBuild) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovBuilding(uint64(m.Uid))
	}
	if m.BuildingType != 0 {
		n += 1 + sovBuilding(uint64(m.BuildingType))
	}
	if len(m.BelieverId) > 0 {
		for _, s := range m.BelieverId {
			l = len(s)
			n += 1 + l + sovBuilding(uint64(l))
		}
	}
	return n
}

func (m *AccRepairStarBuildRet) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovBuilding(uint64(m.Uid))
	}
	if m.BuildingType != 0 {
		n += 1 + sovBuilding(uint64(m.BuildingType))
	}
	if m.RepairTime != 0 {
		n += 1 + sovBuilding(uint64(m.RepairTime))
	}
	if m.BelieverNum != 0 {
		n += 1 + sovBuilding(uint64(m.BelieverNum))
	}
	if m.Done {
		n += 2
	}
	if m.BuildingLevel != 0 {
		n += 1 + sovBuilding(uint64(m.BuildingLevel))
	}
	if m.CivilizationInfo != nil {
		l = m.CivilizationInfo.Size()
		n += 1 + l + sovBuilding(uint64(l))
	}
	if m.ItemID != 0 {
		n += 1 + sovBuilding(uint64(m.ItemID))
	}
	return n
}

func (m *RepairStarBuild) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovBuilding(uint64(m.Uid))
	}
	if m.Faith != 0 {
		n += 1 + sovBuilding(uint64(m.Faith))
	}
	if m.BuildingType != 0 {
		n += 1 + sovBuilding(uint64(m.BuildingType))
	}
	if len(m.BelieverId) > 0 {
		for _, s := range m.BelieverId {
			l = len(s)
			n += 1 + l + sovBuilding(uint64(l))
		}
	}
	return n
}

func (m *RepairStarBuildRet) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovBuilding(uint64(m.Uid))
	}
	if m.Cost != 0 {
		n += 1 + sovBuilding(uint64(m.Cost))
	}
	if m.BuildingType != 0 {
		n += 1 + sovBuilding(uint64(m.BuildingType))
	}
	if m.RepairTime != 0 {
		n += 1 + sovBuilding(uint64(m.RepairTime))
	}
	if m.Done {
		n += 2
	}
	if m.BuildingLevel != 0 {
		n += 1 + sovBuilding(uint64(m.BuildingLevel))
	}
	if m.CivilizationInfo != nil {
		l = m.CivilizationInfo.Size()
		n += 1 + l + sovBuilding(uint64(l))
	}
	if m.ItemID != 0 {
		n += 1 + sovBuilding(uint64(m.ItemID))
	}
	return n
}

func (m *RepairStarBuildEnd) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovBuilding(uint64(m.Uid))
	}
	if m.BuildingType != 0 {
		n += 1 + sovBuilding(uint64(m.BuildingType))
	}
	return n
}

func (m *RepairStarBuildEndRet) Size() (n int) {
	var l int
	_ = l
	if m.Done {
		n += 2
	}
	if m.RepairTime != 0 {
		n += 1 + sovBuilding(uint64(m.RepairTime))
	}
	if m.BuildingLevel != 0 {
		n += 1 + sovBuilding(uint64(m.BuildingLevel))
	}
	if m.CivilizationInfo != nil {
		l = m.CivilizationInfo.Size()
		n += 1 + l + sovBuilding(uint64(l))
	}
	if m.ItemID != 0 {
		n += 1 + sovBuilding(uint64(m.ItemID))
	}
	return n
}

func (m *UpdateStarBuildEnd) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovBuilding(uint64(m.Uid))
	}
	if m.BuildingType != 0 {
		n += 1 + sovBuilding(uint64(m.BuildingType))
	}
	return n
}

func (m *UpdateStarBuildEndRet) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovBuilding(uint64(m.Uid))
	}
	if m.BuildingType != 0 {
		n += 1 + sovBuilding(uint64(m.BuildingType))
	}
	if m.Level != 0 {
		n += 1 + sovBuilding(uint64(m.Level))
	}
	if m.UpdateTime != 0 {
		n += 1 + sovBuilding(uint64(m.UpdateTime))
	}
	if m.PowerLimit != 0 {
		n += 1 + sovBuilding(uint64(m.PowerLimit))
	}
	if m.Done {
		n += 2
	}
	if m.CivilizationInfo != nil {
		l = m.CivilizationInfo.Size()
		n += 1 + l + sovBuilding(uint64(l))
	}
	if m.ItemID != 0 {
		n += 1 + sovBuilding(uint64(m.ItemID))
	}
	if m.PowerReward != 0 {
		n += 1 + sovBuilding(uint64(m.PowerReward))
	}
	return n
}

func (m *AccUpdateStarBuild) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovBuilding(uint64(m.Uid))
	}
	if m.BuildingType != 0 {
		n += 1 + sovBuilding(uint64(m.BuildingType))
	}
	if len(m.BelieverId) > 0 {
		for _, s := range m.BelieverId {
			l = len(s)
			n += 1 + l + sovBuilding(uint64(l))
		}
	}
	if m.Guide {
		n += 2
	}
	return n
}

func (m *AccUpdateStarBuildRet) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovBuilding(uint64(m.Uid))
	}
	if m.BuildingType != 0 {
		n += 1 + sovBuilding(uint64(m.BuildingType))
	}
	if m.Level != 0 {
		n += 1 + sovBuilding(uint64(m.Level))
	}
	if m.PowerLimit != 0 {
		n += 1 + sovBuilding(uint64(m.PowerLimit))
	}
	if m.UpdateTime != 0 {
		n += 1 + sovBuilding(uint64(m.UpdateTime))
	}
	if m.BelieverNum != 0 {
		n += 1 + sovBuilding(uint64(m.BelieverNum))
	}
	if m.Done {
		n += 2
	}
	if m.CivilizationInfo != nil {
		l = m.CivilizationInfo.Size()
		n += 1 + l + sovBuilding(uint64(l))
	}
	if m.ItemID != 0 {
		n += 1 + sovBuilding(uint64(m.ItemID))
	}
	return n
}

func (m *CancelUpgradeStarBuild) Size() (n int) {
	var l int
	_ = l
	if m.BuildingType != 0 {
		n += 1 + sovBuilding(uint64(m.BuildingType))
	}
	return n
}

func (m *CancelUpgradeStarBuildRet) Size() (n int) {
	var l int
	_ = l
	if m.BackFaith != 0 {
		n += 1 + sovBuilding(uint64(m.BackFaith))
	}
	if m.BuildingType != 0 {
		n += 1 + sovBuilding(uint64(m.BuildingType))
	}
	if m.BuildingLevel != 0 {
		n += 1 + sovBuilding(uint64(m.BuildingLevel))
	}
	if m.UpdateTime != 0 {
		n += 1 + sovBuilding(uint64(m.UpdateTime))
	}
	return n
}

func (m *CancelRepairStarBuild) Size() (n int) {
	var l int
	_ = l
	if m.BuildingType != 0 {
		n += 1 + sovBuilding(uint64(m.BuildingType))
	}
	return n
}

func (m *CancelRepairStarBuildRet) Size() (n int) {
	var l int
	_ = l
	if m.BackFaith != 0 {
		n += 1 + sovBuilding(uint64(m.BackFaith))
	}
	if m.BuildingType != 0 {
		n += 1 + sovBuilding(uint64(m.BuildingType))
	}
	if m.BuildingLevel != 0 {
		n += 1 + sovBuilding(uint64(m.BuildingLevel))
	}
	if m.RepairTime != 0 {
		n += 1 + sovBuilding(uint64(m.RepairTime))
	}
	if m.BrokenTime != 0 {
		n += 1 + sovBuilding(uint64(m.BrokenTime))
	}
	return n
}

func (m *BuildingInfoPush) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovBuilding(uint64(m.Uid))
	}
	if m.StarID != 0 {
		n += 1 + sovBuilding(uint64(m.StarID))
	}
	if m.Type != 0 {
		n += 1 + sovBuilding(uint64(m.Type))
	}
	if len(m.Building) > 0 {
		for _, e := range m.Building {
			l = e.Size()
			n += 1 + l + sovBuilding(uint64(l))
		}
	}
	return n
}

func (m *GetBuildingFaith) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovBuilding(uint64(m.Uid))
	}
	if m.BuildingType != 0 {
		n += 1 + sovBuilding(uint64(m.BuildingType))
	}
	return n
}

func (m *GetBuildingFaithRet) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovBuilding(uint64(m.Uid))
	}
	if len(m.BuildingsFaith) > 0 {
		for _, e := range m.BuildingsFaith {
			l = e.Size()
			n += 1 + l + sovBuilding(uint64(l))
		}
	}
	return n
}

func (m *ReceiveBuildingFaith) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovBuilding(uint64(m.Uid))
	}
	if m.BuildingType != 0 {
		n += 1 + sovBuilding(uint64(m.BuildingType))
	}
	return n
}

func (m *ReceiveBuildingFaithRet) Size() (n int) {
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	if m.BuildingFaith != 0 {
		n += 1 + sovBuilding(uint64(m.BuildingFaith))
	}
	if m.FaithUpdateTime != 0 {
		n += 1 + sovBuilding(uint64(m.FaithUpdateTime))
	}
	return n
}

func (m *ActiveGroupItem) Size() (n int) {
	var l int
	_ = l
	if m.GroupID != 0 {
		n += 1 + sovBuilding(uint64(m.GroupID))
	}
	if len(m.ItemID) > 0 {
		l = 0
		for _, e := range m.ItemID {
			l += sovBuilding(uint64(e))
		}
		n += 1 + sovBuilding(uint64(l)) + l
	}
	return n
}

func (m *ActiveGroupItemRet) Size() (n int) {
	var l int
	_ = l
	if m.GroupID != 0 {
		n += 1 + sovBuilding(uint64(m.GroupID))
	}
	return n
}

func sovBuilding(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozBuilding(x uint64) (n int) {
	return sovBuilding(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *BuildingReset) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBuilding
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: building_reset: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: building_reset: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Building", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBuilding
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Building = append(m.Building, &BuildingInfo{})
			if err := m.Building[len(m.Building)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBuilding
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ItemID = append(m.ItemID, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBuilding
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBuilding
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBuilding
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ItemID = append(m.ItemID, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemID", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PowerLimit", wireType)
			}
			m.PowerLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PowerLimit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBuilding(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBuilding
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuildStarBuilding) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBuilding
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: build_star_building: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: build_star_building: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StarID", wireType)
			}
			m.StarID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StarID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildingType", wireType)
			}
			m.BuildingType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuildingType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BelieverId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBuilding
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BelieverId = append(m.BelieverId, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Faith", wireType)
			}
			m.Faith = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Faith |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Guide", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Guide = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipBuilding(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBuilding
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuildStarBuildingRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBuilding
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: build_star_building_ret: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: build_star_building_ret: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateTime", wireType)
			}
			m.UpdateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Builidng", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBuilding
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Builidng == nil {
				m.Builidng = &BuildingInfo{}
			}
			if err := m.Builidng.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PowerLimit", wireType)
			}
			m.PowerLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PowerLimit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cost", wireType)
			}
			m.Cost = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cost |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Done", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Done = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CivilizationInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBuilding
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CivilizationInfo == nil {
				m.CivilizationInfo = &CivilizationInfo{}
			}
			if err := m.CivilizationInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemID", wireType)
			}
			m.ItemID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBuilding(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBuilding
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccRepairStarBuild) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBuilding
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: acc_repair_star_build: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: acc_repair_star_build: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildingType", wireType)
			}
			m.BuildingType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuildingType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BelieverId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBuilding
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BelieverId = append(m.BelieverId, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBuilding(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBuilding
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccRepairStarBuildRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBuilding
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: acc_repair_star_build_ret: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: acc_repair_star_build_ret: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildingType", wireType)
			}
			m.BuildingType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuildingType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepairTime", wireType)
			}
			m.RepairTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RepairTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BelieverNum", wireType)
			}
			m.BelieverNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BelieverNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Done", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Done = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildingLevel", wireType)
			}
			m.BuildingLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuildingLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CivilizationInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBuilding
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CivilizationInfo == nil {
				m.CivilizationInfo = &CivilizationInfo{}
			}
			if err := m.CivilizationInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemID", wireType)
			}
			m.ItemID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBuilding(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBuilding
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepairStarBuild) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBuilding
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: repair_star_build: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: repair_star_build: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Faith", wireType)
			}
			m.Faith = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Faith |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildingType", wireType)
			}
			m.BuildingType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuildingType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BelieverId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBuilding
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BelieverId = append(m.BelieverId, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBuilding(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBuilding
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepairStarBuildRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBuilding
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: repair_star_build_ret: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: repair_star_build_ret: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cost", wireType)
			}
			m.Cost = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cost |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildingType", wireType)
			}
			m.BuildingType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuildingType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepairTime", wireType)
			}
			m.RepairTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RepairTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Done", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Done = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildingLevel", wireType)
			}
			m.BuildingLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuildingLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CivilizationInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBuilding
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CivilizationInfo == nil {
				m.CivilizationInfo = &CivilizationInfo{}
			}
			if err := m.CivilizationInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemID", wireType)
			}
			m.ItemID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBuilding(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBuilding
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepairStarBuildEnd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBuilding
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: repair_star_build_end: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: repair_star_build_end: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildingType", wireType)
			}
			m.BuildingType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuildingType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBuilding(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBuilding
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepairStarBuildEndRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBuilding
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: repair_star_build_end_ret: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: repair_star_build_end_ret: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Done", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Done = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepairTime", wireType)
			}
			m.RepairTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RepairTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildingLevel", wireType)
			}
			m.BuildingLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuildingLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CivilizationInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBuilding
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CivilizationInfo == nil {
				m.CivilizationInfo = &CivilizationInfo{}
			}
			if err := m.CivilizationInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemID", wireType)
			}
			m.ItemID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBuilding(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBuilding
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateStarBuildEnd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBuilding
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: update_star_build_end: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: update_star_build_end: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildingType", wireType)
			}
			m.BuildingType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuildingType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBuilding(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBuilding
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateStarBuildEndRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBuilding
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: update_star_build_end_ret: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: update_star_build_end_ret: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildingType", wireType)
			}
			m.BuildingType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuildingType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateTime", wireType)
			}
			m.UpdateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PowerLimit", wireType)
			}
			m.PowerLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PowerLimit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Done", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Done = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CivilizationInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBuilding
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CivilizationInfo == nil {
				m.CivilizationInfo = &CivilizationInfo{}
			}
			if err := m.CivilizationInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemID", wireType)
			}
			m.ItemID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PowerReward", wireType)
			}
			m.PowerReward = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PowerReward |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBuilding(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBuilding
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccUpdateStarBuild) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBuilding
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: acc_update_star_build: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: acc_update_star_build: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildingType", wireType)
			}
			m.BuildingType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuildingType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BelieverId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBuilding
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BelieverId = append(m.BelieverId, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Guide", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Guide = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipBuilding(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBuilding
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccUpdateStarBuildRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBuilding
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: acc_update_star_build_ret: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: acc_update_star_build_ret: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildingType", wireType)
			}
			m.BuildingType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuildingType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PowerLimit", wireType)
			}
			m.PowerLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PowerLimit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateTime", wireType)
			}
			m.UpdateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BelieverNum", wireType)
			}
			m.BelieverNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BelieverNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Done", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Done = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CivilizationInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBuilding
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CivilizationInfo == nil {
				m.CivilizationInfo = &CivilizationInfo{}
			}
			if err := m.CivilizationInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemID", wireType)
			}
			m.ItemID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBuilding(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBuilding
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CancelUpgradeStarBuild) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBuilding
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: cancel_upgrade_star_build: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: cancel_upgrade_star_build: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildingType", wireType)
			}
			m.BuildingType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuildingType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBuilding(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBuilding
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CancelUpgradeStarBuildRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBuilding
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: cancel_upgrade_star_build_ret: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: cancel_upgrade_star_build_ret: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackFaith", wireType)
			}
			m.BackFaith = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BackFaith |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildingType", wireType)
			}
			m.BuildingType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuildingType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildingLevel", wireType)
			}
			m.BuildingLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuildingLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateTime", wireType)
			}
			m.UpdateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBuilding(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBuilding
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CancelRepairStarBuild) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBuilding
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: cancel_repair_star_build: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: cancel_repair_star_build: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildingType", wireType)
			}
			m.BuildingType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuildingType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBuilding(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBuilding
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CancelRepairStarBuildRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBuilding
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: cancel_repair_star_build_ret: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: cancel_repair_star_build_ret: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackFaith", wireType)
			}
			m.BackFaith = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BackFaith |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildingType", wireType)
			}
			m.BuildingType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuildingType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildingLevel", wireType)
			}
			m.BuildingLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuildingLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepairTime", wireType)
			}
			m.RepairTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RepairTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BrokenTime", wireType)
			}
			m.BrokenTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BrokenTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBuilding(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBuilding
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuildingInfoPush) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBuilding
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: building_info_push: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: building_info_push: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StarID", wireType)
			}
			m.StarID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StarID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Building", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBuilding
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Building = append(m.Building, &BuildingInfo{})
			if err := m.Building[len(m.Building)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBuilding(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBuilding
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetBuildingFaith) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBuilding
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: get_building_faith: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: get_building_faith: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildingType", wireType)
			}
			m.BuildingType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuildingType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBuilding(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBuilding
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetBuildingFaithRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBuilding
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: get_building_faith_ret: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: get_building_faith_ret: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildingsFaith", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBuilding
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BuildingsFaith = append(m.BuildingsFaith, &BuildingFaith{})
			if err := m.BuildingsFaith[len(m.BuildingsFaith)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBuilding(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBuilding
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReceiveBuildingFaith) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBuilding
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: receive_building_faith: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: receive_building_faith: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildingType", wireType)
			}
			m.BuildingType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuildingType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBuilding(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBuilding
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReceiveBuildingFaithRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBuilding
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: receive_building_faith_ret: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: receive_building_faith_ret: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildingFaith", wireType)
			}
			m.BuildingFaith = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuildingFaith |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FaithUpdateTime", wireType)
			}
			m.FaithUpdateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FaithUpdateTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBuilding(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBuilding
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActiveGroupItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBuilding
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: active_group_item: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: active_group_item: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			m.GroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBuilding
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ItemID = append(m.ItemID, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBuilding
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBuilding
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBuilding
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ItemID = append(m.ItemID, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemID", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBuilding(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBuilding
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActiveGroupItemRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBuilding
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: active_group_item_ret: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: active_group_item_ret: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			m.GroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBuilding(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBuilding
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBuilding(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBuilding
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBuilding
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthBuilding
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowBuilding
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipBuilding(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthBuilding = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBuilding   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("building.proto", fileDescriptorBuilding) }

var fileDescriptorBuilding = []byte{
	// 876 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x57, 0x4d, 0x6f, 0xd3, 0x4c,
	0x10, 0xd6, 0xda, 0x4e, 0x9a, 0x4c, 0xfb, 0xf6, 0x6d, 0x17, 0xda, 0x3a, 0xa5, 0x44, 0x91, 0xc5,
	0x21, 0xa7, 0x4a, 0xd0, 0x3b, 0x20, 0x54, 0x8a, 0x82, 0x4a, 0x0f, 0x56, 0x39, 0x5b, 0x8e, 0xbd,
	0x4d, 0x57, 0x75, 0x6c, 0xcb, 0xb1, 0x53, 0x81, 0x84, 0x38, 0x80, 0xc4, 0x9f, 0xe0, 0xce, 0x0d,
	0x0e, 0xdc, 0x7b, 0x44, 0x1c, 0x39, 0x71, 0x46, 0xfd, 0x25, 0xc8, 0xbb, 0x76, 0xbc, 0xfe, 0x48,
	0x13, 0xf5, 0x03, 0xf5, 0x14, 0xcf, 0x64, 0x77, 0xf6, 0xd9, 0xe7, 0xd9, 0x99, 0xd9, 0x85, 0xe5,
	0x7e, 0x44, 0x1d, 0x9b, 0xba, 0x83, 0x6d, 0x3f, 0xf0, 0x42, 0x0f, 0x37, 0xd8, 0x8f, 0xe5, 0x39,
	0x9b, 0xcb, 0xa6, 0x69, 0x79, 0xc3, 0xa1, 0xe7, 0xf2, 0x7f, 0xb4, 0x77, 0xd9, 0x58, 0x23, 0x20,
	0x23, 0x12, 0xe2, 0x1d, 0x68, 0xa4, 0x1e, 0x15, 0x75, 0xe4, 0xee, 0xe2, 0xa3, 0x8d, 0xed, 0x74,
	0xfa, 0xf6, 0x64, 0x2c, 0x75, 0x8f, 0x3c, 0x7d, 0x32, 0x10, 0xaf, 0x43, 0x9d, 0x86, 0x64, 0xd8,
	0xdb, 0x55, 0xa5, 0x8e, 0xdc, 0xad, 0xe9, 0x89, 0x85, 0xdb, 0x00, 0xbe, 0x77, 0x4a, 0x82, 0x7d,
	0x3a, 0xa4, 0xa1, 0x2a, 0x77, 0x50, 0xb7, 0xa6, 0x0b, 0x1e, 0xed, 0x3b, 0x82, 0x3b, 0x2c, 0x88,
	0x31, 0x0a, 0xcd, 0xc0, 0x10, 0xe3, 0xc5, 0x8e, 0xde, 0xae, 0x8a, 0xd8, 0x9c, 0xc4, 0xc2, 0x1a,
	0x2c, 0xa5, 0x63, 0x0e, 0xdf, 0xf8, 0x44, 0x95, 0xd8, 0xbf, 0x39, 0x1f, 0xbe, 0x0b, 0x35, 0x87,
	0x8c, 0x89, 0x93, 0x2c, 0xc7, 0x8d, 0x18, 0x49, 0x9f, 0x38, 0x94, 0x8c, 0x49, 0xd0, 0xb3, 0x55,
	0xa5, 0x23, 0x77, 0x9b, 0xba, 0xe0, 0x89, 0x67, 0x1d, 0x99, 0x34, 0x3c, 0x56, 0x6b, 0x7c, 0x16,
	0x33, 0x62, 0xef, 0x20, 0xa2, 0x36, 0x51, 0xeb, 0x1d, 0xd4, 0x6d, 0xe8, 0xdc, 0xd0, 0xbe, 0x49,
	0xb0, 0x51, 0x81, 0xda, 0x08, 0x48, 0x18, 0x23, 0x0f, 0xc8, 0x28, 0x72, 0x42, 0x86, 0xbc, 0xa1,
	0x27, 0x56, 0xbc, 0x7e, 0xe4, 0xdb, 0x66, 0x48, 0x0e, 0xe9, 0x90, 0xe3, 0x96, 0x75, 0xc1, 0x93,
	0xd2, 0x4e, 0x6d, 0x77, 0xc0, 0x80, 0xcf, 0xa2, 0x3d, 0x1e, 0x58, 0xa0, 0x57, 0x29, 0xd2, 0x8b,
	0x31, 0x28, 0x96, 0x37, 0x0a, 0x93, 0x3d, 0xb1, 0xef, 0xd8, 0x67, 0x7b, 0x6e, 0xba, 0x23, 0xf6,
	0x8d, 0x5f, 0xc0, 0x8a, 0x45, 0xc7, 0xd4, 0xa1, 0x6f, 0xcd, 0x90, 0x7a, 0x6e, 0xcf, 0x3d, 0xf2,
	0xd4, 0x05, 0x06, 0xe2, 0x5e, 0x06, 0x42, 0x1c, 0xc1, 0x81, 0x94, 0x26, 0x09, 0xe7, 0xa0, 0xc1,
	0x75, 0xe3, 0x96, 0x36, 0x84, 0x35, 0xd3, 0xb2, 0x8c, 0x80, 0xf8, 0x26, 0x0d, 0x04, 0xd6, 0xf0,
	0x0a, 0xc8, 0x11, 0xb5, 0x13, 0x95, 0xe3, 0xcf, 0xb9, 0x24, 0xce, 0x8b, 0x29, 0x17, 0xc5, 0xd4,
	0xbe, 0x4a, 0xd0, 0xaa, 0x5c, 0x8f, 0x49, 0x74, 0xe9, 0x35, 0x79, 0x38, 0x26, 0xa0, 0xcc, 0x05,
	0xcc, 0x3c, 0xb8, 0x03, 0x8b, 0x29, 0x82, 0x83, 0x68, 0x98, 0x88, 0x21, 0xba, 0x26, 0xcc, 0xd7,
	0x04, 0xe6, 0x1f, 0xc0, 0x7f, 0xe9, 0x2a, 0xfb, 0xec, 0xd0, 0xd6, 0xd9, 0xbc, 0xbc, 0xf3, 0xe6,
	0xf5, 0x79, 0x0f, 0xab, 0xf3, 0x68, 0x33, 0x49, 0x12, 0x49, 0x4c, 0x92, 0x22, 0x7b, 0xf2, 0x4c,
	0xc5, 0x4a, 0xe9, 0xa7, 0x7d, 0x96, 0x60, 0x6d, 0x5e, 0xb5, 0xd2, 0x53, 0x2d, 0x09, 0xa7, 0x7a,
	0x4e, 0x0c, 0x82, 0x82, 0x4a, 0x49, 0xc1, 0x5b, 0xac, 0xcf, 0xab, 0x2a, 0x76, 0x88, 0x7b, 0xc9,
	0xfc, 0xd1, 0x7e, 0x23, 0x68, 0x55, 0xc6, 0x63, 0x8c, 0xa7, 0x3c, 0x20, 0x81, 0x87, 0x3c, 0x77,
	0x52, 0x89, 0xbb, 0xdb, 0xc3, 0x13, 0xaf, 0xa9, 0xd7, 0xc3, 0xd3, 0x99, 0x04, 0xad, 0xca, 0x78,
	0x57, 0xa8, 0x23, 0x53, 0xdb, 0x93, 0xd0, 0x1e, 0x94, 0x52, 0x7b, 0xc8, 0x57, 0xfa, 0x5a, 0x55,
	0xa5, 0x67, 0x9a, 0x2d, 0xcc, 0xa8, 0xea, 0x8d, 0xab, 0xb1, 0xdd, 0x14, 0xd9, 0x8e, 0x4b, 0x1e,
	0x83, 0xa0, 0x93, 0x53, 0x33, 0xb0, 0x55, 0xe0, 0x25, 0x4f, 0x70, 0x69, 0x1f, 0x10, 0x2f, 0xfc,
	0x25, 0x12, 0x6f, 0xa6, 0xf0, 0x67, 0xfd, 0x5a, 0x11, 0xfb, 0xf5, 0x59, 0xd2, 0x0e, 0xca, 0x52,
	0xde, 0x80, 0x8c, 0x17, 0x36, 0xe4, 0xbc, 0xcc, 0xb5, 0x92, 0xcc, 0x85, 0x26, 0x52, 0x9f, 0xde,
	0x44, 0x1a, 0x33, 0x84, 0x6e, 0x5e, 0x4d, 0x68, 0xc8, 0xa5, 0xd5, 0x13, 0x68, 0x59, 0xa6, 0x6b,
	0x11, 0xc7, 0x88, 0xfc, 0x41, 0x60, 0xda, 0x39, 0x25, 0x8b, 0x6c, 0xa1, 0x8a, 0x44, 0xfa, 0x82,
	0xe0, 0xfe, 0xd4, 0x08, 0x4c, 0x85, 0x2d, 0x68, 0xf6, 0x4d, 0xeb, 0x64, 0x8f, 0xb5, 0x17, 0x1e,
	0x22, 0x73, 0xcc, 0xa5, 0x48, 0xa9, 0x04, 0xc9, 0x55, 0x25, 0x68, 0x46, 0xa2, 0x69, 0x8f, 0x41,
	0x4d, 0x80, 0x96, 0x1b, 0xe2, 0x3c, 0x3b, 0xfd, 0x81, 0x60, 0x6b, 0x5a, 0x80, 0x7f, 0xbd, 0xd1,
	0x0b, 0xbb, 0x5d, 0x9c, 0x4a, 0x81, 0x77, 0x42, 0x5c, 0xf1, 0x28, 0x66, 0x1e, 0xed, 0x13, 0x02,
	0x9c, 0xbb, 0x77, 0x1a, 0x7e, 0x34, 0x3a, 0xae, 0xc8, 0x96, 0xec, 0xae, 0x2e, 0xe5, 0xee, 0xea,
	0x18, 0x94, 0x30, 0x6b, 0xc5, 0xec, 0x3b, 0xf7, 0xb8, 0x50, 0xe6, 0x7c, 0x5c, 0x68, 0x2f, 0x01,
	0x0f, 0x48, 0x98, 0x5d, 0xb3, 0xf9, 0xad, 0xe3, 0x72, 0x15, 0xdd, 0x81, 0xf5, 0x72, 0xac, 0x29,
	0x65, 0xe0, 0x69, 0xf6, 0x36, 0x1a, 0xed, 0x25, 0xd7, 0x9e, 0x18, 0xb2, 0x5a, 0x01, 0x99, 0xc5,
	0xd1, 0x0b, 0xe3, 0xb5, 0x03, 0x58, 0x0f, 0x88, 0x45, 0xe8, 0x98, 0x5c, 0x0f, 0xfa, 0x8f, 0x08,
	0x36, 0xab, 0x03, 0x5e, 0xf8, 0xf6, 0x10, 0x0e, 0xcc, 0x9e, 0x70, 0x7d, 0xcb, 0x3b, 0x71, 0x17,
	0xfe, 0x67, 0xa1, 0x5e, 0x17, 0xd3, 0xa3, 0xe8, 0xd6, 0x9e, 0xc3, 0xaa, 0x69, 0x85, 0x31, 0x88,
	0x41, 0xe0, 0x45, 0xbe, 0x11, 0x57, 0x09, 0xac, 0xc2, 0x02, 0xb3, 0x26, 0x6f, 0xb6, 0xd4, 0x9c,
	0xf6, 0x38, 0xd4, 0x1e, 0xc6, 0xbd, 0xa1, 0x10, 0x86, 0xed, 0x63, 0x6a, 0xa8, 0x67, 0x4b, 0x3f,
	0xcf, 0xdb, 0xe8, 0xd7, 0x79, 0x1b, 0xfd, 0x39, 0x6f, 0xa3, 0x7e, 0x9d, 0xe9, 0xb0, 0xf3, 0x37,
	0x00, 0x00, 0xff, 0xff, 0xca, 0xe7, 0x0d, 0x91, 0xef, 0x0e, 0x00, 0x00,
}
