// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: aacommon.proto

/*
	Package protocol is a generated protocol buffer package.

	It is generated from these files:
		aacommon.proto
		bag.proto
		bblogin.proto
		believer.proto
		building.proto
		community.proto
		event.proto
		eventtask.proto
		internal.proto
		log_model.proto
		mail.proto
		moments.proto
		protocol.proto
		rank.proto
		role.proto
		search.proto
		shop.proto
		star.proto
		statistics.proto
		trade.proto

	It has these top-level messages:
		ResultPush
		KickOff
		HeartBeat
		HeartBeatRet
		KickoffPush
		RoleInfo
		BuildingInfo
		BuildingFaith
		BelieverCost
		LevelInfo
		FlagInfo
		BuildingBuffInfo
		BelieverInfo
		StarInfoDetail
		CivilizationReward
		CivilizationInfo
		Statistics
		BagItem
		Reward
		InviteType
		GetTempItem
		GetTempItemRet
		TakeinBag
		TakeinBagRet
		GetBagItem
		GetBagItemRet
		ActiveGroup
		ActiveGroupRet
		ItemGroupOpenPush
		ItemGroup
		ItemGroupRecord
		GetItemGroup
		GetItemGroupRet
		GetGroupReward
		GetGroupRewardRet
		GetCurrentGroup
		GetCurrentGroupRet
		LoginRegister
		LoginRegisterRet
		LoginLogin
		LoginLoginRet
		LoginServer
		LoginSeverRet
		ChannelLogin
		ChannelLoginRet
		ChangeUserState
		ChangeUserStateRet
		TransferRemoteUserSession
		TransferRemoteUserSessionRet
		RefreshClientVersion
		RefreshClientVersionRet
		WechatEventPush
		CleanTestAccount
		CleanTestAccountRet
		QueryByUsername
		QueryByUsernameRet
		AutoAddBeliever
		AutoAddBelieverRet
		UpdateBelieverInfo
		UpdateBelieverInfoRet
		UpgradeBeliever
		UpgradeBelieverRet
		UpdateBeliever
		UpdateBelieverRet
		BelieverFlagInfo
		BelieverFlagInfoRet
		BelieverPush
		BuildingReset
		BuildStarBuilding
		BuildStarBuildingRet
		AccRepairStarBuild
		AccRepairStarBuildRet
		RepairStarBuild
		RepairStarBuildRet
		RepairStarBuildEnd
		RepairStarBuildEndRet
		UpdateStarBuildEnd
		UpdateStarBuildEndRet
		AccUpdateStarBuild
		AccUpdateStarBuildRet
		CancelUpgradeStarBuild
		CancelUpgradeStarBuildRet
		CancelRepairStarBuild
		CancelRepairStarBuildRet
		BuildingInfoPush
		GetBuildingFaith
		GetBuildingFaithRet
		ReceiveBuildingFaith
		ReceiveBuildingFaithRet
		ActiveGroupItem
		ActiveGroupItemRet
		UserInfo
		FriendRequestInfo
		UserDetailInfo
		SearchUser
		SearchUserRet
		GetFriendList
		GetFriendListRet
		GetFriendDetailInfo
		GetFriendDetailInfoRet
		DeleteFriend
		DeleteFriendRet
		GetFriendRequestList
		GetFriendRequestListRet
		AddFriendRequest
		AddFriendRequestRet
		AcceptFriendRequest
		AcceptFriendRequestRet
		RefuseFriendRequest
		RefuseFriendRequestRet
		Follow
		FollowRet
		Unfollow
		UnfollowRet
		GetFollowerList
		GetFollowerListRet
		GetFollowingList
		GetFollowingListRet
		FollowEach
		GetFollowState
		GetFollowStateRet
		Sale
		PublicSale
		PublicSaleRet
		CancelSale
		CancelSaleRet
		BuySale
		BuySaleRet
		GetSaleInfo
		GetSaleInfoRet
		Stranger
		GetStrangerList
		GetStrangerListRet
		SearchResult
		SearchItem
		SearchItemRet
		NewsFeed
		NewsFeedDetail
		AttackStatistics
		ReadNewsfeed
		ReadNewsfeedRet
		GetNewsfeedDetail
		GetNewsfeedDetailRet
		GetNewsfeedList
		GetNewsfeedListRet
		GetOfflineNewsfeedList
		GetOfflineNewsfeedListRet
		GetDealList
		GetDealListRet
		RequestItem
		RequestItemRet
		LootItem
		LootItemRet
		LootStarBeliever
		LootStarBelieverRet
		AcceptItemRequest
		AcceptItemRequestRet
		RejectItemRequest
		RejectItemRequestRet
		ItemRequestOverdue
		ItemRequestOverdueRet
		FollowPush
		RefuseFriendPush
		DeleteFriendPush
		AddSale
		AddSaleRet
		RemoveSale
		RemoveSaleRet
		GetSale
		GetSaleRet
		GetSales
		GetSalesRet
		GlobalMessage
		LampMessage
		NoticeMessage
		PublicShare
		PublicShareRet
		PublicWechatShare
		PublicWechatShareRet
		DrawWechatShareReward
		DrawWechatShareRewardRet
		GetWechatShareTime
		GetWechatShareTimeRet
		WatchAdSuccess
		WatchAdSuccessRet
		GuideRevengeRet
		GetGlobalMessageRet
		DrawDayGift
		DrawDayGiftRet
		EventMember
		Event
		Event_Module
		DisplayStarUidPush
		GetEventModule
		GetEventModuleRet
		DoneEventStep
		DoneEventStepRet
		EventStepPush
		GetEvent
		GetEventRet
		Module_Display
		Module_Storyboard
		Module_Random_Target
		RandomTarget
		RandomTargetRet
		OpenCard
		OpenCardRet
		CardReward
		RandomGuideRobot
		RandomGuideRobotRet
		RandomEventRobot
		RandomEventRobotRet
		GetEventRobot
		GetEventRobotRet
		Target
		SelectEventTarget
		SelectEventTargetRet
		Module_Recruit
		PublicEvent
		PublicEventRet
		AssistEventRequest
		AssistEventRequestRet
		AssistEventRequestList
		AssistEventRequestListRet
		AssistEventRequestPush
		RejectAssistEvent
		RejectAssistEventRet
		AcceptAssistEvent
		AcceptAssistEventRet
		AssistResultPush
		Module_Buff
		EventField
		UpdateEventField
		UpdateEventFieldRet
		EventFieldPush
		Module_Switch_Star
		GetFaith
		GetFaithRet
		GetBeliever
		GetBelieverRet
		LootFaith
		LootFaithRet
		AtkStarBuilding
		AtkStarBuildingRet
		LootBeliever
		LootBelieverRet
		IntoEvent
		IntoEventRet
		LeaveEvent
		LeaveEventRet
		PublicVote
		PublicVoteRet
		AddEventVote
		AddEventVoteRet
		VoteFinishPush
		VotePush
		Vote
		DataFlag
		SaveData
		SaveDataRet
		GenEvent
		GenEventRet
		EventFieldChange
		RemoveEvent
		EventDone
		EventDoneRet
		Task
		RandomEventTask
		RandomEventTaskRet
		RandomRevengeTask
		RandomRevengeTaskRet
		GetTaskList
		GetTaskListRet
		TriggerTask
		TriggerTaskRet
		SetTaskEnding
		SetTaskEndingRet
		RandomDial
		RandomDialRet
		MultipleDialReward
		MultipleDialRewardRet
		AddAttach
		AddAttachRet
		SetBuildings
		SetBuildingsRet
		SetBelievers
		SetBelieversRet
		AddLog
		OrderRecord
		Mail
		Attach
		GetMail
		GetMailRet
		GetAllMail
		GetAllMailRet
		DrawMail
		DrawMailRet
		RemoveMail
		RemoveMailRet
		CreateMail
		CreateMailRet
		Notice
		GetOnNotices
		GetOnNoticesRet
		MomentInfo
		GetUserDetail
		GetUserDetailRet
		UserDetail
		PublicMoment
		PublicMomentRet
		RemoveMoments
		RemoveMomentsRet
		GetReceiveMoments
		GetReceiveMomentsRet
		GetPublicMoments
		GetPublicMomentsRet
		C2GS
		UserPush
		GS2C
		GetRankInfo
		GetRankInfoRet
		Rank
		ScorePush
		CreateRole
		CreateRoleRet
		GetAvatar
		GetAvatarRet
		GetRoleInfo
		GetRoleInfoRet
		JoinGame
		JoinGameRet
		LeaveGame
		LeaveGameRet
		RoleInfoPush
		RolePowerPush
		RoleFlagInfo
		RoleFlagInfoRet
		UpdateFlag
		UpdateFlagRet
		RoleDisplayInfo
		RoleDisplayInfoRet
		UpdateDisplay
		UpdateDisplayRet
		UpdatePower
		UpdatePowerRet
		DayGiftStatus
		DayGiftStatusRet
		CorrectCivilReward
		CorrectCivilRewardRet
		UpdateUnlockFlag
		UpdateUnlockFlagRet
		QueryByNickname
		QueryByNicknameRet
		UpdateSearchData
		UpdateRandomStar
		StarOpt
		UpdateSearchHelpData
		RandomHelpTarget
		RandomHelpTargetRet
		BuyShopItem
		BuyShopItemRet
		GenOrder
		GenOrderRet
		RefreshMallItem
		RefreshMallItemRet
		BuyMallItem
		BuyMallItemRet
		GetMallItem
		GetMallItemRet
		AutoRefreshMallItem
		AutoRefreshMallItemRet
		MallItem
		StarInfoBase
		TransmitUserStar
		TransmitUserStarRet
		HelpRepairBuildPublic
		HelpRepairBuildPublicRet
		LoginStarInfo
		LoginStarInfoRet
		BuildingState
		StarInfo
		GetStarsSelect
		GetStarsSelectRet
		SelectStar
		SelectStarRet
		GetStarInfo
		GetStarInfoRet
		GetStarShield
		GetStarShieldRet
		Shield
		OpenStarPush
		SearchStarInfo
		SearchStarInfoRet
		GetStarInfoDetail
		GetStarRecordInfo
		SetStarRecordInfo
		DelStarRecordInfo
		ReplaceStarRecordInfo
		MoveStarRecordInfo
		OccupyStar
		GetHelpRepairInfo
		GetHelpRepairInfoRet
		HelpRepairBuildInfo
		HelpRepairBuild
		HelpRepairBuildRet
		GetCurrentGroupItems
		GetCurrentGroupItemsRet
		GetEventStarInfo
		GetEventStarInfoRet
		AllocNewStar
		AllocNewStarRet
		UserStarInfo
		UserStarInfoRet
		GetStarInfoDetailRet
		GetStarInfoCompleteRet
		GetStarRecordInfoRet
		SetStarRecordInfoRet
		DelStarRecordInfoRet
		ReplaceStarRecordInfoRet
		MoveStarRecordInfoRet
		OccupyStarRet
		AddCivilization
		DrawCivilizationReward
		DrawCivilizationRewardRet
		StarSettle
		StarSettleRet
		StarFlagInfo
		StarFlagInfoRet
		UpdateStarFlag
		UpdateStarFlagRet
		UpdateAllStarFlag
		UpdateAllStarFlagRet
		GetOwnersByCondition
		GetOwnersByConditionRet
		UserStarData
		GetStarStatistics
		GetStarStatisticsRet
		UpdateStarStatistics
		UpdateStarStatisticsRet
		GetStarHistory
		GetStarHistoryRet
		History
		Goods
		GetGoodsInfo
		GetGoodsInfoRet
		BuyGoods
		BuyGoodsRet
		PublicGoods
		PublicGoodsRet
		CancelGoods
		CancelGoodsRet
		PublicItemHelp
		PublicItemHelpRet
		CancelItemHelp
		CancelItemHelpRet
		DrawItemHelp
		DrawItemHelpRet
		GetItemHelp
		GetItemHelpRet
		LootHelpItem
		LootHelpItemRet
		HelpItem
		HelpItemRet
		GetHelpItemHistory
		GetHelpItemHistoryRet
		ItemHelp
		ItemEvent
*/
package protocol

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// 所有业务失败返回结果(推送)
type ResultPush struct {
	Result int32  `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
	Attach int32  `protobuf:"varint,2,opt,name=attach,proto3" json:"attach,omitempty"`
	Msg    string `protobuf:"bytes,3,opt,name=msg,proto3" json:"msg,omitempty"`
}

func (m *ResultPush) Reset()                    { *m = ResultPush{} }
func (m *ResultPush) String() string            { return proto.CompactTextString(m) }
func (*ResultPush) ProtoMessage()               {}
func (*ResultPush) Descriptor() ([]byte, []int) { return fileDescriptorAacommon, []int{0} }

func (m *ResultPush) GetResult() int32 {
	if m != nil {
		return m.Result
	}
	return 0
}

func (m *ResultPush) GetAttach() int32 {
	if m != nil {
		return m.Attach
	}
	return 0
}

func (m *ResultPush) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

type KickOff struct {
	Uid      int32 `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
	KickType int32 `protobuf:"varint,2,opt,name=kickType,proto3" json:"kickType,omitempty"`
}

func (m *KickOff) Reset()                    { *m = KickOff{} }
func (m *KickOff) String() string            { return proto.CompactTextString(m) }
func (*KickOff) ProtoMessage()               {}
func (*KickOff) Descriptor() ([]byte, []int) { return fileDescriptorAacommon, []int{1} }

func (m *KickOff) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *KickOff) GetKickType() int32 {
	if m != nil {
		return m.KickType
	}
	return 0
}

// 心跳包,客户端每隔一段时间发送请求
type HeartBeat struct {
}

func (m *HeartBeat) Reset()                    { *m = HeartBeat{} }
func (m *HeartBeat) String() string            { return proto.CompactTextString(m) }
func (*HeartBeat) ProtoMessage()               {}
func (*HeartBeat) Descriptor() ([]byte, []int) { return fileDescriptorAacommon, []int{2} }

// 心跳包返回
type HeartBeatRet struct {
}

func (m *HeartBeatRet) Reset()                    { *m = HeartBeatRet{} }
func (m *HeartBeatRet) String() string            { return proto.CompactTextString(m) }
func (*HeartBeatRet) ProtoMessage()               {}
func (*HeartBeatRet) Descriptor() ([]byte, []int) { return fileDescriptorAacommon, []int{3} }

// 被服务器踢下线推送,长时间没操作结果
type KickoffPush struct {
	Type int32 `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`
}

func (m *KickoffPush) Reset()                    { *m = KickoffPush{} }
func (m *KickoffPush) String() string            { return proto.CompactTextString(m) }
func (*KickoffPush) ProtoMessage()               {}
func (*KickoffPush) Descriptor() ([]byte, []int) { return fileDescriptorAacommon, []int{4} }

func (m *KickoffPush) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

// 角色信息
type RoleInfo struct {
	Id int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// int32  icon = 2;    //角色图标
	Nickname string `protobuf:"bytes,3,opt,name=nickname,proto3" json:"nickname,omitempty"`
	Level    int32  `protobuf:"varint,4,opt,name=level,proto3" json:"level,omitempty"`
	Exp      int32  `protobuf:"varint,5,opt,name=exp,proto3" json:"exp,omitempty"`
	Power    int32  `protobuf:"varint,6,opt,name=power,proto3" json:"power,omitempty"`
	//    int32  limit = 7;  //角色的法力值上限
	Faith           int32 `protobuf:"varint,8,opt,name=faith,proto3" json:"faith,omitempty"`
	UpdateTimestamp int64 `protobuf:"varint,9,opt,name=updateTimestamp,proto3" json:"updateTimestamp,omitempty"`
	//    int32  starID = 10;//星球id
	//    int32  starType = 11;//星球类型
	Diamond    int32 `protobuf:"varint,12,opt,name=diamond,proto3" json:"diamond,omitempty"`
	PowerLimit int32 `protobuf:"varint,13,opt,name=powerLimit,proto3" json:"powerLimit,omitempty"`
	// repeated int32  flag = 14;    //1是否有消息面板新内容  2是否有好友面板新内容 3是否播放过开场动画
	// repeated int32  value = 15;   //0 代表没有
	Flag      []*FlagInfo `protobuf:"bytes,14,rep,name=flag" json:"flag,omitempty"`
	GayPoint  int32       `protobuf:"varint,16,opt,name=gayPoint,proto3" json:"gayPoint,omitempty"`
	Desc      string      `protobuf:"bytes,17,opt,name=desc,proto3" json:"desc,omitempty"`
	Avatar    string      `protobuf:"bytes,18,opt,name=avatar,proto3" json:"avatar,omitempty"`
	Subscribe bool        `protobuf:"varint,19,opt,name=subscribe,proto3" json:"subscribe,omitempty"`
}

func (m *RoleInfo) Reset()                    { *m = RoleInfo{} }
func (m *RoleInfo) String() string            { return proto.CompactTextString(m) }
func (*RoleInfo) ProtoMessage()               {}
func (*RoleInfo) Descriptor() ([]byte, []int) { return fileDescriptorAacommon, []int{5} }

func (m *RoleInfo) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *RoleInfo) GetNickname() string {
	if m != nil {
		return m.Nickname
	}
	return ""
}

func (m *RoleInfo) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *RoleInfo) GetExp() int32 {
	if m != nil {
		return m.Exp
	}
	return 0
}

func (m *RoleInfo) GetPower() int32 {
	if m != nil {
		return m.Power
	}
	return 0
}

func (m *RoleInfo) GetFaith() int32 {
	if m != nil {
		return m.Faith
	}
	return 0
}

func (m *RoleInfo) GetUpdateTimestamp() int64 {
	if m != nil {
		return m.UpdateTimestamp
	}
	return 0
}

func (m *RoleInfo) GetDiamond() int32 {
	if m != nil {
		return m.Diamond
	}
	return 0
}

func (m *RoleInfo) GetPowerLimit() int32 {
	if m != nil {
		return m.PowerLimit
	}
	return 0
}

func (m *RoleInfo) GetFlag() []*FlagInfo {
	if m != nil {
		return m.Flag
	}
	return nil
}

func (m *RoleInfo) GetGayPoint() int32 {
	if m != nil {
		return m.GayPoint
	}
	return 0
}

func (m *RoleInfo) GetDesc() string {
	if m != nil {
		return m.Desc
	}
	return ""
}

func (m *RoleInfo) GetAvatar() string {
	if m != nil {
		return m.Avatar
	}
	return ""
}

func (m *RoleInfo) GetSubscribe() bool {
	if m != nil {
		return m.Subscribe
	}
	return false
}

// 建筑信息
type BuildingInfo struct {
	Id         int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Type       int32 `protobuf:"varint,2,opt,name=type,proto3" json:"type,omitempty"`
	Level      int32 `protobuf:"varint,3,opt,name=Level,proto3" json:"Level,omitempty"`
	RepairTime int64 `protobuf:"varint,4,opt,name=repairTime,proto3" json:"repairTime,omitempty"`
	UpdateTime int64 `protobuf:"varint,5,opt,name=updateTime,proto3" json:"updateTime,omitempty"`
	BrokenTime int64 `protobuf:"varint,6,opt,name=brokenTime,proto3" json:"brokenTime,omitempty"`
	// repeated item_groove itemGrooves = 9; //当前建筑的圣物槽
	Exist     bool         `protobuf:"varint,10,opt,name=exist,proto3" json:"exist,omitempty"`
	BuffID    []int32      `protobuf:"varint,11,rep,packed,name=buffID" json:"buffID,omitempty"`
	BuffNum   []int32      `protobuf:"varint,12,rep,packed,name=buffNum" json:"buffNum,omitempty"`
	LevelInfo []*LevelInfo `protobuf:"bytes,14,rep,name=levelInfo" json:"levelInfo,omitempty"`
}

func (m *BuildingInfo) Reset()                    { *m = BuildingInfo{} }
func (m *BuildingInfo) String() string            { return proto.CompactTextString(m) }
func (*BuildingInfo) ProtoMessage()               {}
func (*BuildingInfo) Descriptor() ([]byte, []int) { return fileDescriptorAacommon, []int{6} }

func (m *BuildingInfo) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *BuildingInfo) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *BuildingInfo) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *BuildingInfo) GetRepairTime() int64 {
	if m != nil {
		return m.RepairTime
	}
	return 0
}

func (m *BuildingInfo) GetUpdateTime() int64 {
	if m != nil {
		return m.UpdateTime
	}
	return 0
}

func (m *BuildingInfo) GetBrokenTime() int64 {
	if m != nil {
		return m.BrokenTime
	}
	return 0
}

func (m *BuildingInfo) GetExist() bool {
	if m != nil {
		return m.Exist
	}
	return false
}

func (m *BuildingInfo) GetBuffID() []int32 {
	if m != nil {
		return m.BuffID
	}
	return nil
}

func (m *BuildingInfo) GetBuffNum() []int32 {
	if m != nil {
		return m.BuffNum
	}
	return nil
}

func (m *BuildingInfo) GetLevelInfo() []*LevelInfo {
	if m != nil {
		return m.LevelInfo
	}
	return nil
}

type BuildingFaith struct {
	BuildingType    int32 `protobuf:"varint,1,opt,name=buildingType,proto3" json:"buildingType,omitempty"`
	BuildingFaith   int32 `protobuf:"varint,2,opt,name=buildingFaith,proto3" json:"buildingFaith,omitempty"`
	FaithUpdateTime int64 `protobuf:"varint,3,opt,name=faithUpdateTime,proto3" json:"faithUpdateTime,omitempty"`
}

func (m *BuildingFaith) Reset()                    { *m = BuildingFaith{} }
func (m *BuildingFaith) String() string            { return proto.CompactTextString(m) }
func (*BuildingFaith) ProtoMessage()               {}
func (*BuildingFaith) Descriptor() ([]byte, []int) { return fileDescriptorAacommon, []int{7} }

func (m *BuildingFaith) GetBuildingType() int32 {
	if m != nil {
		return m.BuildingType
	}
	return 0
}

func (m *BuildingFaith) GetBuildingFaith() int32 {
	if m != nil {
		return m.BuildingFaith
	}
	return 0
}

func (m *BuildingFaith) GetFaithUpdateTime() int64 {
	if m != nil {
		return m.FaithUpdateTime
	}
	return 0
}

type BelieverCost struct {
	BelieverID string `protobuf:"bytes,1,opt,name=believerID,proto3" json:"believerID,omitempty"`
	Num        int32  `protobuf:"varint,2,opt,name=num,proto3" json:"num,omitempty"`
}

func (m *BelieverCost) Reset()                    { *m = BelieverCost{} }
func (m *BelieverCost) String() string            { return proto.CompactTextString(m) }
func (*BelieverCost) ProtoMessage()               {}
func (*BelieverCost) Descriptor() ([]byte, []int) { return fileDescriptorAacommon, []int{8} }

func (m *BelieverCost) GetBelieverID() string {
	if m != nil {
		return m.BelieverID
	}
	return ""
}

func (m *BelieverCost) GetNum() int32 {
	if m != nil {
		return m.Num
	}
	return 0
}

type LevelInfo struct {
	Level        int32           `protobuf:"varint,1,opt,name=level,proto3" json:"level,omitempty"`
	Time         int64           `protobuf:"varint,2,opt,name=time,proto3" json:"time,omitempty"`
	BelieverCost []*BelieverCost `protobuf:"bytes,3,rep,name=believerCost" json:"believerCost,omitempty"`
	FaithCost    int32           `protobuf:"varint,4,opt,name=faithCost,proto3" json:"faithCost,omitempty"`
}

func (m *LevelInfo) Reset()                    { *m = LevelInfo{} }
func (m *LevelInfo) String() string            { return proto.CompactTextString(m) }
func (*LevelInfo) ProtoMessage()               {}
func (*LevelInfo) Descriptor() ([]byte, []int) { return fileDescriptorAacommon, []int{9} }

func (m *LevelInfo) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *LevelInfo) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *LevelInfo) GetBelieverCost() []*BelieverCost {
	if m != nil {
		return m.BelieverCost
	}
	return nil
}

func (m *LevelInfo) GetFaithCost() int32 {
	if m != nil {
		return m.FaithCost
	}
	return 0
}

type FlagInfo struct {
	Id    int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Value int32 `protobuf:"varint,2,opt,name=value,proto3" json:"value,omitempty"`
	Time  int64 `protobuf:"varint,3,opt,name=time,proto3" json:"time,omitempty"`
}

func (m *FlagInfo) Reset()                    { *m = FlagInfo{} }
func (m *FlagInfo) String() string            { return proto.CompactTextString(m) }
func (*FlagInfo) ProtoMessage()               {}
func (*FlagInfo) Descriptor() ([]byte, []int) { return fileDescriptorAacommon, []int{10} }

func (m *FlagInfo) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *FlagInfo) GetValue() int32 {
	if m != nil {
		return m.Value
	}
	return 0
}

func (m *FlagInfo) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

// 建筑信息
type BuildingBuffInfo struct {
	Type    int32   `protobuf:"varint,2,opt,name=type,proto3" json:"type,omitempty"`
	BuffID  []int32 `protobuf:"varint,11,rep,packed,name=buffID" json:"buffID,omitempty"`
	BuffNum []int32 `protobuf:"varint,12,rep,packed,name=buffNum" json:"buffNum,omitempty"`
}

func (m *BuildingBuffInfo) Reset()                    { *m = BuildingBuffInfo{} }
func (m *BuildingBuffInfo) String() string            { return proto.CompactTextString(m) }
func (*BuildingBuffInfo) ProtoMessage()               {}
func (*BuildingBuffInfo) Descriptor() ([]byte, []int) { return fileDescriptorAacommon, []int{11} }

func (m *BuildingBuffInfo) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *BuildingBuffInfo) GetBuffID() []int32 {
	if m != nil {
		return m.BuffID
	}
	return nil
}

func (m *BuildingBuffInfo) GetBuffNum() []int32 {
	if m != nil {
		return m.BuffNum
	}
	return nil
}

type BelieverInfo struct {
	Id  string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Num int32  `protobuf:"varint,2,opt,name=num,proto3" json:"num,omitempty"`
}

func (m *BelieverInfo) Reset()                    { *m = BelieverInfo{} }
func (m *BelieverInfo) String() string            { return proto.CompactTextString(m) }
func (*BelieverInfo) ProtoMessage()               {}
func (*BelieverInfo) Descriptor() ([]byte, []int) { return fileDescriptorAacommon, []int{12} }

func (m *BelieverInfo) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *BelieverInfo) GetNum() int32 {
	if m != nil {
		return m.Num
	}
	return 0
}

// 星球信息( 详细 ) @brief wjl 20170601 新增
type StarInfoDetail struct {
	StarID               int32                 `protobuf:"varint,1,opt,name=starID,proto3" json:"starID,omitempty"`
	Type                 int32                 `protobuf:"varint,2,opt,name=type,proto3" json:"type,omitempty"`
	OwnID                int32                 `protobuf:"varint,3,opt,name=ownID,proto3" json:"ownID,omitempty"`
	Building             []*BuildingInfo       `protobuf:"bytes,4,rep,name=building" json:"building,omitempty"`
	Believer             []*BelieverInfo       `protobuf:"bytes,5,rep,name=believer" json:"believer,omitempty"`
	CreateTime           int64                 `protobuf:"varint,6,opt,name=createTime,proto3" json:"createTime,omitempty"`
	DoneTime             int64                 `protobuf:"varint,7,opt,name=doneTime,proto3" json:"doneTime,omitempty"`
	Seq                  int32                 `protobuf:"varint,8,opt,name=seq,proto3" json:"seq,omitempty"`
	CivilizationLv       int32                 `protobuf:"varint,19,opt,name=civilizationLv,proto3" json:"civilizationLv,omitempty"`
	CivilizationProgress int32                 `protobuf:"varint,20,opt,name=civilizationProgress,proto3" json:"civilizationProgress,omitempty"`
	CivilizationReward   []*CivilizationReward `protobuf:"bytes,21,rep,name=civilizationReward" json:"civilizationReward,omitempty"`
	StarFlags            []*FlagInfo           `protobuf:"bytes,22,rep,name=starFlags" json:"starFlags,omitempty"`
}

func (m *StarInfoDetail) Reset()                    { *m = StarInfoDetail{} }
func (m *StarInfoDetail) String() string            { return proto.CompactTextString(m) }
func (*StarInfoDetail) ProtoMessage()               {}
func (*StarInfoDetail) Descriptor() ([]byte, []int) { return fileDescriptorAacommon, []int{13} }

func (m *StarInfoDetail) GetStarID() int32 {
	if m != nil {
		return m.StarID
	}
	return 0
}

func (m *StarInfoDetail) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *StarInfoDetail) GetOwnID() int32 {
	if m != nil {
		return m.OwnID
	}
	return 0
}

func (m *StarInfoDetail) GetBuilding() []*BuildingInfo {
	if m != nil {
		return m.Building
	}
	return nil
}

func (m *StarInfoDetail) GetBeliever() []*BelieverInfo {
	if m != nil {
		return m.Believer
	}
	return nil
}

func (m *StarInfoDetail) GetCreateTime() int64 {
	if m != nil {
		return m.CreateTime
	}
	return 0
}

func (m *StarInfoDetail) GetDoneTime() int64 {
	if m != nil {
		return m.DoneTime
	}
	return 0
}

func (m *StarInfoDetail) GetSeq() int32 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *StarInfoDetail) GetCivilizationLv() int32 {
	if m != nil {
		return m.CivilizationLv
	}
	return 0
}

func (m *StarInfoDetail) GetCivilizationProgress() int32 {
	if m != nil {
		return m.CivilizationProgress
	}
	return 0
}

func (m *StarInfoDetail) GetCivilizationReward() []*CivilizationReward {
	if m != nil {
		return m.CivilizationReward
	}
	return nil
}

func (m *StarInfoDetail) GetStarFlags() []*FlagInfo {
	if m != nil {
		return m.StarFlags
	}
	return nil
}

type CivilizationReward struct {
	Level int32 `protobuf:"varint,1,opt,name=level,proto3" json:"level,omitempty"`
	Draw  bool  `protobuf:"varint,2,opt,name=draw,proto3" json:"draw,omitempty"`
}

func (m *CivilizationReward) Reset()                    { *m = CivilizationReward{} }
func (m *CivilizationReward) String() string            { return proto.CompactTextString(m) }
func (*CivilizationReward) ProtoMessage()               {}
func (*CivilizationReward) Descriptor() ([]byte, []int) { return fileDescriptorAacommon, []int{14} }

func (m *CivilizationReward) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *CivilizationReward) GetDraw() bool {
	if m != nil {
		return m.Draw
	}
	return false
}

type CivilizationInfo struct {
	StarID               int32 `protobuf:"varint,1,opt,name=starID,proto3" json:"starID,omitempty"`
	StarSeq              int32 `protobuf:"varint,2,opt,name=starSeq,proto3" json:"starSeq,omitempty"`
	CivilizationLv       int32 `protobuf:"varint,3,opt,name=civilizationLv,proto3" json:"civilizationLv,omitempty"`
	CivilizationProgress int32 `protobuf:"varint,4,opt,name=civilizationProgress,proto3" json:"civilizationProgress,omitempty"`
}

func (m *CivilizationInfo) Reset()                    { *m = CivilizationInfo{} }
func (m *CivilizationInfo) String() string            { return proto.CompactTextString(m) }
func (*CivilizationInfo) ProtoMessage()               {}
func (*CivilizationInfo) Descriptor() ([]byte, []int) { return fileDescriptorAacommon, []int{15} }

func (m *CivilizationInfo) GetStarID() int32 {
	if m != nil {
		return m.StarID
	}
	return 0
}

func (m *CivilizationInfo) GetStarSeq() int32 {
	if m != nil {
		return m.StarSeq
	}
	return 0
}

func (m *CivilizationInfo) GetCivilizationLv() int32 {
	if m != nil {
		return m.CivilizationLv
	}
	return 0
}

func (m *CivilizationInfo) GetCivilizationProgress() int32 {
	if m != nil {
		return m.CivilizationProgress
	}
	return 0
}

type Statistics struct {
	Id    int32   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Value float64 `protobuf:"fixed64,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *Statistics) Reset()                    { *m = Statistics{} }
func (m *Statistics) String() string            { return proto.CompactTextString(m) }
func (*Statistics) ProtoMessage()               {}
func (*Statistics) Descriptor() ([]byte, []int) { return fileDescriptorAacommon, []int{16} }

func (m *Statistics) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Statistics) GetValue() float64 {
	if m != nil {
		return m.Value
	}
	return 0
}

// 物品
type BagItem struct {
	Id   int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Num  int32 `protobuf:"varint,2,opt,name=num,proto3" json:"num,omitempty"`
	Time int64 `protobuf:"varint,3,opt,name=time,proto3" json:"time,omitempty"`
}

func (m *BagItem) Reset()                    { *m = BagItem{} }
func (m *BagItem) String() string            { return proto.CompactTextString(m) }
func (*BagItem) ProtoMessage()               {}
func (*BagItem) Descriptor() ([]byte, []int) { return fileDescriptorAacommon, []int{17} }

func (m *BagItem) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *BagItem) GetNum() int32 {
	if m != nil {
		return m.Num
	}
	return 0
}

func (m *BagItem) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

type Reward struct {
	Faith    int32           `protobuf:"varint,1,opt,name=faith,proto3" json:"faith,omitempty"`
	Believer []*BelieverInfo `protobuf:"bytes,2,rep,name=believer" json:"believer,omitempty"`
	ItemID   int32           `protobuf:"varint,3,opt,name=itemID,proto3" json:"itemID,omitempty"`
	GayPoint int32           `protobuf:"varint,4,opt,name=gayPoint,proto3" json:"gayPoint,omitempty"`
	Diamond  int32           `protobuf:"varint,5,opt,name=diamond,proto3" json:"diamond,omitempty"`
	Power    int32           `protobuf:"varint,6,opt,name=power,proto3" json:"power,omitempty"`
}

func (m *Reward) Reset()                    { *m = Reward{} }
func (m *Reward) String() string            { return proto.CompactTextString(m) }
func (*Reward) ProtoMessage()               {}
func (*Reward) Descriptor() ([]byte, []int) { return fileDescriptorAacommon, []int{18} }

func (m *Reward) GetFaith() int32 {
	if m != nil {
		return m.Faith
	}
	return 0
}

func (m *Reward) GetBeliever() []*BelieverInfo {
	if m != nil {
		return m.Believer
	}
	return nil
}

func (m *Reward) GetItemID() int32 {
	if m != nil {
		return m.ItemID
	}
	return 0
}

func (m *Reward) GetGayPoint() int32 {
	if m != nil {
		return m.GayPoint
	}
	return 0
}

func (m *Reward) GetDiamond() int32 {
	if m != nil {
		return m.Diamond
	}
	return 0
}

func (m *Reward) GetPower() int32 {
	if m != nil {
		return m.Power
	}
	return 0
}

type InviteType struct {
	Type    int32 `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`
	RefType int32 `protobuf:"varint,2,opt,name=refType,proto3" json:"refType,omitempty"`
	RefNum  int32 `protobuf:"varint,3,opt,name=refNum,proto3" json:"refNum,omitempty"`
}

func (m *InviteType) Reset()                    { *m = InviteType{} }
func (m *InviteType) String() string            { return proto.CompactTextString(m) }
func (*InviteType) ProtoMessage()               {}
func (*InviteType) Descriptor() ([]byte, []int) { return fileDescriptorAacommon, []int{19} }

func (m *InviteType) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *InviteType) GetRefType() int32 {
	if m != nil {
		return m.RefType
	}
	return 0
}

func (m *InviteType) GetRefNum() int32 {
	if m != nil {
		return m.RefNum
	}
	return 0
}

func init() {
	proto.RegisterType((*ResultPush)(nil), "protocol.result_push")
	proto.RegisterType((*KickOff)(nil), "protocol.kick_off")
	proto.RegisterType((*HeartBeat)(nil), "protocol.heart_beat")
	proto.RegisterType((*HeartBeatRet)(nil), "protocol.heart_beat_ret")
	proto.RegisterType((*KickoffPush)(nil), "protocol.kickoff_push")
	proto.RegisterType((*RoleInfo)(nil), "protocol.role_info")
	proto.RegisterType((*BuildingInfo)(nil), "protocol.building_info")
	proto.RegisterType((*BuildingFaith)(nil), "protocol.building_faith")
	proto.RegisterType((*BelieverCost)(nil), "protocol.believer_cost")
	proto.RegisterType((*LevelInfo)(nil), "protocol.level_info")
	proto.RegisterType((*FlagInfo)(nil), "protocol.flag_info")
	proto.RegisterType((*BuildingBuffInfo)(nil), "protocol.building_buff_info")
	proto.RegisterType((*BelieverInfo)(nil), "protocol.believer_info")
	proto.RegisterType((*StarInfoDetail)(nil), "protocol.star_info_detail")
	proto.RegisterType((*CivilizationReward)(nil), "protocol.civilization_reward")
	proto.RegisterType((*CivilizationInfo)(nil), "protocol.civilization_info")
	proto.RegisterType((*Statistics)(nil), "protocol.Statistics")
	proto.RegisterType((*BagItem)(nil), "protocol.bag_item")
	proto.RegisterType((*Reward)(nil), "protocol.Reward")
	proto.RegisterType((*InviteType)(nil), "protocol.invite_type")
}
func (m *ResultPush) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResultPush) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAacommon(dAtA, i, uint64(m.Result))
	}
	if m.Attach != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAacommon(dAtA, i, uint64(m.Attach))
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAacommon(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	return i, nil
}

func (m *KickOff) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KickOff) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAacommon(dAtA, i, uint64(m.Uid))
	}
	if m.KickType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAacommon(dAtA, i, uint64(m.KickType))
	}
	return i, nil
}

func (m *HeartBeat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeartBeat) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *HeartBeatRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeartBeatRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *KickoffPush) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KickoffPush) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAacommon(dAtA, i, uint64(m.Type))
	}
	return i, nil
}

func (m *RoleInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoleInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAacommon(dAtA, i, uint64(m.Id))
	}
	if len(m.Nickname) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAacommon(dAtA, i, uint64(len(m.Nickname)))
		i += copy(dAtA[i:], m.Nickname)
	}
	if m.Level != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAacommon(dAtA, i, uint64(m.Level))
	}
	if m.Exp != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintAacommon(dAtA, i, uint64(m.Exp))
	}
	if m.Power != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintAacommon(dAtA, i, uint64(m.Power))
	}
	if m.Faith != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintAacommon(dAtA, i, uint64(m.Faith))
	}
	if m.UpdateTimestamp != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintAacommon(dAtA, i, uint64(m.UpdateTimestamp))
	}
	if m.Diamond != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintAacommon(dAtA, i, uint64(m.Diamond))
	}
	if m.PowerLimit != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintAacommon(dAtA, i, uint64(m.PowerLimit))
	}
	if len(m.Flag) > 0 {
		for _, msg := range m.Flag {
			dAtA[i] = 0x72
			i++
			i = encodeVarintAacommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.GayPoint != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintAacommon(dAtA, i, uint64(m.GayPoint))
	}
	if len(m.Desc) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintAacommon(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	if len(m.Avatar) > 0 {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintAacommon(dAtA, i, uint64(len(m.Avatar)))
		i += copy(dAtA[i:], m.Avatar)
	}
	if m.Subscribe {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		if m.Subscribe {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *BuildingInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuildingInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAacommon(dAtA, i, uint64(m.Id))
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAacommon(dAtA, i, uint64(m.Type))
	}
	if m.Level != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAacommon(dAtA, i, uint64(m.Level))
	}
	if m.RepairTime != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAacommon(dAtA, i, uint64(m.RepairTime))
	}
	if m.UpdateTime != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintAacommon(dAtA, i, uint64(m.UpdateTime))
	}
	if m.BrokenTime != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintAacommon(dAtA, i, uint64(m.BrokenTime))
	}
	if m.Exist {
		dAtA[i] = 0x50
		i++
		if m.Exist {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.BuffID) > 0 {
		dAtA2 := make([]byte, len(m.BuffID)*10)
		var j1 int
		for _, num1 := range m.BuffID {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0x5a
		i++
		i = encodeVarintAacommon(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	if len(m.BuffNum) > 0 {
		dAtA4 := make([]byte, len(m.BuffNum)*10)
		var j3 int
		for _, num1 := range m.BuffNum {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		dAtA[i] = 0x62
		i++
		i = encodeVarintAacommon(dAtA, i, uint64(j3))
		i += copy(dAtA[i:], dAtA4[:j3])
	}
	if len(m.LevelInfo) > 0 {
		for _, msg := range m.LevelInfo {
			dAtA[i] = 0x72
			i++
			i = encodeVarintAacommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *BuildingFaith) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuildingFaith) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BuildingType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAacommon(dAtA, i, uint64(m.BuildingType))
	}
	if m.BuildingFaith != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAacommon(dAtA, i, uint64(m.BuildingFaith))
	}
	if m.FaithUpdateTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAacommon(dAtA, i, uint64(m.FaithUpdateTime))
	}
	return i, nil
}

func (m *BelieverCost) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BelieverCost) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.BelieverID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAacommon(dAtA, i, uint64(len(m.BelieverID)))
		i += copy(dAtA[i:], m.BelieverID)
	}
	if m.Num != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAacommon(dAtA, i, uint64(m.Num))
	}
	return i, nil
}

func (m *LevelInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LevelInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Level != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAacommon(dAtA, i, uint64(m.Level))
	}
	if m.Time != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAacommon(dAtA, i, uint64(m.Time))
	}
	if len(m.BelieverCost) > 0 {
		for _, msg := range m.BelieverCost {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintAacommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.FaithCost != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAacommon(dAtA, i, uint64(m.FaithCost))
	}
	return i, nil
}

func (m *FlagInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlagInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAacommon(dAtA, i, uint64(m.Id))
	}
	if m.Value != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAacommon(dAtA, i, uint64(m.Value))
	}
	if m.Time != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAacommon(dAtA, i, uint64(m.Time))
	}
	return i, nil
}

func (m *BuildingBuffInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuildingBuffInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAacommon(dAtA, i, uint64(m.Type))
	}
	if len(m.BuffID) > 0 {
		dAtA6 := make([]byte, len(m.BuffID)*10)
		var j5 int
		for _, num1 := range m.BuffID {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		dAtA[i] = 0x5a
		i++
		i = encodeVarintAacommon(dAtA, i, uint64(j5))
		i += copy(dAtA[i:], dAtA6[:j5])
	}
	if len(m.BuffNum) > 0 {
		dAtA8 := make([]byte, len(m.BuffNum)*10)
		var j7 int
		for _, num1 := range m.BuffNum {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		dAtA[i] = 0x62
		i++
		i = encodeVarintAacommon(dAtA, i, uint64(j7))
		i += copy(dAtA[i:], dAtA8[:j7])
	}
	return i, nil
}

func (m *BelieverInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BelieverInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAacommon(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.Num != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAacommon(dAtA, i, uint64(m.Num))
	}
	return i, nil
}

func (m *StarInfoDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StarInfoDetail) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StarID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAacommon(dAtA, i, uint64(m.StarID))
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAacommon(dAtA, i, uint64(m.Type))
	}
	if m.OwnID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAacommon(dAtA, i, uint64(m.OwnID))
	}
	if len(m.Building) > 0 {
		for _, msg := range m.Building {
			dAtA[i] = 0x22
			i++
			i = encodeVarintAacommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Believer) > 0 {
		for _, msg := range m.Believer {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintAacommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.CreateTime != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintAacommon(dAtA, i, uint64(m.CreateTime))
	}
	if m.DoneTime != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintAacommon(dAtA, i, uint64(m.DoneTime))
	}
	if m.Seq != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintAacommon(dAtA, i, uint64(m.Seq))
	}
	if m.CivilizationLv != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintAacommon(dAtA, i, uint64(m.CivilizationLv))
	}
	if m.CivilizationProgress != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintAacommon(dAtA, i, uint64(m.CivilizationProgress))
	}
	if len(m.CivilizationReward) > 0 {
		for _, msg := range m.CivilizationReward {
			dAtA[i] = 0xaa
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintAacommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.StarFlags) > 0 {
		for _, msg := range m.StarFlags {
			dAtA[i] = 0xb2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintAacommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CivilizationReward) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CivilizationReward) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Level != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAacommon(dAtA, i, uint64(m.Level))
	}
	if m.Draw {
		dAtA[i] = 0x10
		i++
		if m.Draw {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *CivilizationInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CivilizationInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StarID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAacommon(dAtA, i, uint64(m.StarID))
	}
	if m.StarSeq != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAacommon(dAtA, i, uint64(m.StarSeq))
	}
	if m.CivilizationLv != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAacommon(dAtA, i, uint64(m.CivilizationLv))
	}
	if m.CivilizationProgress != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAacommon(dAtA, i, uint64(m.CivilizationProgress))
	}
	return i, nil
}

func (m *Statistics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Statistics) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAacommon(dAtA, i, uint64(m.Id))
	}
	if m.Value != 0 {
		dAtA[i] = 0x11
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Value))))
		i += 8
	}
	return i, nil
}

func (m *BagItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BagItem) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAacommon(dAtA, i, uint64(m.Id))
	}
	if m.Num != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAacommon(dAtA, i, uint64(m.Num))
	}
	if m.Time != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAacommon(dAtA, i, uint64(m.Time))
	}
	return i, nil
}

func (m *Reward) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Reward) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Faith != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAacommon(dAtA, i, uint64(m.Faith))
	}
	if len(m.Believer) > 0 {
		for _, msg := range m.Believer {
			dAtA[i] = 0x12
			i++
			i = encodeVarintAacommon(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ItemID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAacommon(dAtA, i, uint64(m.ItemID))
	}
	if m.GayPoint != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAacommon(dAtA, i, uint64(m.GayPoint))
	}
	if m.Diamond != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintAacommon(dAtA, i, uint64(m.Diamond))
	}
	if m.Power != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintAacommon(dAtA, i, uint64(m.Power))
	}
	return i, nil
}

func (m *InviteType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InviteType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAacommon(dAtA, i, uint64(m.Type))
	}
	if m.RefType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAacommon(dAtA, i, uint64(m.RefType))
	}
	if m.RefNum != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAacommon(dAtA, i, uint64(m.RefNum))
	}
	return i, nil
}

func encodeVarintAacommon(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ResultPush) Size() (n int) {
	var l int
	_ = l
	if m.Result != 0 {
		n += 1 + sovAacommon(uint64(m.Result))
	}
	if m.Attach != 0 {
		n += 1 + sovAacommon(uint64(m.Attach))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovAacommon(uint64(l))
	}
	return n
}

func (m *KickOff) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovAacommon(uint64(m.Uid))
	}
	if m.KickType != 0 {
		n += 1 + sovAacommon(uint64(m.KickType))
	}
	return n
}

func (m *HeartBeat) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *HeartBeatRet) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *KickoffPush) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovAacommon(uint64(m.Type))
	}
	return n
}

func (m *RoleInfo) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovAacommon(uint64(m.Id))
	}
	l = len(m.Nickname)
	if l > 0 {
		n += 1 + l + sovAacommon(uint64(l))
	}
	if m.Level != 0 {
		n += 1 + sovAacommon(uint64(m.Level))
	}
	if m.Exp != 0 {
		n += 1 + sovAacommon(uint64(m.Exp))
	}
	if m.Power != 0 {
		n += 1 + sovAacommon(uint64(m.Power))
	}
	if m.Faith != 0 {
		n += 1 + sovAacommon(uint64(m.Faith))
	}
	if m.UpdateTimestamp != 0 {
		n += 1 + sovAacommon(uint64(m.UpdateTimestamp))
	}
	if m.Diamond != 0 {
		n += 1 + sovAacommon(uint64(m.Diamond))
	}
	if m.PowerLimit != 0 {
		n += 1 + sovAacommon(uint64(m.PowerLimit))
	}
	if len(m.Flag) > 0 {
		for _, e := range m.Flag {
			l = e.Size()
			n += 1 + l + sovAacommon(uint64(l))
		}
	}
	if m.GayPoint != 0 {
		n += 2 + sovAacommon(uint64(m.GayPoint))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 2 + l + sovAacommon(uint64(l))
	}
	l = len(m.Avatar)
	if l > 0 {
		n += 2 + l + sovAacommon(uint64(l))
	}
	if m.Subscribe {
		n += 3
	}
	return n
}

func (m *BuildingInfo) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovAacommon(uint64(m.Id))
	}
	if m.Type != 0 {
		n += 1 + sovAacommon(uint64(m.Type))
	}
	if m.Level != 0 {
		n += 1 + sovAacommon(uint64(m.Level))
	}
	if m.RepairTime != 0 {
		n += 1 + sovAacommon(uint64(m.RepairTime))
	}
	if m.UpdateTime != 0 {
		n += 1 + sovAacommon(uint64(m.UpdateTime))
	}
	if m.BrokenTime != 0 {
		n += 1 + sovAacommon(uint64(m.BrokenTime))
	}
	if m.Exist {
		n += 2
	}
	if len(m.BuffID) > 0 {
		l = 0
		for _, e := range m.BuffID {
			l += sovAacommon(uint64(e))
		}
		n += 1 + sovAacommon(uint64(l)) + l
	}
	if len(m.BuffNum) > 0 {
		l = 0
		for _, e := range m.BuffNum {
			l += sovAacommon(uint64(e))
		}
		n += 1 + sovAacommon(uint64(l)) + l
	}
	if len(m.LevelInfo) > 0 {
		for _, e := range m.LevelInfo {
			l = e.Size()
			n += 1 + l + sovAacommon(uint64(l))
		}
	}
	return n
}

func (m *BuildingFaith) Size() (n int) {
	var l int
	_ = l
	if m.BuildingType != 0 {
		n += 1 + sovAacommon(uint64(m.BuildingType))
	}
	if m.BuildingFaith != 0 {
		n += 1 + sovAacommon(uint64(m.BuildingFaith))
	}
	if m.FaithUpdateTime != 0 {
		n += 1 + sovAacommon(uint64(m.FaithUpdateTime))
	}
	return n
}

func (m *BelieverCost) Size() (n int) {
	var l int
	_ = l
	l = len(m.BelieverID)
	if l > 0 {
		n += 1 + l + sovAacommon(uint64(l))
	}
	if m.Num != 0 {
		n += 1 + sovAacommon(uint64(m.Num))
	}
	return n
}

func (m *LevelInfo) Size() (n int) {
	var l int
	_ = l
	if m.Level != 0 {
		n += 1 + sovAacommon(uint64(m.Level))
	}
	if m.Time != 0 {
		n += 1 + sovAacommon(uint64(m.Time))
	}
	if len(m.BelieverCost) > 0 {
		for _, e := range m.BelieverCost {
			l = e.Size()
			n += 1 + l + sovAacommon(uint64(l))
		}
	}
	if m.FaithCost != 0 {
		n += 1 + sovAacommon(uint64(m.FaithCost))
	}
	return n
}

func (m *FlagInfo) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovAacommon(uint64(m.Id))
	}
	if m.Value != 0 {
		n += 1 + sovAacommon(uint64(m.Value))
	}
	if m.Time != 0 {
		n += 1 + sovAacommon(uint64(m.Time))
	}
	return n
}

func (m *BuildingBuffInfo) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovAacommon(uint64(m.Type))
	}
	if len(m.BuffID) > 0 {
		l = 0
		for _, e := range m.BuffID {
			l += sovAacommon(uint64(e))
		}
		n += 1 + sovAacommon(uint64(l)) + l
	}
	if len(m.BuffNum) > 0 {
		l = 0
		for _, e := range m.BuffNum {
			l += sovAacommon(uint64(e))
		}
		n += 1 + sovAacommon(uint64(l)) + l
	}
	return n
}

func (m *BelieverInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovAacommon(uint64(l))
	}
	if m.Num != 0 {
		n += 1 + sovAacommon(uint64(m.Num))
	}
	return n
}

func (m *StarInfoDetail) Size() (n int) {
	var l int
	_ = l
	if m.StarID != 0 {
		n += 1 + sovAacommon(uint64(m.StarID))
	}
	if m.Type != 0 {
		n += 1 + sovAacommon(uint64(m.Type))
	}
	if m.OwnID != 0 {
		n += 1 + sovAacommon(uint64(m.OwnID))
	}
	if len(m.Building) > 0 {
		for _, e := range m.Building {
			l = e.Size()
			n += 1 + l + sovAacommon(uint64(l))
		}
	}
	if len(m.Believer) > 0 {
		for _, e := range m.Believer {
			l = e.Size()
			n += 1 + l + sovAacommon(uint64(l))
		}
	}
	if m.CreateTime != 0 {
		n += 1 + sovAacommon(uint64(m.CreateTime))
	}
	if m.DoneTime != 0 {
		n += 1 + sovAacommon(uint64(m.DoneTime))
	}
	if m.Seq != 0 {
		n += 1 + sovAacommon(uint64(m.Seq))
	}
	if m.CivilizationLv != 0 {
		n += 2 + sovAacommon(uint64(m.CivilizationLv))
	}
	if m.CivilizationProgress != 0 {
		n += 2 + sovAacommon(uint64(m.CivilizationProgress))
	}
	if len(m.CivilizationReward) > 0 {
		for _, e := range m.CivilizationReward {
			l = e.Size()
			n += 2 + l + sovAacommon(uint64(l))
		}
	}
	if len(m.StarFlags) > 0 {
		for _, e := range m.StarFlags {
			l = e.Size()
			n += 2 + l + sovAacommon(uint64(l))
		}
	}
	return n
}

func (m *CivilizationReward) Size() (n int) {
	var l int
	_ = l
	if m.Level != 0 {
		n += 1 + sovAacommon(uint64(m.Level))
	}
	if m.Draw {
		n += 2
	}
	return n
}

func (m *CivilizationInfo) Size() (n int) {
	var l int
	_ = l
	if m.StarID != 0 {
		n += 1 + sovAacommon(uint64(m.StarID))
	}
	if m.StarSeq != 0 {
		n += 1 + sovAacommon(uint64(m.StarSeq))
	}
	if m.CivilizationLv != 0 {
		n += 1 + sovAacommon(uint64(m.CivilizationLv))
	}
	if m.CivilizationProgress != 0 {
		n += 1 + sovAacommon(uint64(m.CivilizationProgress))
	}
	return n
}

func (m *Statistics) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovAacommon(uint64(m.Id))
	}
	if m.Value != 0 {
		n += 9
	}
	return n
}

func (m *BagItem) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovAacommon(uint64(m.Id))
	}
	if m.Num != 0 {
		n += 1 + sovAacommon(uint64(m.Num))
	}
	if m.Time != 0 {
		n += 1 + sovAacommon(uint64(m.Time))
	}
	return n
}

func (m *Reward) Size() (n int) {
	var l int
	_ = l
	if m.Faith != 0 {
		n += 1 + sovAacommon(uint64(m.Faith))
	}
	if len(m.Believer) > 0 {
		for _, e := range m.Believer {
			l = e.Size()
			n += 1 + l + sovAacommon(uint64(l))
		}
	}
	if m.ItemID != 0 {
		n += 1 + sovAacommon(uint64(m.ItemID))
	}
	if m.GayPoint != 0 {
		n += 1 + sovAacommon(uint64(m.GayPoint))
	}
	if m.Diamond != 0 {
		n += 1 + sovAacommon(uint64(m.Diamond))
	}
	if m.Power != 0 {
		n += 1 + sovAacommon(uint64(m.Power))
	}
	return n
}

func (m *InviteType) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovAacommon(uint64(m.Type))
	}
	if m.RefType != 0 {
		n += 1 + sovAacommon(uint64(m.RefType))
	}
	if m.RefNum != 0 {
		n += 1 + sovAacommon(uint64(m.RefNum))
	}
	return n
}

func sovAacommon(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozAacommon(x uint64) (n int) {
	return sovAacommon(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ResultPush) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAacommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: result_push: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: result_push: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attach", wireType)
			}
			m.Attach = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Attach |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAacommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAacommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAacommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KickOff) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAacommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: kick_off: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: kick_off: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KickType", wireType)
			}
			m.KickType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KickType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAacommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAacommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeartBeat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAacommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: heart_beat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: heart_beat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAacommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAacommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeartBeatRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAacommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: heart_beat_ret: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: heart_beat_ret: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAacommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAacommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KickoffPush) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAacommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: kickoff_push: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: kickoff_push: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAacommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAacommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoleInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAacommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: role_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: role_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nickname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAacommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nickname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exp", wireType)
			}
			m.Exp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Power", wireType)
			}
			m.Power = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Power |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Faith", wireType)
			}
			m.Faith = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Faith |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateTimestamp", wireType)
			}
			m.UpdateTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateTimestamp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Diamond", wireType)
			}
			m.Diamond = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Diamond |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PowerLimit", wireType)
			}
			m.PowerLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PowerLimit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flag", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAacommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Flag = append(m.Flag, &FlagInfo{})
			if err := m.Flag[len(m.Flag)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GayPoint", wireType)
			}
			m.GayPoint = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GayPoint |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAacommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Avatar", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAacommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Avatar = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subscribe", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Subscribe = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAacommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAacommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuildingInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAacommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: building_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: building_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepairTime", wireType)
			}
			m.RepairTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RepairTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateTime", wireType)
			}
			m.UpdateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BrokenTime", wireType)
			}
			m.BrokenTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BrokenTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exist", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Exist = bool(v != 0)
		case 11:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAacommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.BuffID = append(m.BuffID, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAacommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthAacommon
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAacommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.BuffID = append(m.BuffID, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BuffID", wireType)
			}
		case 12:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAacommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.BuffNum = append(m.BuffNum, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAacommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthAacommon
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAacommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.BuffNum = append(m.BuffNum, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BuffNum", wireType)
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LevelInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAacommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LevelInfo = append(m.LevelInfo, &LevelInfo{})
			if err := m.LevelInfo[len(m.LevelInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAacommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAacommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuildingFaith) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAacommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: building_faith: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: building_faith: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildingType", wireType)
			}
			m.BuildingType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuildingType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildingFaith", wireType)
			}
			m.BuildingFaith = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuildingFaith |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FaithUpdateTime", wireType)
			}
			m.FaithUpdateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FaithUpdateTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAacommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAacommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BelieverCost) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAacommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: believer_cost: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: believer_cost: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BelieverID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAacommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BelieverID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			m.Num = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Num |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAacommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAacommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LevelInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAacommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: level_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: level_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BelieverCost", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAacommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BelieverCost = append(m.BelieverCost, &BelieverCost{})
			if err := m.BelieverCost[len(m.BelieverCost)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FaithCost", wireType)
			}
			m.FaithCost = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FaithCost |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAacommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAacommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlagInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAacommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: flag_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: flag_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAacommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAacommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuildingBuffInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAacommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: building_buff_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: building_buff_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAacommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.BuffID = append(m.BuffID, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAacommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthAacommon
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAacommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.BuffID = append(m.BuffID, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BuffID", wireType)
			}
		case 12:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAacommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.BuffNum = append(m.BuffNum, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAacommon
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthAacommon
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAacommon
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.BuffNum = append(m.BuffNum, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BuffNum", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAacommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAacommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BelieverInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAacommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: believer_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: believer_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAacommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			m.Num = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Num |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAacommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAacommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StarInfoDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAacommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: star_info_detail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: star_info_detail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StarID", wireType)
			}
			m.StarID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StarID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnID", wireType)
			}
			m.OwnID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OwnID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Building", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAacommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Building = append(m.Building, &BuildingInfo{})
			if err := m.Building[len(m.Building)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Believer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAacommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Believer = append(m.Believer, &BelieverInfo{})
			if err := m.Believer[len(m.Believer)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			m.CreateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoneTime", wireType)
			}
			m.DoneTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DoneTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CivilizationLv", wireType)
			}
			m.CivilizationLv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CivilizationLv |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CivilizationProgress", wireType)
			}
			m.CivilizationProgress = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CivilizationProgress |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CivilizationReward", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAacommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CivilizationReward = append(m.CivilizationReward, &CivilizationReward{})
			if err := m.CivilizationReward[len(m.CivilizationReward)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StarFlags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAacommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StarFlags = append(m.StarFlags, &FlagInfo{})
			if err := m.StarFlags[len(m.StarFlags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAacommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAacommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CivilizationReward) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAacommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: civilization_reward: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: civilization_reward: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Draw", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Draw = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAacommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAacommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CivilizationInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAacommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: civilization_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: civilization_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StarID", wireType)
			}
			m.StarID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StarID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StarSeq", wireType)
			}
			m.StarSeq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StarSeq |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CivilizationLv", wireType)
			}
			m.CivilizationLv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CivilizationLv |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CivilizationProgress", wireType)
			}
			m.CivilizationProgress = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CivilizationProgress |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAacommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAacommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Statistics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAacommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Statistics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Statistics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Value = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipAacommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAacommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BagItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAacommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: bag_item: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: bag_item: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			m.Num = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Num |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAacommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAacommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Reward) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAacommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Reward: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Reward: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Faith", wireType)
			}
			m.Faith = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Faith |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Believer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAacommon
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Believer = append(m.Believer, &BelieverInfo{})
			if err := m.Believer[len(m.Believer)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemID", wireType)
			}
			m.ItemID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GayPoint", wireType)
			}
			m.GayPoint = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GayPoint |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Diamond", wireType)
			}
			m.Diamond = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Diamond |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Power", wireType)
			}
			m.Power = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Power |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAacommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAacommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InviteType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAacommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: invite_type: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: invite_type: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefType", wireType)
			}
			m.RefType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefNum", wireType)
			}
			m.RefNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAacommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAacommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAacommon(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAacommon
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAacommon
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthAacommon
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowAacommon
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipAacommon(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthAacommon = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAacommon   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("aacommon.proto", fileDescriptorAacommon) }

var fileDescriptorAacommon = []byte{
	// 1019 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x56, 0xcd, 0x6e, 0x23, 0x45,
	0x10, 0xd6, 0x78, 0x6c, 0xc7, 0xae, 0x38, 0x26, 0xdb, 0x09, 0xa1, 0x85, 0x20, 0xb2, 0x5a, 0x08,
	0x7c, 0x8a, 0xb4, 0xd9, 0x0b, 0x12, 0x07, 0xfe, 0xc2, 0x4a, 0x91, 0x02, 0xac, 0x26, 0xe1, 0xc2,
	0xc5, 0x6a, 0x8f, 0x7b, 0x9c, 0x56, 0x66, 0xa6, 0xbd, 0x33, 0x6d, 0x27, 0xcb, 0x99, 0x17, 0xe0,
	0x11, 0x38, 0xf0, 0x0c, 0xbc, 0x02, 0x47, 0x1e, 0x01, 0xe5, 0xc8, 0x43, 0x20, 0x54, 0xd5, 0xf3,
	0xe7, 0xd8, 0x46, 0xec, 0x69, 0xfa, 0xfb, 0xaa, 0xa6, 0xbb, 0xea, 0xab, 0xaa, 0xe9, 0x81, 0xa1,
	0x94, 0xa1, 0x49, 0x12, 0x93, 0x9e, 0x2d, 0x32, 0x63, 0x0d, 0xeb, 0xd1, 0x23, 0x34, 0xb1, 0xf8,
	0x1e, 0xf6, 0x33, 0x95, 0x2f, 0x63, 0x3b, 0x59, 0x2c, 0xf3, 0x5b, 0x76, 0x02, 0x5d, 0x07, 0xb9,
	0x37, 0xf2, 0xc6, 0x9d, 0xa0, 0x40, 0xc8, 0x4b, 0x6b, 0x65, 0x78, 0xcb, 0x5b, 0x8e, 0x77, 0x88,
	0x1d, 0x82, 0x9f, 0xe4, 0x73, 0xee, 0x8f, 0xbc, 0x71, 0x3f, 0xc0, 0xa5, 0xf8, 0x14, 0x7a, 0x77,
	0x3a, 0xbc, 0x9b, 0x98, 0x28, 0x42, 0xeb, 0x52, 0xcf, 0x8a, 0xad, 0x70, 0xc9, 0xde, 0x77, 0xd6,
	0x9b, 0x37, 0x0b, 0x55, 0xec, 0x54, 0x61, 0x31, 0x00, 0xb8, 0x55, 0x32, 0xb3, 0x93, 0xa9, 0x92,
	0x56, 0x1c, 0xc2, 0xb0, 0x46, 0x93, 0x4c, 0x59, 0x21, 0x60, 0x80, 0xbe, 0x26, 0x8a, 0x5c, 0xac,
	0x0c, 0xda, 0x16, 0xf7, 0x71, 0xdb, 0xd3, 0x5a, 0xfc, 0xd3, 0x82, 0x7e, 0x66, 0x62, 0x35, 0xd1,
	0x69, 0x64, 0xd8, 0x10, 0x5a, 0xd5, 0xf1, 0x2d, 0x77, 0x7a, 0xaa, 0xc3, 0xbb, 0x54, 0x26, 0xaa,
	0x08, 0xb9, 0xc2, 0xec, 0x18, 0x3a, 0xb1, 0x5a, 0xa9, 0x98, 0xb7, 0xc9, 0xdd, 0x01, 0xcc, 0x40,
	0x3d, 0x2c, 0x78, 0xc7, 0x65, 0xa0, 0x1e, 0x16, 0xe8, 0xb7, 0x30, 0xf7, 0x2a, 0xe3, 0x5d, 0xe7,
	0x47, 0x00, 0xd9, 0x48, 0x6a, 0x7b, 0xcb, 0x7b, 0x8e, 0x25, 0xc0, 0xc6, 0xf0, 0xce, 0x72, 0x31,
	0x93, 0x56, 0xdd, 0xe8, 0x44, 0xe5, 0x56, 0x26, 0x0b, 0xde, 0x1f, 0x79, 0x63, 0x3f, 0x78, 0x4a,
	0x33, 0x0e, 0x7b, 0x33, 0x2d, 0x13, 0x93, 0xce, 0xf8, 0x80, 0x76, 0x28, 0x21, 0x3b, 0x05, 0xa0,
	0x23, 0xae, 0x74, 0xa2, 0x2d, 0x3f, 0x20, 0x63, 0x83, 0x61, 0x9f, 0x40, 0x3b, 0x8a, 0xe5, 0x9c,
	0x0f, 0x47, 0xfe, 0x78, 0xff, 0xfc, 0xe8, 0xac, 0xac, 0xec, 0x19, 0xb2, 0x24, 0x43, 0x40, 0x0e,
	0x98, 0xfc, 0x5c, 0xbe, 0x79, 0x65, 0x74, 0x6a, 0xf9, 0xa1, 0x93, 0xbe, 0xc4, 0x28, 0xe5, 0x4c,
	0xe5, 0x21, 0x7f, 0x46, 0xa2, 0xd0, 0x9a, 0x4a, 0xbe, 0x92, 0x56, 0x66, 0x9c, 0x11, 0x5b, 0x20,
	0xf6, 0x01, 0xf4, 0xf3, 0xe5, 0x34, 0x0f, 0x33, 0x3d, 0x55, 0xfc, 0x68, 0xe4, 0x8d, 0x7b, 0x41,
	0x4d, 0x88, 0xdf, 0x5a, 0x70, 0x30, 0x5d, 0xea, 0x78, 0xa6, 0xd3, 0xf9, 0xf6, 0x22, 0x94, 0x65,
	0x6b, 0xd5, 0x65, 0x43, 0xf9, 0xae, 0x48, 0x7c, 0xdf, 0xc9, 0x47, 0x00, 0x53, 0xcf, 0xd4, 0x42,
	0xea, 0x0c, 0x75, 0xa2, 0xba, 0xf8, 0x41, 0x83, 0x41, 0x7b, 0xad, 0x23, 0xd5, 0xc8, 0x0f, 0x1a,
	0x0c, 0xda, 0xa7, 0x99, 0xb9, 0x53, 0x29, 0xd9, 0xbb, 0xce, 0x5e, 0x33, 0x78, 0xaa, 0x7a, 0xd0,
	0xb9, 0xe5, 0x40, 0x59, 0x38, 0x80, 0x79, 0x4f, 0x97, 0x51, 0x74, 0x79, 0xc1, 0xf7, 0x47, 0x3e,
	0xb6, 0xba, 0x43, 0x58, 0x22, 0x5c, 0x7d, 0xb7, 0x4c, 0xf8, 0x80, 0x0c, 0x25, 0x64, 0xe7, 0xd0,
	0xa7, 0x6e, 0xb9, 0x4c, 0x23, 0x53, 0xd4, 0xe1, 0xb8, 0xae, 0x03, 0x99, 0x5c, 0x21, 0x6a, 0x37,
	0xf1, 0xb3, 0x07, 0xc3, 0x4a, 0x27, 0xd7, 0x2d, 0x02, 0x06, 0x25, 0x73, 0x53, 0xf7, 0xf5, 0x1a,
	0xc7, 0x3e, 0xaa, 0xd5, 0x7d, 0x49, 0xfd, 0xe6, 0x54, 0x5c, 0x27, 0xb1, 0xef, 0x68, 0xcb, 0x1f,
	0x6a, 0x75, 0x7c, 0xd7, 0x77, 0x4f, 0x68, 0xf1, 0x25, 0x1c, 0x4c, 0x55, 0xac, 0xd5, 0x4a, 0x65,
	0x93, 0xd0, 0xe4, 0x96, 0x34, 0x2b, 0x88, 0xcb, 0x0b, 0x0a, 0xa1, 0x1f, 0x34, 0x18, 0x1c, 0x88,
	0x74, 0x99, 0x14, 0xc7, 0xe2, 0x52, 0xfc, 0xe2, 0x01, 0xd4, 0x39, 0xd6, 0x73, 0xe4, 0x35, 0xe7,
	0x08, 0x8b, 0x8e, 0x61, 0xb4, 0x28, 0x0c, 0x5a, 0xb3, 0xcf, 0x60, 0x50, 0x6e, 0xfc, 0xb5, 0xc9,
	0x2d, 0xf7, 0x49, 0xb9, 0xf7, 0x6a, 0xe5, 0xd6, 0x22, 0x0b, 0xd6, 0x9c, 0xb1, 0x0b, 0x29, 0x17,
	0x7a, 0xd3, 0x8d, 0x6c, 0x4d, 0x88, 0x6f, 0xa0, 0x5f, 0xb5, 0xff, 0x46, 0x03, 0x1e, 0x43, 0x67,
	0x25, 0xe3, 0x65, 0xd9, 0x81, 0x0e, 0x54, 0x11, 0xfa, 0x75, 0x84, 0xe2, 0x47, 0x60, 0x55, 0x8d,
	0xb0, 0xd8, 0x6e, 0xbf, 0x6d, 0x0d, 0xfc, 0xd6, 0x4d, 0x23, 0x9e, 0x37, 0x94, 0x7f, 0x12, 0x66,
	0x9f, 0xc2, 0xdc, 0x54, 0xfa, 0x6f, 0x1f, 0x0e, 0x73, 0x2b, 0x9d, 0xff, 0x64, 0xa6, 0xac, 0xd4,
	0x31, 0x9e, 0x8c, 0x5c, 0x51, 0xac, 0x4e, 0x50, 0xa0, 0x5d, 0x63, 0x66, 0xee, 0xd3, 0xcb, 0x8b,
	0x72, 0xcc, 0x08, 0xb0, 0x17, 0xd0, 0x2b, 0xb3, 0xe4, 0xed, 0x8d, 0x1a, 0x34, 0x67, 0x39, 0xa8,
	0x1c, 0xe9, 0xa5, 0x22, 0x7c, 0xde, 0xd9, 0x59, 0xb8, 0xe2, 0xa5, 0x02, 0x62, 0x73, 0x85, 0x99,
	0x2a, 0x5b, 0xb2, 0x18, 0xc8, 0x9a, 0xc1, 0x4f, 0xd4, 0xcc, 0xa4, 0xce, 0xba, 0x47, 0xd6, 0x0a,
	0xa3, 0x1c, 0xb9, 0x7a, 0x5d, 0x7c, 0x5f, 0x71, 0xc9, 0x3e, 0x86, 0x61, 0xa8, 0x57, 0x3a, 0xd6,
	0x3f, 0x49, 0xab, 0x4d, 0x7a, 0xb5, 0xa2, 0xaf, 0x51, 0x27, 0x78, 0xc2, 0xb2, 0x73, 0x38, 0x6e,
	0x32, 0xaf, 0x32, 0x33, 0xcf, 0x54, 0x9e, 0xf3, 0x63, 0xf2, 0xde, 0x6a, 0x63, 0xdf, 0x02, 0x6b,
	0xf2, 0x81, 0xba, 0x97, 0xd9, 0x8c, 0xbf, 0x4b, 0x89, 0x7e, 0x58, 0x27, 0xda, 0xf4, 0x99, 0x64,
	0xe4, 0x14, 0x6c, 0x79, 0x91, 0x3d, 0x87, 0x3e, 0x96, 0xe5, 0x65, 0x2c, 0xe7, 0x39, 0x3f, 0xd9,
	0xfd, 0xa5, 0xae, 0xbd, 0xc4, 0xe7, 0x70, 0xb4, 0x65, 0xf7, 0xdd, 0xe3, 0x35, 0xcb, 0xe4, 0x3d,
	0x15, 0xbb, 0x17, 0xd0, 0x5a, 0xfc, 0xea, 0xc1, 0xb3, 0xb5, 0x1d, 0xa8, 0xcb, 0x76, 0xb5, 0x0b,
	0x87, 0x3d, 0x5c, 0x5d, 0xab, 0xd7, 0x45, 0xc7, 0x94, 0x70, 0x8b, 0xcc, 0xfe, 0x5b, 0xc9, 0xdc,
	0xde, 0x2d, 0xb3, 0x38, 0x07, 0xb8, 0xb6, 0xd2, 0xea, 0xdc, 0xea, 0x30, 0xff, 0xef, 0x41, 0xf5,
	0x8a, 0x41, 0x15, 0x5f, 0x40, 0x6f, 0x8a, 0x7a, 0x59, 0x95, 0x6c, 0xbc, 0xb1, 0x31, 0x33, 0x5b,
	0xc7, 0xfa, 0x77, 0x0f, 0xba, 0x41, 0x25, 0xa7, 0xbb, 0xb7, 0xbd, 0xe6, 0xbd, 0xdd, 0x6c, 0xee,
	0xd6, 0xff, 0x6d, 0xee, 0x13, 0xe8, 0x62, 0x4c, 0xd5, 0x74, 0x15, 0x68, 0xed, 0xde, 0x6d, 0x3f,
	0xb9, 0x77, 0x1b, 0xd7, 0x7e, 0x67, 0xfd, 0xda, 0xdf, 0xfa, 0x9b, 0x21, 0xae, 0x61, 0x5f, 0xa7,
	0x2b, 0x6d, 0xd5, 0x84, 0xe6, 0x79, 0xcb, 0x1f, 0x10, 0x6e, 0x99, 0xa9, 0xa8, 0xf1, 0x83, 0x55,
	0x42, 0xf7, 0x6f, 0x47, 0x9f, 0x22, 0xbf, 0xfc, 0xb7, 0x43, 0xf4, 0xd5, 0xe0, 0x8f, 0xc7, 0x53,
	0xef, 0xcf, 0xc7, 0x53, 0xef, 0xaf, 0xc7, 0x53, 0x6f, 0xda, 0xa5, 0x44, 0x5f, 0xfc, 0x1b, 0x00,
	0x00, 0xff, 0xff, 0x70, 0xa9, 0xc9, 0xb1, 0x33, 0x0a, 0x00, 0x00,
}
