// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: trade.proto

package protocol

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type Goods struct {
	Id    int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Num   int32 `protobuf:"varint,2,opt,name=num,proto3" json:"num,omitempty"`
	Price int32 `protobuf:"varint,3,opt,name=price,proto3" json:"price,omitempty"`
}

func (m *Goods) Reset()                    { *m = Goods{} }
func (m *Goods) String() string            { return proto.CompactTextString(m) }
func (*Goods) ProtoMessage()               {}
func (*Goods) Descriptor() ([]byte, []int) { return fileDescriptorTrade, []int{0} }

func (m *Goods) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Goods) GetNum() int32 {
	if m != nil {
		return m.Num
	}
	return 0
}

func (m *Goods) GetPrice() int32 {
	if m != nil {
		return m.Price
	}
	return 0
}

// 获取货架信息
type GetGoodsInfo struct {
	Uid int32 `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
}

func (m *GetGoodsInfo) Reset()                    { *m = GetGoodsInfo{} }
func (m *GetGoodsInfo) String() string            { return proto.CompactTextString(m) }
func (*GetGoodsInfo) ProtoMessage()               {}
func (*GetGoodsInfo) Descriptor() ([]byte, []int) { return fileDescriptorTrade, []int{1} }

func (m *GetGoodsInfo) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

type GetGoodsInfoRet struct {
	Goods []*Goods `protobuf:"bytes,1,rep,name=goods" json:"goods,omitempty"`
}

func (m *GetGoodsInfoRet) Reset()                    { *m = GetGoodsInfoRet{} }
func (m *GetGoodsInfoRet) String() string            { return proto.CompactTextString(m) }
func (*GetGoodsInfoRet) ProtoMessage()               {}
func (*GetGoodsInfoRet) Descriptor() ([]byte, []int) { return fileDescriptorTrade, []int{2} }

func (m *GetGoodsInfoRet) GetGoods() []*Goods {
	if m != nil {
		return m.Goods
	}
	return nil
}

// 购买物品
type BuyGoods struct {
	Uid    int32 `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
	Itemid int32 `protobuf:"varint,2,opt,name=itemid,proto3" json:"itemid,omitempty"`
	Num    int32 `protobuf:"varint,3,opt,name=num,proto3" json:"num,omitempty"`
	Social int32 `protobuf:"varint,4,opt,name=social,proto3" json:"social,omitempty"`
}

func (m *BuyGoods) Reset()                    { *m = BuyGoods{} }
func (m *BuyGoods) String() string            { return proto.CompactTextString(m) }
func (*BuyGoods) ProtoMessage()               {}
func (*BuyGoods) Descriptor() ([]byte, []int) { return fileDescriptorTrade, []int{3} }

func (m *BuyGoods) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *BuyGoods) GetItemid() int32 {
	if m != nil {
		return m.Itemid
	}
	return 0
}

func (m *BuyGoods) GetNum() int32 {
	if m != nil {
		return m.Num
	}
	return 0
}

func (m *BuyGoods) GetSocial() int32 {
	if m != nil {
		return m.Social
	}
	return 0
}

type BuyGoodsRet struct {
	Num int32 `protobuf:"varint,1,opt,name=num,proto3" json:"num,omitempty"`
	Fee int32 `protobuf:"varint,2,opt,name=fee,proto3" json:"fee,omitempty"`
}

func (m *BuyGoodsRet) Reset()                    { *m = BuyGoodsRet{} }
func (m *BuyGoodsRet) String() string            { return proto.CompactTextString(m) }
func (*BuyGoodsRet) ProtoMessage()               {}
func (*BuyGoodsRet) Descriptor() ([]byte, []int) { return fileDescriptorTrade, []int{4} }

func (m *BuyGoodsRet) GetNum() int32 {
	if m != nil {
		return m.Num
	}
	return 0
}

func (m *BuyGoodsRet) GetFee() int32 {
	if m != nil {
		return m.Fee
	}
	return 0
}

// 发布物品
type PublicGoods struct {
	Uid   int32  `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
	Goods *Goods `protobuf:"bytes,2,opt,name=goods" json:"goods,omitempty"`
}

func (m *PublicGoods) Reset()                    { *m = PublicGoods{} }
func (m *PublicGoods) String() string            { return proto.CompactTextString(m) }
func (*PublicGoods) ProtoMessage()               {}
func (*PublicGoods) Descriptor() ([]byte, []int) { return fileDescriptorTrade, []int{5} }

func (m *PublicGoods) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *PublicGoods) GetGoods() *Goods {
	if m != nil {
		return m.Goods
	}
	return nil
}

type PublicGoodsRet struct {
	Result bool `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
}

func (m *PublicGoodsRet) Reset()                    { *m = PublicGoodsRet{} }
func (m *PublicGoodsRet) String() string            { return proto.CompactTextString(m) }
func (*PublicGoodsRet) ProtoMessage()               {}
func (*PublicGoodsRet) Descriptor() ([]byte, []int) { return fileDescriptorTrade, []int{6} }

func (m *PublicGoodsRet) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

// 撤销物品
type CancelGoods struct {
	Uid    int32 `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
	Itemid int32 `protobuf:"varint,2,opt,name=itemid,proto3" json:"itemid,omitempty"`
}

func (m *CancelGoods) Reset()                    { *m = CancelGoods{} }
func (m *CancelGoods) String() string            { return proto.CompactTextString(m) }
func (*CancelGoods) ProtoMessage()               {}
func (*CancelGoods) Descriptor() ([]byte, []int) { return fileDescriptorTrade, []int{7} }

func (m *CancelGoods) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *CancelGoods) GetItemid() int32 {
	if m != nil {
		return m.Itemid
	}
	return 0
}

type CancelGoodsRet struct {
	Goods *Goods `protobuf:"bytes,1,opt,name=goods" json:"goods,omitempty"`
}

func (m *CancelGoodsRet) Reset()                    { *m = CancelGoodsRet{} }
func (m *CancelGoodsRet) String() string            { return proto.CompactTextString(m) }
func (*CancelGoodsRet) ProtoMessage()               {}
func (*CancelGoodsRet) Descriptor() ([]byte, []int) { return fileDescriptorTrade, []int{8} }

func (m *CancelGoodsRet) GetGoods() *Goods {
	if m != nil {
		return m.Goods
	}
	return nil
}

// ------------------------------------------圣物求组--------------------
// 发布圣物求助
type PublicItemHelp struct {
	ItemID    int32 `protobuf:"varint,1,opt,name=itemID,proto3" json:"itemID,omitempty"`
	IsWatchAd bool  `protobuf:"varint,2,opt,name=isWatchAd,proto3" json:"isWatchAd,omitempty"`
}

func (m *PublicItemHelp) Reset()                    { *m = PublicItemHelp{} }
func (m *PublicItemHelp) String() string            { return proto.CompactTextString(m) }
func (*PublicItemHelp) ProtoMessage()               {}
func (*PublicItemHelp) Descriptor() ([]byte, []int) { return fileDescriptorTrade, []int{9} }

func (m *PublicItemHelp) GetItemID() int32 {
	if m != nil {
		return m.ItemID
	}
	return 0
}

func (m *PublicItemHelp) GetIsWatchAd() bool {
	if m != nil {
		return m.IsWatchAd
	}
	return false
}

type PublicItemHelpRet struct {
	Cost     int32     `protobuf:"varint,1,opt,name=cost,proto3" json:"cost,omitempty"`
	ItemHelp *ItemHelp `protobuf:"bytes,2,opt,name=itemHelp" json:"itemHelp,omitempty"`
}

func (m *PublicItemHelpRet) Reset()                    { *m = PublicItemHelpRet{} }
func (m *PublicItemHelpRet) String() string            { return proto.CompactTextString(m) }
func (*PublicItemHelpRet) ProtoMessage()               {}
func (*PublicItemHelpRet) Descriptor() ([]byte, []int) { return fileDescriptorTrade, []int{10} }

func (m *PublicItemHelpRet) GetCost() int32 {
	if m != nil {
		return m.Cost
	}
	return 0
}

func (m *PublicItemHelpRet) GetItemHelp() *ItemHelp {
	if m != nil {
		return m.ItemHelp
	}
	return nil
}

// 取消圣物求助
type CancelItemHelp struct {
	ItemID int32 `protobuf:"varint,1,opt,name=itemID,proto3" json:"itemID,omitempty"`
}

func (m *CancelItemHelp) Reset()                    { *m = CancelItemHelp{} }
func (m *CancelItemHelp) String() string            { return proto.CompactTextString(m) }
func (*CancelItemHelp) ProtoMessage()               {}
func (*CancelItemHelp) Descriptor() ([]byte, []int) { return fileDescriptorTrade, []int{11} }

func (m *CancelItemHelp) GetItemID() int32 {
	if m != nil {
		return m.ItemID
	}
	return 0
}

type CancelItemHelpRet struct {
	Result bool `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
}

func (m *CancelItemHelpRet) Reset()                    { *m = CancelItemHelpRet{} }
func (m *CancelItemHelpRet) String() string            { return proto.CompactTextString(m) }
func (*CancelItemHelpRet) ProtoMessage()               {}
func (*CancelItemHelpRet) Descriptor() ([]byte, []int) { return fileDescriptorTrade, []int{12} }

func (m *CancelItemHelpRet) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

// 领取求组到的圣物
type DrawItemHelp struct {
	ItemID int32 `protobuf:"varint,1,opt,name=itemID,proto3" json:"itemID,omitempty"`
	Cancel bool  `protobuf:"varint,2,opt,name=cancel,proto3" json:"cancel,omitempty"`
}

func (m *DrawItemHelp) Reset()                    { *m = DrawItemHelp{} }
func (m *DrawItemHelp) String() string            { return proto.CompactTextString(m) }
func (*DrawItemHelp) ProtoMessage()               {}
func (*DrawItemHelp) Descriptor() ([]byte, []int) { return fileDescriptorTrade, []int{13} }

func (m *DrawItemHelp) GetItemID() int32 {
	if m != nil {
		return m.ItemID
	}
	return 0
}

func (m *DrawItemHelp) GetCancel() bool {
	if m != nil {
		return m.Cancel
	}
	return false
}

type DrawItemHelpRet struct {
	ItemID   int32     `protobuf:"varint,1,opt,name=itemID,proto3" json:"itemID,omitempty"`
	ItemNum  int32     `protobuf:"varint,2,opt,name=itemNum,proto3" json:"itemNum,omitempty"`
	ItemHelp *ItemHelp `protobuf:"bytes,3,opt,name=itemHelp" json:"itemHelp,omitempty"`
}

func (m *DrawItemHelpRet) Reset()                    { *m = DrawItemHelpRet{} }
func (m *DrawItemHelpRet) String() string            { return proto.CompactTextString(m) }
func (*DrawItemHelpRet) ProtoMessage()               {}
func (*DrawItemHelpRet) Descriptor() ([]byte, []int) { return fileDescriptorTrade, []int{14} }

func (m *DrawItemHelpRet) GetItemID() int32 {
	if m != nil {
		return m.ItemID
	}
	return 0
}

func (m *DrawItemHelpRet) GetItemNum() int32 {
	if m != nil {
		return m.ItemNum
	}
	return 0
}

func (m *DrawItemHelpRet) GetItemHelp() *ItemHelp {
	if m != nil {
		return m.ItemHelp
	}
	return nil
}

// 获取求助信息
type GetItemHelp struct {
	Uid        int32  `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
	Id         string `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	NewsFeedID string `protobuf:"bytes,3,opt,name=newsFeedID,proto3" json:"newsFeedID,omitempty"`
}

func (m *GetItemHelp) Reset()                    { *m = GetItemHelp{} }
func (m *GetItemHelp) String() string            { return proto.CompactTextString(m) }
func (*GetItemHelp) ProtoMessage()               {}
func (*GetItemHelp) Descriptor() ([]byte, []int) { return fileDescriptorTrade, []int{15} }

func (m *GetItemHelp) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *GetItemHelp) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *GetItemHelp) GetNewsFeedID() string {
	if m != nil {
		return m.NewsFeedID
	}
	return ""
}

type GetItemHelpRet struct {
	ItemHelp *ItemHelp `protobuf:"bytes,1,opt,name=itemHelp" json:"itemHelp,omitempty"`
}

func (m *GetItemHelpRet) Reset()                    { *m = GetItemHelpRet{} }
func (m *GetItemHelpRet) String() string            { return proto.CompactTextString(m) }
func (*GetItemHelpRet) ProtoMessage()               {}
func (*GetItemHelpRet) Descriptor() ([]byte, []int) { return fileDescriptorTrade, []int{16} }

func (m *GetItemHelpRet) GetItemHelp() *ItemHelp {
	if m != nil {
		return m.ItemHelp
	}
	return nil
}

// 偷取圣物
type LootHelpItem struct {
	Uid        int32     `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
	ItemID     int32     `protobuf:"varint,2,opt,name=itemID,proto3" json:"itemID,omitempty"`
	Power      int32     `protobuf:"varint,3,opt,name=power,proto3" json:"power,omitempty"`
	Costs      []int32   `protobuf:"varint,4,rep,packed,name=costs" json:"costs,omitempty"`
	Limit      int32     `protobuf:"varint,5,opt,name=limit,proto3" json:"limit,omitempty"`
	Probs      []float32 `protobuf:"fixed32,6,rep,packed,name=probs" json:"probs,omitempty"`
	AddProb    float32   `protobuf:"fixed32,7,opt,name=addProb,proto3" json:"addProb,omitempty"`
	IsWatchAd  bool      `protobuf:"varint,8,opt,name=isWatchAd,proto3" json:"isWatchAd,omitempty"`
	EachFollow bool      `protobuf:"varint,9,opt,name=eachFollow,proto3" json:"eachFollow,omitempty"`
	Id         string    `protobuf:"bytes,10,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *LootHelpItem) Reset()                    { *m = LootHelpItem{} }
func (m *LootHelpItem) String() string            { return proto.CompactTextString(m) }
func (*LootHelpItem) ProtoMessage()               {}
func (*LootHelpItem) Descriptor() ([]byte, []int) { return fileDescriptorTrade, []int{17} }

func (m *LootHelpItem) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *LootHelpItem) GetItemID() int32 {
	if m != nil {
		return m.ItemID
	}
	return 0
}

func (m *LootHelpItem) GetPower() int32 {
	if m != nil {
		return m.Power
	}
	return 0
}

func (m *LootHelpItem) GetCosts() []int32 {
	if m != nil {
		return m.Costs
	}
	return nil
}

func (m *LootHelpItem) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *LootHelpItem) GetProbs() []float32 {
	if m != nil {
		return m.Probs
	}
	return nil
}

func (m *LootHelpItem) GetAddProb() float32 {
	if m != nil {
		return m.AddProb
	}
	return 0
}

func (m *LootHelpItem) GetIsWatchAd() bool {
	if m != nil {
		return m.IsWatchAd
	}
	return false
}

func (m *LootHelpItem) GetEachFollow() bool {
	if m != nil {
		return m.EachFollow
	}
	return false
}

func (m *LootHelpItem) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type LootHelpItemRet struct {
	Result     bool      `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
	Cost       int32     `protobuf:"varint,2,opt,name=cost,proto3" json:"cost,omitempty"`
	ItemHelp   *ItemHelp `protobuf:"bytes,3,opt,name=itemHelp" json:"itemHelp,omitempty"`
	EachFollow bool      `protobuf:"varint,4,opt,name=eachFollow,proto3" json:"eachFollow,omitempty"`
}

func (m *LootHelpItemRet) Reset()                    { *m = LootHelpItemRet{} }
func (m *LootHelpItemRet) String() string            { return proto.CompactTextString(m) }
func (*LootHelpItemRet) ProtoMessage()               {}
func (*LootHelpItemRet) Descriptor() ([]byte, []int) { return fileDescriptorTrade, []int{18} }

func (m *LootHelpItemRet) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func (m *LootHelpItemRet) GetCost() int32 {
	if m != nil {
		return m.Cost
	}
	return 0
}

func (m *LootHelpItemRet) GetItemHelp() *ItemHelp {
	if m != nil {
		return m.ItemHelp
	}
	return nil
}

func (m *LootHelpItemRet) GetEachFollow() bool {
	if m != nil {
		return m.EachFollow
	}
	return false
}

// 援助圣物
type HelpItem struct {
	Uid        int32  `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
	ItemID     int32  `protobuf:"varint,2,opt,name=itemID,proto3" json:"itemID,omitempty"`
	Limit      int32  `protobuf:"varint,3,opt,name=limit,proto3" json:"limit,omitempty"`
	EachFollow bool   `protobuf:"varint,4,opt,name=eachFollow,proto3" json:"eachFollow,omitempty"`
	Id         string `protobuf:"bytes,10,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *HelpItem) Reset()                    { *m = HelpItem{} }
func (m *HelpItem) String() string            { return proto.CompactTextString(m) }
func (*HelpItem) ProtoMessage()               {}
func (*HelpItem) Descriptor() ([]byte, []int) { return fileDescriptorTrade, []int{19} }

func (m *HelpItem) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *HelpItem) GetItemID() int32 {
	if m != nil {
		return m.ItemID
	}
	return 0
}

func (m *HelpItem) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *HelpItem) GetEachFollow() bool {
	if m != nil {
		return m.EachFollow
	}
	return false
}

func (m *HelpItem) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type HelpItemRet struct {
	Result     bool      `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
	GayPoint   int32     `protobuf:"varint,2,opt,name=gayPoint,proto3" json:"gayPoint,omitempty"`
	ItemHelp   *ItemHelp `protobuf:"bytes,3,opt,name=itemHelp" json:"itemHelp,omitempty"`
	EachFollow bool      `protobuf:"varint,4,opt,name=eachFollow,proto3" json:"eachFollow,omitempty"`
}

func (m *HelpItemRet) Reset()                    { *m = HelpItemRet{} }
func (m *HelpItemRet) String() string            { return proto.CompactTextString(m) }
func (*HelpItemRet) ProtoMessage()               {}
func (*HelpItemRet) Descriptor() ([]byte, []int) { return fileDescriptorTrade, []int{20} }

func (m *HelpItemRet) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func (m *HelpItemRet) GetGayPoint() int32 {
	if m != nil {
		return m.GayPoint
	}
	return 0
}

func (m *HelpItemRet) GetItemHelp() *ItemHelp {
	if m != nil {
		return m.ItemHelp
	}
	return nil
}

func (m *HelpItemRet) GetEachFollow() bool {
	if m != nil {
		return m.EachFollow
	}
	return false
}

type GetHelpItemHistory struct {
	Uid   int32 `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
	Skip  int32 `protobuf:"varint,2,opt,name=skip,proto3" json:"skip,omitempty"`
	Limit int32 `protobuf:"varint,3,opt,name=limit,proto3" json:"limit,omitempty"`
	Count bool  `protobuf:"varint,4,opt,name=count,proto3" json:"count,omitempty"`
}

func (m *GetHelpItemHistory) Reset()                    { *m = GetHelpItemHistory{} }
func (m *GetHelpItemHistory) String() string            { return proto.CompactTextString(m) }
func (*GetHelpItemHistory) ProtoMessage()               {}
func (*GetHelpItemHistory) Descriptor() ([]byte, []int) { return fileDescriptorTrade, []int{21} }

func (m *GetHelpItemHistory) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *GetHelpItemHistory) GetSkip() int32 {
	if m != nil {
		return m.Skip
	}
	return 0
}

func (m *GetHelpItemHistory) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *GetHelpItemHistory) GetCount() bool {
	if m != nil {
		return m.Count
	}
	return false
}

type GetHelpItemHistoryRet struct {
	ItemHelp []*ItemHelp `protobuf:"bytes,1,rep,name=itemHelp" json:"itemHelp,omitempty"`
	Count    int32       `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
}

func (m *GetHelpItemHistoryRet) Reset()                    { *m = GetHelpItemHistoryRet{} }
func (m *GetHelpItemHistoryRet) String() string            { return proto.CompactTextString(m) }
func (*GetHelpItemHistoryRet) ProtoMessage()               {}
func (*GetHelpItemHistoryRet) Descriptor() ([]byte, []int) { return fileDescriptorTrade, []int{22} }

func (m *GetHelpItemHistoryRet) GetItemHelp() []*ItemHelp {
	if m != nil {
		return m.ItemHelp
	}
	return nil
}

func (m *GetHelpItemHistoryRet) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

type ItemHelp struct {
	Id      string       `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty" bson:"_id"`
	Uid     int32        `protobuf:"varint,2,opt,name=uid,proto3" json:"uid,omitempty" bson:"uid"`
	ItemID  int32        `protobuf:"varint,3,opt,name=itemID,proto3" json:"itemID,omitempty" bson:"itemID"`
	ItemNum int32        `protobuf:"varint,4,opt,name=ItemNum,proto3" json:"ItemNum,omitempty" bson:"itemNum"`
	DrawNum int32        `protobuf:"varint,5,opt,name=DrawNum,proto3" json:"DrawNum,omitempty" bson:"drawNum"`
	LootNum int32        `protobuf:"varint,6,opt,name=LootNum,proto3" json:"LootNum,omitempty" bson:"lootNum"`
	HelpNum int32        `protobuf:"varint,7,opt,name=helpNum,proto3" json:"helpNum,omitempty" bson:"helpNum"`
	Events  []*ItemEvent `protobuf:"bytes,8,rep,name=Events" json:"Events,omitempty" bson:"events"`
	Overdue bool         `protobuf:"varint,10,opt,name=overdue,proto3" json:"overdue,omitempty" bson:"overdue"`
}

func (m *ItemHelp) Reset()                    { *m = ItemHelp{} }
func (m *ItemHelp) String() string            { return proto.CompactTextString(m) }
func (*ItemHelp) ProtoMessage()               {}
func (*ItemHelp) Descriptor() ([]byte, []int) { return fileDescriptorTrade, []int{23} }

func (m *ItemHelp) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ItemHelp) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *ItemHelp) GetItemID() int32 {
	if m != nil {
		return m.ItemID
	}
	return 0
}

func (m *ItemHelp) GetItemNum() int32 {
	if m != nil {
		return m.ItemNum
	}
	return 0
}

func (m *ItemHelp) GetDrawNum() int32 {
	if m != nil {
		return m.DrawNum
	}
	return 0
}

func (m *ItemHelp) GetLootNum() int32 {
	if m != nil {
		return m.LootNum
	}
	return 0
}

func (m *ItemHelp) GetHelpNum() int32 {
	if m != nil {
		return m.HelpNum
	}
	return 0
}

func (m *ItemHelp) GetEvents() []*ItemEvent {
	if m != nil {
		return m.Events
	}
	return nil
}

func (m *ItemHelp) GetOverdue() bool {
	if m != nil {
		return m.Overdue
	}
	return false
}

type ItemEvent struct {
	Uid  int32 `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty" bson:"uid"`
	Type int32 `protobuf:"varint,2,opt,name=type,proto3" json:"type,omitempty" bson:"type"`
	// int32 count = 3 [(gogoproto.moretags) = "bson:\"count\""];
	Draw  bool `protobuf:"varint,4,opt,name=draw,proto3" json:"draw,omitempty" bson:"draw"`
	IsNew bool `protobuf:"varint,5,opt,name=isNew,proto3" json:"isNew,omitempty" bson:"isNew"`
}

func (m *ItemEvent) Reset()                    { *m = ItemEvent{} }
func (m *ItemEvent) String() string            { return proto.CompactTextString(m) }
func (*ItemEvent) ProtoMessage()               {}
func (*ItemEvent) Descriptor() ([]byte, []int) { return fileDescriptorTrade, []int{24} }

func (m *ItemEvent) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *ItemEvent) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *ItemEvent) GetDraw() bool {
	if m != nil {
		return m.Draw
	}
	return false
}

func (m *ItemEvent) GetIsNew() bool {
	if m != nil {
		return m.IsNew
	}
	return false
}

func init() {
	proto.RegisterType((*Goods)(nil), "protocol.Goods")
	proto.RegisterType((*GetGoodsInfo)(nil), "protocol.get_goods_info")
	proto.RegisterType((*GetGoodsInfoRet)(nil), "protocol.get_goods_info_ret")
	proto.RegisterType((*BuyGoods)(nil), "protocol.buy_goods")
	proto.RegisterType((*BuyGoodsRet)(nil), "protocol.buy_goods_ret")
	proto.RegisterType((*PublicGoods)(nil), "protocol.public_goods")
	proto.RegisterType((*PublicGoodsRet)(nil), "protocol.public_goods_ret")
	proto.RegisterType((*CancelGoods)(nil), "protocol.cancel_goods")
	proto.RegisterType((*CancelGoodsRet)(nil), "protocol.cancel_goods_ret")
	proto.RegisterType((*PublicItemHelp)(nil), "protocol.publicItemHelp")
	proto.RegisterType((*PublicItemHelpRet)(nil), "protocol.publicItemHelpRet")
	proto.RegisterType((*CancelItemHelp)(nil), "protocol.cancelItemHelp")
	proto.RegisterType((*CancelItemHelpRet)(nil), "protocol.cancelItemHelpRet")
	proto.RegisterType((*DrawItemHelp)(nil), "protocol.drawItemHelp")
	proto.RegisterType((*DrawItemHelpRet)(nil), "protocol.drawItemHelpRet")
	proto.RegisterType((*GetItemHelp)(nil), "protocol.getItemHelp")
	proto.RegisterType((*GetItemHelpRet)(nil), "protocol.getItemHelpRet")
	proto.RegisterType((*LootHelpItem)(nil), "protocol.lootHelpItem")
	proto.RegisterType((*LootHelpItemRet)(nil), "protocol.lootHelpItemRet")
	proto.RegisterType((*HelpItem)(nil), "protocol.helpItem")
	proto.RegisterType((*HelpItemRet)(nil), "protocol.helpItemRet")
	proto.RegisterType((*GetHelpItemHistory)(nil), "protocol.getHelpItemHistory")
	proto.RegisterType((*GetHelpItemHistoryRet)(nil), "protocol.getHelpItemHistoryRet")
	proto.RegisterType((*ItemHelp)(nil), "protocol.ItemHelp")
	proto.RegisterType((*ItemEvent)(nil), "protocol.ItemEvent")
}
func (m *Goods) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Goods) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTrade(dAtA, i, uint64(m.Id))
	}
	if m.Num != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTrade(dAtA, i, uint64(m.Num))
	}
	if m.Price != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTrade(dAtA, i, uint64(m.Price))
	}
	return i, nil
}

func (m *GetGoodsInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetGoodsInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTrade(dAtA, i, uint64(m.Uid))
	}
	return i, nil
}

func (m *GetGoodsInfoRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetGoodsInfoRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Goods) > 0 {
		for _, msg := range m.Goods {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTrade(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *BuyGoods) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuyGoods) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTrade(dAtA, i, uint64(m.Uid))
	}
	if m.Itemid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTrade(dAtA, i, uint64(m.Itemid))
	}
	if m.Num != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTrade(dAtA, i, uint64(m.Num))
	}
	if m.Social != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTrade(dAtA, i, uint64(m.Social))
	}
	return i, nil
}

func (m *BuyGoodsRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuyGoodsRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Num != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTrade(dAtA, i, uint64(m.Num))
	}
	if m.Fee != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTrade(dAtA, i, uint64(m.Fee))
	}
	return i, nil
}

func (m *PublicGoods) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PublicGoods) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTrade(dAtA, i, uint64(m.Uid))
	}
	if m.Goods != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTrade(dAtA, i, uint64(m.Goods.Size()))
		n1, err := m.Goods.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *PublicGoodsRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PublicGoodsRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result {
		dAtA[i] = 0x8
		i++
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *CancelGoods) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CancelGoods) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTrade(dAtA, i, uint64(m.Uid))
	}
	if m.Itemid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTrade(dAtA, i, uint64(m.Itemid))
	}
	return i, nil
}

func (m *CancelGoodsRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CancelGoodsRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Goods != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTrade(dAtA, i, uint64(m.Goods.Size()))
		n2, err := m.Goods.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *PublicItemHelp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PublicItemHelp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ItemID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTrade(dAtA, i, uint64(m.ItemID))
	}
	if m.IsWatchAd {
		dAtA[i] = 0x10
		i++
		if m.IsWatchAd {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *PublicItemHelpRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PublicItemHelpRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Cost != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTrade(dAtA, i, uint64(m.Cost))
	}
	if m.ItemHelp != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTrade(dAtA, i, uint64(m.ItemHelp.Size()))
		n3, err := m.ItemHelp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *CancelItemHelp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CancelItemHelp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ItemID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTrade(dAtA, i, uint64(m.ItemID))
	}
	return i, nil
}

func (m *CancelItemHelpRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CancelItemHelpRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result {
		dAtA[i] = 0x8
		i++
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *DrawItemHelp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DrawItemHelp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ItemID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTrade(dAtA, i, uint64(m.ItemID))
	}
	if m.Cancel {
		dAtA[i] = 0x10
		i++
		if m.Cancel {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *DrawItemHelpRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DrawItemHelpRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ItemID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTrade(dAtA, i, uint64(m.ItemID))
	}
	if m.ItemNum != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTrade(dAtA, i, uint64(m.ItemNum))
	}
	if m.ItemHelp != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTrade(dAtA, i, uint64(m.ItemHelp.Size()))
		n4, err := m.ItemHelp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *GetItemHelp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetItemHelp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTrade(dAtA, i, uint64(m.Uid))
	}
	if len(m.Id) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTrade(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.NewsFeedID) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTrade(dAtA, i, uint64(len(m.NewsFeedID)))
		i += copy(dAtA[i:], m.NewsFeedID)
	}
	return i, nil
}

func (m *GetItemHelpRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetItemHelpRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ItemHelp != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTrade(dAtA, i, uint64(m.ItemHelp.Size()))
		n5, err := m.ItemHelp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *LootHelpItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LootHelpItem) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTrade(dAtA, i, uint64(m.Uid))
	}
	if m.ItemID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTrade(dAtA, i, uint64(m.ItemID))
	}
	if m.Power != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTrade(dAtA, i, uint64(m.Power))
	}
	if len(m.Costs) > 0 {
		dAtA7 := make([]byte, len(m.Costs)*10)
		var j6 int
		for _, num1 := range m.Costs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA7[j6] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j6++
			}
			dAtA7[j6] = uint8(num)
			j6++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintTrade(dAtA, i, uint64(j6))
		i += copy(dAtA[i:], dAtA7[:j6])
	}
	if m.Limit != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintTrade(dAtA, i, uint64(m.Limit))
	}
	if len(m.Probs) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTrade(dAtA, i, uint64(len(m.Probs)*4))
		for _, num := range m.Probs {
			f8 := math.Float32bits(float32(num))
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(f8))
			i += 4
		}
	}
	if m.AddProb != 0 {
		dAtA[i] = 0x3d
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.AddProb))))
		i += 4
	}
	if m.IsWatchAd {
		dAtA[i] = 0x40
		i++
		if m.IsWatchAd {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.EachFollow {
		dAtA[i] = 0x48
		i++
		if m.EachFollow {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Id) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintTrade(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	return i, nil
}

func (m *LootHelpItemRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LootHelpItemRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result {
		dAtA[i] = 0x8
		i++
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Cost != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTrade(dAtA, i, uint64(m.Cost))
	}
	if m.ItemHelp != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTrade(dAtA, i, uint64(m.ItemHelp.Size()))
		n9, err := m.ItemHelp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.EachFollow {
		dAtA[i] = 0x20
		i++
		if m.EachFollow {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *HelpItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HelpItem) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTrade(dAtA, i, uint64(m.Uid))
	}
	if m.ItemID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTrade(dAtA, i, uint64(m.ItemID))
	}
	if m.Limit != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTrade(dAtA, i, uint64(m.Limit))
	}
	if m.EachFollow {
		dAtA[i] = 0x20
		i++
		if m.EachFollow {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Id) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintTrade(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	return i, nil
}

func (m *HelpItemRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HelpItemRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result {
		dAtA[i] = 0x8
		i++
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.GayPoint != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTrade(dAtA, i, uint64(m.GayPoint))
	}
	if m.ItemHelp != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTrade(dAtA, i, uint64(m.ItemHelp.Size()))
		n10, err := m.ItemHelp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.EachFollow {
		dAtA[i] = 0x20
		i++
		if m.EachFollow {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *GetHelpItemHistory) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetHelpItemHistory) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTrade(dAtA, i, uint64(m.Uid))
	}
	if m.Skip != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTrade(dAtA, i, uint64(m.Skip))
	}
	if m.Limit != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTrade(dAtA, i, uint64(m.Limit))
	}
	if m.Count {
		dAtA[i] = 0x20
		i++
		if m.Count {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *GetHelpItemHistoryRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetHelpItemHistoryRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ItemHelp) > 0 {
		for _, msg := range m.ItemHelp {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTrade(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Count != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTrade(dAtA, i, uint64(m.Count))
	}
	return i, nil
}

func (m *ItemHelp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ItemHelp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTrade(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.Uid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTrade(dAtA, i, uint64(m.Uid))
	}
	if m.ItemID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTrade(dAtA, i, uint64(m.ItemID))
	}
	if m.ItemNum != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTrade(dAtA, i, uint64(m.ItemNum))
	}
	if m.DrawNum != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintTrade(dAtA, i, uint64(m.DrawNum))
	}
	if m.LootNum != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintTrade(dAtA, i, uint64(m.LootNum))
	}
	if m.HelpNum != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintTrade(dAtA, i, uint64(m.HelpNum))
	}
	if len(m.Events) > 0 {
		for _, msg := range m.Events {
			dAtA[i] = 0x42
			i++
			i = encodeVarintTrade(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Overdue {
		dAtA[i] = 0x50
		i++
		if m.Overdue {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ItemEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ItemEvent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTrade(dAtA, i, uint64(m.Uid))
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTrade(dAtA, i, uint64(m.Type))
	}
	if m.Draw {
		dAtA[i] = 0x20
		i++
		if m.Draw {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsNew {
		dAtA[i] = 0x28
		i++
		if m.IsNew {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func encodeVarintTrade(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Goods) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovTrade(uint64(m.Id))
	}
	if m.Num != 0 {
		n += 1 + sovTrade(uint64(m.Num))
	}
	if m.Price != 0 {
		n += 1 + sovTrade(uint64(m.Price))
	}
	return n
}

func (m *GetGoodsInfo) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovTrade(uint64(m.Uid))
	}
	return n
}

func (m *GetGoodsInfoRet) Size() (n int) {
	var l int
	_ = l
	if len(m.Goods) > 0 {
		for _, e := range m.Goods {
			l = e.Size()
			n += 1 + l + sovTrade(uint64(l))
		}
	}
	return n
}

func (m *BuyGoods) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovTrade(uint64(m.Uid))
	}
	if m.Itemid != 0 {
		n += 1 + sovTrade(uint64(m.Itemid))
	}
	if m.Num != 0 {
		n += 1 + sovTrade(uint64(m.Num))
	}
	if m.Social != 0 {
		n += 1 + sovTrade(uint64(m.Social))
	}
	return n
}

func (m *BuyGoodsRet) Size() (n int) {
	var l int
	_ = l
	if m.Num != 0 {
		n += 1 + sovTrade(uint64(m.Num))
	}
	if m.Fee != 0 {
		n += 1 + sovTrade(uint64(m.Fee))
	}
	return n
}

func (m *PublicGoods) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovTrade(uint64(m.Uid))
	}
	if m.Goods != nil {
		l = m.Goods.Size()
		n += 1 + l + sovTrade(uint64(l))
	}
	return n
}

func (m *PublicGoodsRet) Size() (n int) {
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	return n
}

func (m *CancelGoods) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovTrade(uint64(m.Uid))
	}
	if m.Itemid != 0 {
		n += 1 + sovTrade(uint64(m.Itemid))
	}
	return n
}

func (m *CancelGoodsRet) Size() (n int) {
	var l int
	_ = l
	if m.Goods != nil {
		l = m.Goods.Size()
		n += 1 + l + sovTrade(uint64(l))
	}
	return n
}

func (m *PublicItemHelp) Size() (n int) {
	var l int
	_ = l
	if m.ItemID != 0 {
		n += 1 + sovTrade(uint64(m.ItemID))
	}
	if m.IsWatchAd {
		n += 2
	}
	return n
}

func (m *PublicItemHelpRet) Size() (n int) {
	var l int
	_ = l
	if m.Cost != 0 {
		n += 1 + sovTrade(uint64(m.Cost))
	}
	if m.ItemHelp != nil {
		l = m.ItemHelp.Size()
		n += 1 + l + sovTrade(uint64(l))
	}
	return n
}

func (m *CancelItemHelp) Size() (n int) {
	var l int
	_ = l
	if m.ItemID != 0 {
		n += 1 + sovTrade(uint64(m.ItemID))
	}
	return n
}

func (m *CancelItemHelpRet) Size() (n int) {
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	return n
}

func (m *DrawItemHelp) Size() (n int) {
	var l int
	_ = l
	if m.ItemID != 0 {
		n += 1 + sovTrade(uint64(m.ItemID))
	}
	if m.Cancel {
		n += 2
	}
	return n
}

func (m *DrawItemHelpRet) Size() (n int) {
	var l int
	_ = l
	if m.ItemID != 0 {
		n += 1 + sovTrade(uint64(m.ItemID))
	}
	if m.ItemNum != 0 {
		n += 1 + sovTrade(uint64(m.ItemNum))
	}
	if m.ItemHelp != nil {
		l = m.ItemHelp.Size()
		n += 1 + l + sovTrade(uint64(l))
	}
	return n
}

func (m *GetItemHelp) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovTrade(uint64(m.Uid))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTrade(uint64(l))
	}
	l = len(m.NewsFeedID)
	if l > 0 {
		n += 1 + l + sovTrade(uint64(l))
	}
	return n
}

func (m *GetItemHelpRet) Size() (n int) {
	var l int
	_ = l
	if m.ItemHelp != nil {
		l = m.ItemHelp.Size()
		n += 1 + l + sovTrade(uint64(l))
	}
	return n
}

func (m *LootHelpItem) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovTrade(uint64(m.Uid))
	}
	if m.ItemID != 0 {
		n += 1 + sovTrade(uint64(m.ItemID))
	}
	if m.Power != 0 {
		n += 1 + sovTrade(uint64(m.Power))
	}
	if len(m.Costs) > 0 {
		l = 0
		for _, e := range m.Costs {
			l += sovTrade(uint64(e))
		}
		n += 1 + sovTrade(uint64(l)) + l
	}
	if m.Limit != 0 {
		n += 1 + sovTrade(uint64(m.Limit))
	}
	if len(m.Probs) > 0 {
		n += 1 + sovTrade(uint64(len(m.Probs)*4)) + len(m.Probs)*4
	}
	if m.AddProb != 0 {
		n += 5
	}
	if m.IsWatchAd {
		n += 2
	}
	if m.EachFollow {
		n += 2
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTrade(uint64(l))
	}
	return n
}

func (m *LootHelpItemRet) Size() (n int) {
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	if m.Cost != 0 {
		n += 1 + sovTrade(uint64(m.Cost))
	}
	if m.ItemHelp != nil {
		l = m.ItemHelp.Size()
		n += 1 + l + sovTrade(uint64(l))
	}
	if m.EachFollow {
		n += 2
	}
	return n
}

func (m *HelpItem) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovTrade(uint64(m.Uid))
	}
	if m.ItemID != 0 {
		n += 1 + sovTrade(uint64(m.ItemID))
	}
	if m.Limit != 0 {
		n += 1 + sovTrade(uint64(m.Limit))
	}
	if m.EachFollow {
		n += 2
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTrade(uint64(l))
	}
	return n
}

func (m *HelpItemRet) Size() (n int) {
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	if m.GayPoint != 0 {
		n += 1 + sovTrade(uint64(m.GayPoint))
	}
	if m.ItemHelp != nil {
		l = m.ItemHelp.Size()
		n += 1 + l + sovTrade(uint64(l))
	}
	if m.EachFollow {
		n += 2
	}
	return n
}

func (m *GetHelpItemHistory) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovTrade(uint64(m.Uid))
	}
	if m.Skip != 0 {
		n += 1 + sovTrade(uint64(m.Skip))
	}
	if m.Limit != 0 {
		n += 1 + sovTrade(uint64(m.Limit))
	}
	if m.Count {
		n += 2
	}
	return n
}

func (m *GetHelpItemHistoryRet) Size() (n int) {
	var l int
	_ = l
	if len(m.ItemHelp) > 0 {
		for _, e := range m.ItemHelp {
			l = e.Size()
			n += 1 + l + sovTrade(uint64(l))
		}
	}
	if m.Count != 0 {
		n += 1 + sovTrade(uint64(m.Count))
	}
	return n
}

func (m *ItemHelp) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTrade(uint64(l))
	}
	if m.Uid != 0 {
		n += 1 + sovTrade(uint64(m.Uid))
	}
	if m.ItemID != 0 {
		n += 1 + sovTrade(uint64(m.ItemID))
	}
	if m.ItemNum != 0 {
		n += 1 + sovTrade(uint64(m.ItemNum))
	}
	if m.DrawNum != 0 {
		n += 1 + sovTrade(uint64(m.DrawNum))
	}
	if m.LootNum != 0 {
		n += 1 + sovTrade(uint64(m.LootNum))
	}
	if m.HelpNum != 0 {
		n += 1 + sovTrade(uint64(m.HelpNum))
	}
	if len(m.Events) > 0 {
		for _, e := range m.Events {
			l = e.Size()
			n += 1 + l + sovTrade(uint64(l))
		}
	}
	if m.Overdue {
		n += 2
	}
	return n
}

func (m *ItemEvent) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovTrade(uint64(m.Uid))
	}
	if m.Type != 0 {
		n += 1 + sovTrade(uint64(m.Type))
	}
	if m.Draw {
		n += 2
	}
	if m.IsNew {
		n += 2
	}
	return n
}

func sovTrade(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTrade(x uint64) (n int) {
	return sovTrade(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Goods) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTrade
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Goods: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Goods: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			m.Num = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Num |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			m.Price = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Price |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTrade(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTrade
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetGoodsInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTrade
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: get_goods_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: get_goods_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTrade(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTrade
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetGoodsInfoRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTrade
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: get_goods_info_ret: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: get_goods_info_ret: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Goods", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTrade
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Goods = append(m.Goods, &Goods{})
			if err := m.Goods[len(m.Goods)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTrade(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTrade
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuyGoods) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTrade
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: buy_goods: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: buy_goods: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Itemid", wireType)
			}
			m.Itemid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Itemid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			m.Num = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Num |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Social", wireType)
			}
			m.Social = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Social |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTrade(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTrade
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuyGoodsRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTrade
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: buy_goods_ret: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: buy_goods_ret: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			m.Num = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Num |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			m.Fee = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fee |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTrade(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTrade
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PublicGoods) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTrade
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: public_goods: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: public_goods: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Goods", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTrade
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Goods == nil {
				m.Goods = &Goods{}
			}
			if err := m.Goods.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTrade(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTrade
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PublicGoodsRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTrade
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: public_goods_ret: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: public_goods_ret: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTrade(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTrade
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CancelGoods) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTrade
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: cancel_goods: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: cancel_goods: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Itemid", wireType)
			}
			m.Itemid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Itemid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTrade(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTrade
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CancelGoodsRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTrade
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: cancel_goods_ret: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: cancel_goods_ret: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Goods", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTrade
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Goods == nil {
				m.Goods = &Goods{}
			}
			if err := m.Goods.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTrade(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTrade
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PublicItemHelp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTrade
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: publicItemHelp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: publicItemHelp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemID", wireType)
			}
			m.ItemID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsWatchAd", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsWatchAd = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTrade(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTrade
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PublicItemHelpRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTrade
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: publicItemHelpRet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: publicItemHelpRet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cost", wireType)
			}
			m.Cost = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cost |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemHelp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTrade
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ItemHelp == nil {
				m.ItemHelp = &ItemHelp{}
			}
			if err := m.ItemHelp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTrade(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTrade
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CancelItemHelp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTrade
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: cancelItemHelp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: cancelItemHelp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemID", wireType)
			}
			m.ItemID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTrade(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTrade
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CancelItemHelpRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTrade
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: cancelItemHelpRet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: cancelItemHelpRet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTrade(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTrade
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DrawItemHelp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTrade
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: drawItemHelp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: drawItemHelp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemID", wireType)
			}
			m.ItemID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cancel", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Cancel = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTrade(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTrade
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DrawItemHelpRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTrade
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: drawItemHelpRet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: drawItemHelpRet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemID", wireType)
			}
			m.ItemID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemNum", wireType)
			}
			m.ItemNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemHelp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTrade
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ItemHelp == nil {
				m.ItemHelp = &ItemHelp{}
			}
			if err := m.ItemHelp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTrade(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTrade
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetItemHelp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTrade
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: getItemHelp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: getItemHelp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTrade
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewsFeedID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTrade
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewsFeedID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTrade(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTrade
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetItemHelpRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTrade
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: getItemHelpRet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: getItemHelpRet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemHelp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTrade
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ItemHelp == nil {
				m.ItemHelp = &ItemHelp{}
			}
			if err := m.ItemHelp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTrade(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTrade
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LootHelpItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTrade
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lootHelpItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lootHelpItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemID", wireType)
			}
			m.ItemID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Power", wireType)
			}
			m.Power = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Power |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTrade
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Costs = append(m.Costs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTrade
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTrade
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTrade
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Costs = append(m.Costs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Costs", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Probs = append(m.Probs, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTrade
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTrade
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Probs = append(m.Probs, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Probs", wireType)
			}
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddProb", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.AddProb = float32(math.Float32frombits(v))
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsWatchAd", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsWatchAd = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EachFollow", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EachFollow = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTrade
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTrade(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTrade
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LootHelpItemRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTrade
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lootHelpItemRet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lootHelpItemRet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cost", wireType)
			}
			m.Cost = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cost |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemHelp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTrade
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ItemHelp == nil {
				m.ItemHelp = &ItemHelp{}
			}
			if err := m.ItemHelp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EachFollow", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EachFollow = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTrade(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTrade
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HelpItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTrade
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: helpItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: helpItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemID", wireType)
			}
			m.ItemID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EachFollow", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EachFollow = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTrade
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTrade(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTrade
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HelpItemRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTrade
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: helpItemRet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: helpItemRet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GayPoint", wireType)
			}
			m.GayPoint = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GayPoint |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemHelp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTrade
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ItemHelp == nil {
				m.ItemHelp = &ItemHelp{}
			}
			if err := m.ItemHelp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EachFollow", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EachFollow = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTrade(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTrade
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetHelpItemHistory) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTrade
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: getHelpItemHistory: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: getHelpItemHistory: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Skip", wireType)
			}
			m.Skip = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Skip |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Count = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTrade(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTrade
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetHelpItemHistoryRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTrade
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: getHelpItemHistoryRet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: getHelpItemHistoryRet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemHelp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTrade
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ItemHelp = append(m.ItemHelp, &ItemHelp{})
			if err := m.ItemHelp[len(m.ItemHelp)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTrade(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTrade
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ItemHelp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTrade
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ItemHelp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ItemHelp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTrade
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemID", wireType)
			}
			m.ItemID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemNum", wireType)
			}
			m.ItemNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DrawNum", wireType)
			}
			m.DrawNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DrawNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LootNum", wireType)
			}
			m.LootNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LootNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HelpNum", wireType)
			}
			m.HelpNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HelpNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Events", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTrade
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Events = append(m.Events, &ItemEvent{})
			if err := m.Events[len(m.Events)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Overdue", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Overdue = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTrade(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTrade
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ItemEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTrade
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ItemEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ItemEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Draw", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Draw = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsNew", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsNew = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTrade(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTrade
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTrade(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTrade
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTrade
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTrade
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTrade
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTrade(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTrade = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTrade   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("trade.proto", fileDescriptorTrade) }

var fileDescriptorTrade = []byte{
	// 942 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x56, 0xcd, 0x8e, 0xe2, 0x46,
	0x10, 0x96, 0x31, 0x30, 0xa6, 0x60, 0x19, 0xc6, 0x49, 0x46, 0xd6, 0x2a, 0x1a, 0x50, 0x47, 0x89,
	0xc8, 0x1f, 0x2b, 0x65, 0x2f, 0xf9, 0x91, 0x36, 0x09, 0x22, 0xb3, 0x8b, 0x14, 0x4d, 0x56, 0x7d,
	0xd9, 0x53, 0x84, 0x8c, 0xdd, 0x40, 0x2b, 0x86, 0x46, 0x76, 0x7b, 0xd1, 0xe4, 0x1d, 0x72, 0xc8,
	0x03, 0x44, 0x79, 0x9d, 0x1c, 0xf3, 0x04, 0x28, 0x9a, 0x47, 0xe0, 0x94, 0x63, 0xd4, 0xd5, 0x6d,
	0x63, 0x60, 0x99, 0x21, 0x51, 0x4e, 0x74, 0x55, 0x7d, 0xf5, 0xf7, 0x75, 0x55, 0x1b, 0xa8, 0xcb,
	0xd8, 0x0f, 0x59, 0x6f, 0x19, 0x0b, 0x29, 0x5c, 0x07, 0x7f, 0x02, 0x11, 0x3d, 0xfe, 0x74, 0xca,
	0xe5, 0x2c, 0x1d, 0xf7, 0x02, 0x31, 0x7f, 0x32, 0x15, 0x53, 0xf1, 0x04, 0x2d, 0xe3, 0x74, 0x82,
	0x12, 0x0a, 0x78, 0xd2, 0x8e, 0xe4, 0x6b, 0xa8, 0x3c, 0x17, 0x22, 0x4c, 0xdc, 0x26, 0x94, 0x78,
	0xe8, 0x59, 0x1d, 0xab, 0x5b, 0xa1, 0x25, 0x1e, 0xba, 0x2d, 0xb0, 0x17, 0xe9, 0xdc, 0x2b, 0xa1,
	0x42, 0x1d, 0xdd, 0xb7, 0xa1, 0xb2, 0x8c, 0x79, 0xc0, 0x3c, 0x1b, 0x75, 0x5a, 0x20, 0x04, 0x9a,
	0x53, 0x26, 0x47, 0x53, 0x15, 0x64, 0xc4, 0x17, 0x13, 0xa1, 0x3c, 0xd3, 0x3c, 0x94, 0x3a, 0x92,
	0xaf, 0xc0, 0xdd, 0xc5, 0x8c, 0x62, 0x26, 0xdd, 0xf7, 0xa1, 0x82, 0x1a, 0xcf, 0xea, 0xd8, 0xdd,
	0xfa, 0x67, 0xe7, 0xbd, 0xac, 0x87, 0x1e, 0x56, 0x44, 0xb5, 0x95, 0x8c, 0xa0, 0x36, 0x4e, 0x6f,
	0xb5, 0xf3, 0x61, 0x6c, 0xf7, 0x12, 0xaa, 0x5c, 0xb2, 0x39, 0x0f, 0x4d, 0xa9, 0x46, 0xca, 0xea,
	0xb7, 0xb7, 0xf5, 0x5f, 0x42, 0x35, 0x11, 0x01, 0xf7, 0x23, 0xaf, 0xac, 0x91, 0x5a, 0x22, 0x4f,
	0xe1, 0x51, 0x9e, 0x00, 0x0b, 0x33, 0xae, 0xd6, 0xd6, 0xb5, 0x05, 0xf6, 0x84, 0xb1, 0x8c, 0x8c,
	0x09, 0x63, 0xe4, 0x39, 0x34, 0x96, 0xe9, 0x38, 0xe2, 0xc1, 0xd1, 0xc2, 0xf2, 0xf6, 0x94, 0xd7,
	0xf1, 0xf6, 0x3e, 0x82, 0x56, 0x31, 0x10, 0x16, 0x70, 0x09, 0xd5, 0x98, 0x25, 0x69, 0x24, 0x31,
	0x9e, 0x43, 0x8d, 0x44, 0x3e, 0x87, 0x46, 0xe0, 0x2f, 0x02, 0x16, 0xfd, 0x5b, 0x36, 0xc8, 0x17,
	0xd0, 0x2a, 0x7a, 0xee, 0xf3, 0x7f, 0x5f, 0x81, 0xd7, 0xd0, 0xd4, 0x05, 0x0e, 0x25, 0x9b, 0xbf,
	0x60, 0xd1, 0x32, 0x4b, 0x32, 0x1c, 0x98, 0xcc, 0x46, 0x72, 0xdf, 0x85, 0x1a, 0x4f, 0x5e, 0xf9,
	0x32, 0x98, 0x7d, 0xab, 0xf3, 0x3b, 0x74, 0xab, 0x20, 0xaf, 0xe0, 0x62, 0x37, 0x0e, 0x65, 0xd2,
	0x75, 0xa1, 0x1c, 0x88, 0x44, 0x9a, 0x40, 0x78, 0x76, 0x7b, 0xe0, 0x70, 0x03, 0x31, 0xdc, 0xb9,
	0xdb, 0xd2, 0x72, 0xe7, 0x1c, 0x43, 0xba, 0xd0, 0xd4, 0xbd, 0x3d, 0x54, 0x20, 0xf9, 0x18, 0x2e,
	0x76, 0x91, 0xf4, 0x1e, 0xb2, 0x9f, 0x41, 0x23, 0x8c, 0xfd, 0xd5, 0x83, 0x5d, 0x5f, 0x42, 0x55,
	0x07, 0x35, 0x2d, 0x1b, 0x89, 0x24, 0x70, 0x5e, 0xf4, 0x37, 0xa9, 0xde, 0x18, 0xc2, 0x83, 0x33,
	0x75, 0xba, 0xc9, 0xf7, 0x2d, 0x13, 0x77, 0xb8, 0xb0, 0x4f, 0xe0, 0xe2, 0x07, 0xa8, 0x4f, 0x99,
	0xcc, 0x6b, 0x3e, 0x1c, 0x10, 0xbd, 0xe6, 0x2a, 0x4b, 0x0d, 0xd7, 0xfc, 0x0a, 0x60, 0xc1, 0x56,
	0xc9, 0x35, 0x63, 0xe1, 0x70, 0x80, 0x29, 0x6a, 0xb4, 0xa0, 0x21, 0xdf, 0xe0, 0x7a, 0x17, 0x9b,
	0x28, 0x96, 0x64, 0x9d, 0x50, 0xd2, 0xdf, 0x16, 0x34, 0x22, 0x21, 0xa4, 0x12, 0x94, 0xf9, 0xf8,
	0xd4, 0x0e, 0x07, 0xc5, 0xa9, 0x1d, 0x0e, 0xf0, 0xc5, 0x11, 0x2b, 0x16, 0xe7, 0x2f, 0x8e, 0x12,
	0x94, 0x56, 0xcd, 0x49, 0xe2, 0x95, 0x3b, 0xb6, 0xd2, 0xa2, 0xa0, 0xb4, 0x11, 0x9f, 0x73, 0xe9,
	0x55, 0x34, 0x16, 0x05, 0xfd, 0x66, 0x89, 0x71, 0xe2, 0x55, 0x3b, 0x76, 0xb7, 0x44, 0xb5, 0xa0,
	0xf8, 0xf6, 0xc3, 0xf0, 0x65, 0x2c, 0xc6, 0xde, 0x59, 0xc7, 0xea, 0x96, 0x68, 0x26, 0xee, 0x8e,
	0xb0, 0xb3, 0x37, 0xc2, 0x8a, 0x2c, 0xe6, 0x07, 0xb3, 0x6b, 0x11, 0x45, 0x62, 0xe5, 0xd5, 0xd0,
	0x5c, 0xd0, 0x18, 0x72, 0x21, 0x23, 0x97, 0xfc, 0x62, 0xc1, 0x79, 0xb1, 0xf5, 0x7b, 0xc6, 0x2d,
	0xdf, 0x84, 0xd2, 0x91, 0x4d, 0x38, 0xe1, 0xf6, 0xf7, 0xea, 0x2b, 0xef, 0xd7, 0x47, 0x7e, 0x06,
	0x67, 0xf6, 0x9f, 0x6e, 0x41, 0x33, 0x6b, 0x17, 0x99, 0x7d, 0x20, 0xd7, 0x01, 0x17, 0xbf, 0x5a,
	0x50, 0x9f, 0x9d, 0xc0, 0xc3, 0x63, 0x70, 0xa6, 0xfe, 0xed, 0x4b, 0xc1, 0x17, 0x19, 0x17, 0xb9,
	0xfc, 0xbf, 0xf3, 0x31, 0xc1, 0xef, 0x52, 0x76, 0x3b, 0x2f, 0x78, 0x22, 0x45, 0x7c, 0xfb, 0x06,
	0x66, 0x5c, 0x28, 0x27, 0x3f, 0xf1, 0x65, 0x76, 0x37, 0xea, 0x7c, 0x84, 0x15, 0x9c, 0xcd, 0x74,
	0x21, 0x4d, 0x32, 0x2d, 0x90, 0x1f, 0xe1, 0x9d, 0xc3, 0x3c, 0x87, 0xbb, 0x64, 0x3f, 0xd8, 0x50,
	0x1e, 0x5e, 0x57, 0x62, 0xc2, 0xff, 0x66, 0x83, 0x33, 0xdc, 0xf6, 0x9c, 0x7d, 0xc7, 0x6b, 0xfd,
	0xe6, 0x66, 0xdd, 0x86, 0x71, 0x22, 0x16, 0x5f, 0x92, 0x11, 0x0f, 0x09, 0x2e, 0x7c, 0x47, 0x77,
	0x87, 0x01, 0x8a, 0x00, 0xf5, 0x9d, 0xd6, 0xdd, 0x7e, 0x98, 0xcf, 0x01, 0xb6, 0xd6, 0xbf, 0xd8,
	0xac, 0xdb, 0x8f, 0x34, 0xc8, 0xbc, 0xa3, 0xf9, 0x68, 0x7c, 0x02, 0x67, 0x43, 0xf3, 0x70, 0xe1,
	0x37, 0xb5, 0xef, 0x6e, 0xd6, 0xed, 0xe6, 0x16, 0x7b, 0x93, 0xce, 0x09, 0xcd, 0x20, 0x0a, 0x3d,
	0x88, 0xfd, 0x95, 0x42, 0x57, 0xf6, 0xd1, 0xa1, 0x36, 0x10, 0x9a, 0x41, 0x14, 0xfa, 0x7b, 0x21,
	0xa4, 0x42, 0x57, 0xf7, 0xd1, 0x91, 0x36, 0x10, 0x9a, 0x41, 0x14, 0x5a, 0x4d, 0x97, 0x42, 0x9f,
	0xed, 0xa3, 0x8d, 0x81, 0xd0, 0x0c, 0xe2, 0x3e, 0x83, 0xea, 0x77, 0xaf, 0xd9, 0x42, 0x26, 0x9e,
	0x83, 0xac, 0xbf, 0xb5, 0xcb, 0x3a, 0xda, 0x8a, 0x7d, 0x33, 0x04, 0x13, 0x6a, 0xbc, 0x54, 0x36,
	0xf1, 0x9a, 0xc5, 0x61, 0xca, 0x70, 0xc2, 0x9d, 0x62, 0x36, 0x63, 0x20, 0x34, 0x83, 0x90, 0xdf,
	0x2d, 0xa8, 0xe5, 0x61, 0xb3, 0x0b, 0xb0, 0x8e, 0x5f, 0xc0, 0x7b, 0x50, 0x96, 0xb7, 0x4b, 0xf3,
	0x77, 0xa3, 0x7f, 0xbe, 0x59, 0xb7, 0xeb, 0x1a, 0xa2, 0xb4, 0x84, 0xa2, 0x51, 0x81, 0x14, 0x67,
	0x7a, 0xd0, 0x8a, 0x20, 0xa5, 0x25, 0x14, 0x8d, 0xee, 0x07, 0x50, 0xe1, 0xc9, 0x0d, 0x5b, 0x21,
	0xdf, 0x4e, 0xbf, 0xb5, 0x59, 0xb7, 0x1b, 0xe6, 0x76, 0x94, 0x9a, 0x50, 0x6d, 0xee, 0x37, 0xfe,
	0xb8, 0xbb, 0xb2, 0xfe, 0xbc, 0xbb, 0xb2, 0xfe, 0xba, 0xbb, 0xb2, 0xc6, 0x55, 0x24, 0xe3, 0xe9,
	0x3f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x56, 0x4b, 0x23, 0xbe, 0x62, 0x0a, 0x00, 0x00,
}
